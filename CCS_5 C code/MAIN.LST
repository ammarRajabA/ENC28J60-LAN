CCS PCH C Compiler, Version 5.021d, 1               12-‰Ì”«‰-14 00:23
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\Ammar\Desktop\CSS_5\main.lst

               ROM used:   36342 bytes (74%)
                           Largest free fragment is 12806
               RAM used:   889 (27%) at main() level
                           1083 (33%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   7B04
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   00D2
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #include <main.h> 
.................... #include <18F4585.h> 
.................... //////////// Standard Header file for the PIC18F4585 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4585 
0096:  MOVFF  FF2,0D
009A:  BCF    FF2.7
009C:  CLRF   FF7
009E:  ADDLW  B0
00A0:  MOVWF  FF6
00A2:  MOVLW  00
00A4:  ADDWFC FF7,F
00A6:  TBLRD*+
00A8:  MOVF   FF5,W
00AA:  BTFSC  0D.7
00AC:  BSF    FF2.7
00AE:  RETURN 0
00B0:  DATA 30,30
00B2:  DATA 00,00
*
00D8:  DATA 48,54
00DA:  DATA 54,50
00DC:  DATA 2F,31
00DE:  DATA 2E,31
00E0:  DATA 20,25
00E2:  DATA 4C,55
00E4:  DATA 20,00
00E6:  DATA 41,75
00E8:  DATA 74,68
00EA:  DATA 6F,72
00EC:  DATA 69,7A
00EE:  DATA 61,74
00F0:  DATA 69,6F
00F2:  DATA 6E,20
00F4:  DATA 52,65
00F6:  DATA 71,75
00F8:  DATA 69,72
00FA:  DATA 65,64
00FC:  DATA 00,00
00FE:  DATA 4E,6F
0100:  DATA 74,20
0102:  DATA 46,6F
0104:  DATA 75,6E
0106:  DATA 64,00
0108:  DATA 53,65
010A:  DATA 72,76
010C:  DATA 65,72
010E:  DATA 20,45
0110:  DATA 72,72
0112:  DATA 6F,72
0114:  DATA 00,00
0116:  DATA 43,6F
0118:  DATA 6E,74
011A:  DATA 65,6E
011C:  DATA 74,2D
011E:  DATA 54,79
0120:  DATA 70,65
0122:  DATA 3A,20
0124:  DATA 00,00
0126:  DATA 4C,61
0128:  DATA 73,74
012A:  DATA 2D,4D
012C:  DATA 6F,64
012E:  DATA 69,66
0130:  DATA 69,65
0132:  DATA 64,3A
0134:  DATA 20,54
0136:  DATA 75,65
0138:  DATA 2C,20
013A:  DATA 31,35
013C:  DATA 20,4E
013E:  DATA 6F,76
0140:  DATA 20,31
0142:  DATA 39,39
0144:  DATA 34,20
0146:  DATA 31,32
0148:  DATA 3A,34
014A:  DATA 35,3A
014C:  DATA 32,36
014E:  DATA 20,47
0150:  DATA 4D,54
0152:  DATA 0D,0A
0154:  DATA 00,00
0156:  DATA 43,61
0158:  DATA 63,68
015A:  DATA 65,2D
015C:  DATA 43,6F
015E:  DATA 6E,74
0160:  DATA 72,6F
0162:  DATA 6C,3A
0164:  DATA 20,6E
0166:  DATA 6F,2D
0168:  DATA 63,61
016A:  DATA 63,68
016C:  DATA 65,0D
016E:  DATA 0A,00
0170:  DATA 43,6F
0172:  DATA 6E,6E
0174:  DATA 65,63
0176:  DATA 74,69
0178:  DATA 6F,6E
017A:  DATA 3A,20
017C:  DATA 63,6C
017E:  DATA 6F,73
0180:  DATA 65,0D
0182:  DATA 0A,00
0184:  DATA 65,72
0186:  DATA 72,6F
0188:  DATA 72,35
018A:  DATA 30,30
018C:  DATA 2E,68
018E:  DATA 74,6D
0190:  DATA 00,00
0192:  DATA 3C,68
0194:  DATA 74,6D
0196:  DATA 6C,3E
0198:  DATA 3C,62
019A:  DATA 6F,64
019C:  DATA 79,3E
019E:  DATA 3C,68
01A0:  DATA 31,3E
01A2:  DATA 35,30
01A4:  DATA 30,20
01A6:  DATA 45,72
01A8:  DATA 72,6F
01AA:  DATA 72,3C
01AC:  DATA 2F,68
01AE:  DATA 31,3E
01B0:  DATA 3C,68
01B2:  DATA 72,3E
01B4:  DATA 3C,70
01B6:  DATA 3E,49
01B8:  DATA 6E,74
01BA:  DATA 65,72
01BC:  DATA 6E,61
01BE:  DATA 6C,20
01C0:  DATA 73,65
01C2:  DATA 72,76
01C4:  DATA 65,72
01C6:  DATA 20,65
01C8:  DATA 72,72
01CA:  DATA 6F,72
01CC:  DATA 2E,3C
01CE:  DATA 2F,70
01D0:  DATA 3E,3C
01D2:  DATA 2F,62
01D4:  DATA 6F,64
01D6:  DATA 79,3E
01D8:  DATA 3C,2F
01DA:  DATA 68,74
01DC:  DATA 6D,6C
01DE:  DATA 3E,00
01E0:  DATA 69,6E
01E2:  DATA 64,65
01E4:  DATA 78,2E
01E6:  DATA 68,74
01E8:  DATA 6D,00
01EA:  DATA 65,72
01EC:  DATA 72,6F
01EE:  DATA 72,34
01F0:  DATA 30,34
01F2:  DATA 2E,68
01F4:  DATA 74,6D
01F6:  DATA 00,00
01F8:  DATA 65,72
01FA:  DATA 72,6F
01FC:  DATA 72,35
01FE:  DATA 30,30
0200:  DATA 2E,68
0202:  DATA 74,6D
0204:  DATA 00,00
0206:  DATA 65,72
0208:  DATA 72,6F
020A:  DATA 72,35
020C:  DATA 30,30
020E:  DATA 2E,68
0210:  DATA 74,6D
0212:  DATA 00,00
0214:  DATA 65,72
0216:  DATA 72,6F
0218:  DATA 72,35
021A:  DATA 30,30
021C:  DATA 2E,68
021E:  DATA 74,6D
0220:  DATA 00,00
0222:  DATA 57,65
0224:  DATA 6C,63
0226:  DATA 6F,6D
0228:  DATA 65,0A
022A:  DATA 00,00
022C:  DATA 0C,43
022E:  DATA 6C,69
0230:  DATA 65,6E
0232:  DATA 74,0A
0234:  DATA 64,69
0236:  DATA 73,63
0238:  DATA 6F,6E
023A:  DATA 6E,65
023C:  DATA 63,74
023E:  DATA 65,64
0240:  DATA 00,00
0242:  DATA 64,69
0244:  DATA 00,6F
0246:  DATA 64,00
0248:  DATA 72,64
024A:  DATA 00,72
024C:  DATA 61,00
024E:  DATA 77,6C
0250:  DATA 00,00
0252:  DATA 0C,50
0254:  DATA 72,6F
0256:  DATA 67,72
0258:  DATA 61,6D
025A:  DATA 20,65
025C:  DATA 6E,64
025E:  DATA 00,00
*
09F2:  TSTFSZ 01
09F4:  BRA    09FC
09F6:  TSTFSZ 02
09F8:  BRA    09FE
09FA:  BRA    0A0A
09FC:  INCF   02,F
09FE:  MOVFF  00,FEE
0A02:  DECFSZ 01,F
0A04:  BRA    09FE
0A06:  DECFSZ 02,F
0A08:  BRA    09FE
0A0A:  RETURN 0
*
179E:  TBLRD*+
17A0:  MOVF   FF5,F
17A2:  BZ    17BC
17A4:  MOVFF  FF6,37B
17A8:  MOVFF  FF7,37C
17AC:  MOVFF  FF5,393
17B0:  RCALL  1730
17B2:  MOVFF  37B,FF6
17B6:  MOVFF  37C,FF7
17BA:  BRA    179E
17BC:  RETURN 0
*
1AA4:  MOVLB  3
1AA6:  CLRF   xAD
1AA8:  CLRF   xAE
1AAA:  MOVLW  01
1AAC:  MOVWF  xAF
1AAE:  CLRF   FDA
1AB0:  CLRF   FD9
1AB2:  MOVLW  03
1AB4:  MOVWF  xB2
1AB6:  MOVLW  A5
1AB8:  MOVWF  xB1
1ABA:  MOVLW  03
1ABC:  MOVWF  FEA
1ABE:  MOVLW  A9
1AC0:  MOVWF  FE9
1AC2:  MOVFF  3B2,FE2
1AC6:  MOVFF  3B1,FE1
1ACA:  MOVFF  3AF,3B0
1ACE:  BCF    FD8.0
1AD0:  MOVF   FE5,W
1AD2:  MULWF  FEE
1AD4:  MOVF   FF3,W
1AD6:  ADDWFC xAD,F
1AD8:  MOVF   FF4,W
1ADA:  ADDWFC xAE,F
1ADC:  DECFSZ xB0,F
1ADE:  BRA    1ACE
1AE0:  MOVFF  3AD,FDE
1AE4:  MOVFF  3AE,3AD
1AE8:  CLRF   xAE
1AEA:  BTFSC  FD8.0
1AEC:  INCF   xAE,F
1AEE:  INCF   xB1,F
1AF0:  BTFSC  FD8.2
1AF2:  INCF   xB2,F
1AF4:  INCF   xAF,F
1AF6:  MOVF   xAF,W
1AF8:  SUBLW  05
1AFA:  BNZ   1ABA
1AFC:  MOVLB  0
1AFE:  GOTO   1B70 (RETURN)
1B02:  CLRF   01
1B04:  CLRF   02
1B06:  CLRF   00
1B08:  CLRF   03
1B0A:  MOVLB  3
1B0C:  MOVF   xAB,W
1B0E:  BNZ   1B14
1B10:  MOVF   xAA,W
1B12:  BZ    1B44
1B14:  MOVLW  10
1B16:  MOVWF  xAC
1B18:  BCF    FD8.0
1B1A:  RLCF   xA8,F
1B1C:  RLCF   xA9,F
1B1E:  RLCF   00,F
1B20:  RLCF   03,F
1B22:  MOVF   xAB,W
1B24:  SUBWF  03,W
1B26:  BNZ   1B2C
1B28:  MOVF   xAA,W
1B2A:  SUBWF  00,W
1B2C:  BNC   1B3C
1B2E:  MOVF   xAA,W
1B30:  SUBWF  00,F
1B32:  BTFSS  FD8.0
1B34:  DECF   03,F
1B36:  MOVF   xAB,W
1B38:  SUBWF  03,F
1B3A:  BSF    FD8.0
1B3C:  RLCF   01,F
1B3E:  RLCF   02,F
1B40:  DECFSZ xAC,F
1B42:  BRA    1B18
1B44:  MOVLB  0
1B46:  GOTO   1BB0 (RETURN)
*
31DE:  MOVFF  FF2,0D
31E2:  BCF    FF2.7
31E4:  ADDWF  FE8,W
31E6:  CLRF   FF7
31E8:  RLCF   FF7,F
31EA:  ADDLW  03
31EC:  MOVWF  FF6
31EE:  MOVLW  32
31F0:  ADDWFC FF7,F
31F2:  TBLRD*-
31F4:  MOVF   FF5,W
31F6:  MOVWF  FFA
31F8:  TBLRD*
31FA:  MOVF   FF5,W
31FC:  BTFSC  0D.7
31FE:  BSF    FF2.7
3200:  MOVWF  FF9
3202:  DATA 0A,2D
3204:  DATA 0E,2D
3206:  DATA 3E,2D
3208:  DATA F2,2D
320A:  DATA 80,2E
320C:  DATA 04,2F
320E:  DATA 00,30
3210:  DATA B2,30
3212:  DATA 06,31
3214:  DATA B2,30
3216:  DATA 06,31
3218:  DATA B2,30
321A:  DATA 06,31
*
3252:  MOVLB  3
3254:  MOVF   xD0,W
3256:  MULWF  xD2
3258:  MOVFF  FF3,01
325C:  MOVFF  FF4,00
3260:  MULWF  xD3
3262:  MOVF   FF3,W
3264:  ADDWF  00,F
3266:  MOVF   xD1,W
3268:  MULWF  xD2
326A:  MOVF   FF3,W
326C:  ADDWFC 00,W
326E:  MOVWF  02
3270:  MOVLB  0
3272:  RETURN 0
*
6EFE:  MOVLB  3
6F00:  MOVF   x7D,W
6F02:  CLRF   01
6F04:  SUBWF  x7C,W
6F06:  BC    6F0E
6F08:  MOVFF  37C,00
6F0C:  BRA    6F26
6F0E:  CLRF   00
6F10:  MOVLW  08
6F12:  MOVWF  x7E
6F14:  RLCF   x7C,F
6F16:  RLCF   00,F
6F18:  MOVF   x7D,W
6F1A:  SUBWF  00,W
6F1C:  BTFSC  FD8.0
6F1E:  MOVWF  00
6F20:  RLCF   01,F
6F22:  DECFSZ x7E,F
6F24:  BRA    6F14
6F26:  MOVLB  0
6F28:  RETURN 0
*
7362:  MOVFF  FEA,FE2
7366:  MOVFF  FE9,FE1
736A:  CLRF   01
736C:  BSF    00.0
736E:  TBLRD*+
7370:  MOVF   FF5,W
7372:  BTFSS  00.0
7374:  BRA    7380
7376:  SUBWF  FEE,W
7378:  BNZ   7380
737A:  MOVF   FF5,F
737C:  BNZ   736E
737E:  BRA    739A
7380:  BCF    00.0
7382:  MOVF   FF5,F
7384:  BNZ   736E
7386:  INCF   01,F
7388:  BSF    00.0
738A:  MOVFF  FE2,FEA
738E:  MOVFF  FE1,FE9
7392:  TBLRD*
7394:  MOVF   FF5,F
7396:  BNZ   736E
7398:  SETF   01
739A:  GOTO   7C7A (RETURN)
*
73C8:  MOVLB  3
73CA:  MOVF   x80,W
73CC:  ANDLW  07
73CE:  MOVWF  00
73D0:  RRCF   x80,W
73D2:  MOVWF  01
73D4:  RRCF   01,F
73D6:  RRCF   01,F
73D8:  MOVLW  1F
73DA:  ANDWF  01,F
73DC:  MOVF   01,W
73DE:  ADDWF  x82,W
73E0:  MOVWF  FE9
73E2:  MOVLW  00
73E4:  ADDWFC x83,W
73E6:  MOVWF  FEA
73E8:  CLRF   01
73EA:  INCF   01,F
73EC:  INCF   00,F
73EE:  BRA    73F2
73F0:  RLCF   01,F
73F2:  DECFSZ 00,F
73F4:  BRA    73F0
73F6:  MOVF   x81,F
73F8:  BZ    7400
73FA:  MOVF   01,W
73FC:  IORWF  FEF,F
73FE:  BRA    7406
7400:  COMF   01,F
7402:  MOVF   01,W
7404:  ANDWF  FEF,F
7406:  MOVLB  0
7408:  RETURN 0
*
76C2:  MOVFF  FF2,0D
76C6:  BCF    FF2.7
76C8:  ADDWF  FE8,W
76CA:  CLRF   FF7
76CC:  RLCF   FF7,F
76CE:  ADDLW  E7
76D0:  MOVWF  FF6
76D2:  MOVLW  76
76D4:  ADDWFC FF7,F
76D6:  TBLRD*-
76D8:  MOVF   FF5,W
76DA:  MOVWF  FFA
76DC:  TBLRD*
76DE:  MOVF   FF5,W
76E0:  BTFSC  0D.7
76E2:  BSF    FF2.7
76E4:  MOVWF  FF9
76E6:  DATA 48,74
76E8:  DATA C0,74
76EA:  DATA 3E,75
76EC:  DATA BC,75
76EE:  DATA 3A,76
*
799A:  MOVFF  FF2,0D
799E:  BCF    FF2.7
79A0:  ADDWF  FE8,W
79A2:  CLRF   FF7
79A4:  RLCF   FF7,F
79A6:  ADDLW  BF
79A8:  MOVWF  FF6
79AA:  MOVLW  79
79AC:  ADDWFC FF7,F
79AE:  TBLRD*-
79B0:  MOVF   FF5,W
79B2:  MOVWF  FFA
79B4:  TBLRD*
79B6:  MOVF   FF5,W
79B8:  BTFSC  0D.7
79BA:  BSF    FF2.7
79BC:  MOVWF  FF9
79BE:  DATA 3A,79
79C0:  DATA 48,79
79C2:  DATA 56,79
79C4:  DATA 64,79
79C6:  DATA 72,79
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... /* 
.................... TCP/IP Stack enabled. 
.................... Many TCP/IP configuration settings (servers enabled, ports used, 
.................... etc) are defined in TCPIPConfig.h. 
.................... Many hardware configuration settings (SPI port and GPIO pins used) 
.................... are defined in HardwareProfile.h. 
.................... */ 
....................  
.................... #include "tcpip/p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................  #include "PIC18F4585_registers.h" 
.................... #byte TOSU = 0xFFF 
....................  
.................... #word TOS = 0xFFD 
.................... #byte TOSH = 0xFFE 
.................... #byte TOSL = 0xFFD 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int STKPTR0:5; 
....................          unsigned int :1; 
....................          unsigned int STKUNF:1; 
....................          unsigned int STKFUL:1; 
....................       }; 
....................       struct { 
....................          unsigned int STKPTR:5; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :7; 
....................          unsigned int STKOVF:1; 
....................       }; 
....................    }; 
.................... } STKPTRBITS; 
.................... STKPTRBITS STKPTRbits; 
.................... #byte STKPTRbits = 0xFFC 
.................... #byte STKPTR = 0xFFC 
....................  
.................... #byte PCLATU = 0xFFB 
....................  
.................... #byte PCLATH = 0xFFA 
....................  
.................... #byte PCL = 0xFF9 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int TBLPTRU0:5; 
....................          unsigned int ACSS:1; 
....................       }; 
....................       struct { 
....................          unsigned int TBLPTRU:5; 
....................       }; 
.................... } TBLPTRUBITS; 
.................... TBLPTRUBITS TBLPTRUbits; 
.................... #byte TBLPTRUbits = 0xFF8 
.................... #byte TBLPTRU = 0xFF8 
....................  
.................... #word TBLPTR = 0xFF6 
.................... #byte TBLPTRH = 0xFF7 
.................... #byte TBLPTRL = 0xFF6 
....................  
.................... #byte TABLAT = 0xFF5 
....................  
.................... #word PROD = 0xFF3 
.................... #byte PRODH = 0xFF4 
.................... #byte PRODL = 0xFF3 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int INT0F:1; 
....................          unsigned int T0IF:1; 
....................          unsigned int :1; 
....................          unsigned int INT0E:1; 
....................          unsigned int T0IE:1; 
....................          unsigned int GIEL:1; 
....................          unsigned int GIEH:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :6; 
....................          unsigned int PEIE:1; 
....................          unsigned int GIE:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int RBIF:1; 
....................          unsigned int INT0IF:1; 
....................          unsigned int TMR0IF:1; 
....................          unsigned int RBIE:1; 
....................          unsigned int INT0IE:1; 
....................          unsigned int TMR0IE:1; 
....................          unsigned int PEIE_GIEL:1; 
....................          unsigned int GIE_GIEH:1; 
....................       }; 
....................    }; 
.................... } INTCONBITS; 
.................... INTCONBITS INTCONbits; 
.................... #byte INTCONbits = 0xFF2 
.................... #byte INTCON = 0xFF2 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int RBIP:1; 
....................          unsigned int :1; 
....................          unsigned int TMR0IP:1; 
....................          unsigned int :1; 
....................          unsigned int INTEDG2:1; 
....................          unsigned int INTEDG1:1; 
....................          unsigned int INTEDG0:1; 
....................          unsigned int RBPU:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int INTEDG:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int T0IP:1; 
....................       }; 
....................    }; 
.................... } INTCON2BITS; 
.................... INTCON2BITS INTCON2bits; 
.................... #byte INTCON2bits = 0xFF1 
.................... #byte INTCON2 = 0xFF1 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int INT1F:1; 
....................          unsigned int INT2F:1; 
....................          unsigned int :1; 
....................          unsigned int INT1E:1; 
....................          unsigned int INT2E:1; 
....................          unsigned int :1; 
....................          unsigned int INT1P:1; 
....................          unsigned int INT2P:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int INT1IF:1; 
....................          unsigned int INT2IF:1; 
....................          unsigned int :1; 
....................          unsigned int INT1IE:1; 
....................          unsigned int INT2IE:1; 
....................          unsigned int :1; 
....................          unsigned int INT1IP:1; 
....................          unsigned int INT2IP:1; 
....................       }; 
....................    }; 
.................... } INTCON3BITS; 
.................... INTCON3BITS INTCON3bits; 
.................... #byte INTCON3bits = 0xFF0 
.................... #byte INTCON3 = 0xFF0 
....................  
.................... #byte INDF0 = 0xFEF 
....................  
.................... #byte POSTINC0 = 0xFEE 
....................  
.................... #byte POSTDEC0 = 0xFED 
....................  
.................... #byte PREINC0 = 0xFEC 
....................  
.................... #byte PLUSW0 = 0xFEB 
....................  
.................... #word FSR0 = 0xFE9 
.................... #byte FSR0H = 0xFEA 
.................... #byte FSR0L = 0xFE9 
....................  
.................... #byte WREG = 0xFE8 
....................  
.................... #byte INDF1 = 0xFE7 
....................  
.................... #byte POSTINC1 = 0xFE6 
....................  
.................... #byte POSTDEC1 = 0xFE5 
....................  
.................... #byte PREINC1 = 0xFE4 
....................  
.................... #byte PLUSW1 = 0xFE3 
....................  
.................... #word FSR1 = 0xFE1 
.................... #byte FSR1H = 0xFE2 
.................... #byte FSR1L = 0xFE1 
....................  
.................... #byte BSR = 0xFE0 
....................  
.................... #byte INDF2 = 0xFDF 
....................  
.................... #byte POSTINC2 = 0xFDE 
....................  
.................... #byte POSTDEC2 = 0xFDD 
....................  
.................... #byte PREINC2 = 0xFDC 
....................  
.................... #byte PLUSW2 = 0xFDB 
....................  
.................... #word FSR2 = 0xFD9 
.................... #byte FSR2H = 0xFDA 
.................... #byte FSR2L = 0xFD9 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int C:1; 
....................    unsigned int DC:1; 
....................    unsigned int Z:1; 
....................    unsigned int OV:1; 
....................    unsigned int N:1; 
.................... } STATUSBITS; 
.................... STATUSBITS STATUSbits; 
.................... #byte STATUSbits = 0xFD8 
.................... #byte STATUS = 0xFD8 
....................  
.................... #word TMR0 = 0xFD6 
.................... #byte TMR0H = 0xFD7 
.................... #byte TMR0L = 0xFD6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int T0PS0:3; 
....................          unsigned int PSA:1; 
....................          unsigned int T0SE:1; 
....................          unsigned int T0CS:1; 
....................          unsigned int T08BIT:1; 
....................          unsigned int TMR0ON:1; 
....................       }; 
....................       struct { 
....................          unsigned int T0PS:3; 
....................       }; 
.................... } T0CONBITS; 
.................... T0CONBITS T0CONbits; 
.................... #byte T0CONbits = 0xFD5 
.................... #byte T0CON = 0xFD5 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SCS0:2; 
....................          unsigned int IOFS:1; 
....................          unsigned int OSTS:1; 
....................          unsigned int IRCF0:3; 
....................          unsigned int IDLEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int SCS:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int IRCF:3; 
....................       }; 
.................... } OSCCONBITS; 
.................... OSCCONBITS OSCCONbits; 
.................... #byte OSCCONbits = 0xFD3 
.................... #byte OSCCON = 0xFD3 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int LVDL0:4; 
....................          unsigned int LVDEN:1; 
....................          unsigned int IVRST:1; 
....................       }; 
....................       struct { 
....................          unsigned int LVDL:4; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int LVV0:4; 
....................          unsigned int :1; 
....................          unsigned int BGST:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int LVV:4; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int HLVDL0:4; 
....................          unsigned int HLVDEN:1; 
....................          unsigned int IRVST:1; 
....................          unsigned int :1; 
....................          unsigned int VDIRMAG:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int HLVDL:4; 
....................       }; 
.................... } HLVDCONBITS; 
.................... HLVDCONBITS HLVDCONbits; 
.................... #byte HLVDCONbits = 0xFD2 
.................... #byte HLVDCON = 0xFD2 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int SWDTEN:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int SWDTE:1; 
....................       }; 
....................    }; 
.................... } WDTCONBITS; 
.................... WDTCONBITS WDTCONbits; 
.................... #byte WDTCONbits = 0xFD1 
.................... #byte WDTCON = 0xFD1 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int BOR:1; 
....................    unsigned int POR:1; 
....................    unsigned int PD:1; 
....................    unsigned int TO:1; 
....................    unsigned int RI:1; 
....................    unsigned int :1; 
....................    unsigned int SBOREN:1; 
....................    unsigned int IPEN:1; 
.................... } RCONBITS; 
.................... RCONBITS RCONbits; 
.................... #byte RCONbits = 0xFD0 
.................... #byte RCON = 0xFD0 
....................  
.................... #word TMR1 = 0xFCE 
.................... #byte TMR1H = 0xFCF 
.................... #byte TMR1L = 0xFCE 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int T1INSYNC:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int TMR1ON:1; 
....................          unsigned int TMR1CS:1; 
....................          unsigned int T1SYNC:1; 
....................          unsigned int T1OSCEN:1; 
....................          unsigned int T1CKPS0:2; 
....................          unsigned int T1RUN:1; 
....................          unsigned int RD16:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int T1CKPS:2; 
....................       }; 
.................... } T1CONBITS; 
.................... T1CONBITS T1CONbits; 
.................... #byte T1CONbits = 0xFCD 
.................... #byte T1CON = 0xFCD 
....................  
.................... #byte TMR2 = 0xFCC 
....................  
.................... #byte PR2 = 0xFCB 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int TOUTPS0:4; 
....................       }; 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int TOUTPS:4; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int T2CKPS0:2; 
....................          unsigned int TMR2ON:1; 
....................          unsigned int T2OUTPS0:4; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int T2CKPS:2; 
....................          unsigned int :1; 
....................          unsigned int T2OUTPS:4; 
....................       }; 
.................... } T2CONBITS; 
.................... T2CONBITS T2CONbits; 
.................... #byte T2CONbits = 0xFCA 
.................... #byte T2CON = 0xFCA 
....................  
.................... #byte SSPBUF = 0xFC9 
....................  
.................... #byte SSPADD = 0xFC8 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int R_W:1; 
....................          unsigned int :2; 
....................          unsigned int D_A:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int I2C_READ:1; 
....................          unsigned int I2C_START:1; 
....................          unsigned int I2C_STOP:1; 
....................          unsigned int I2C_DAT:1; 
....................       }; 
....................    }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int WRITE:1; 
....................          unsigned int :2; 
....................          unsigned int ADDRESS:1; 
....................       }; 
....................    }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int READ_WRITE:1; 
....................          unsigned int :2; 
....................          unsigned int DATA_ADDRESS:1; 
....................       }; 
....................    }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int W:1; 
....................          unsigned int :2; 
....................          unsigned int A:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int BF:1; 
....................          unsigned int UA:1; 
....................          unsigned int R:1; 
....................          unsigned int S:1; 
....................          unsigned int P:1; 
....................          unsigned int D:1; 
....................          unsigned int CKE:1; 
....................          unsigned int SMP:1; 
....................       }; 
....................    }; 
.................... } SSPSTATBITS; 
.................... SSPSTATBITS SSPSTATbits; 
.................... #byte SSPSTATbits = 0xFC7 
.................... #byte SSPSTAT = 0xFC7 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SSPM0:4; 
....................          unsigned int CKP:1; 
....................          unsigned int SSPEN:1; 
....................          unsigned int SSPOV:1; 
....................          unsigned int WCOL:1; 
....................       }; 
....................       struct { 
....................          unsigned int SSPM:4; 
....................       }; 
.................... } SSPCON1BITS; 
.................... SSPCON1BITS SSPCON1bits; 
.................... #byte SSPCON1bits = 0xFC6 
.................... #byte SSPCON1 = 0xFC6 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SEN:1; 
....................    unsigned int RSEN:1; 
....................    unsigned int PEN:1; 
....................    unsigned int RCEN:1; 
....................    unsigned int ACKEN:1; 
....................    unsigned int ACKDT:1; 
....................    unsigned int ACKSTAT:1; 
....................    unsigned int GCEN:1; 
.................... } SSPCON2BITS; 
.................... SSPCON2BITS SSPCON2bits; 
.................... #byte SSPCON2bits = 0xFC5 
.................... #byte SSPCON2 = 0xFC5 
....................  
.................... #word ADRES = 0xFC3 
.................... #byte ADRESH = 0xFC4 
.................... #byte ADRESL = 0xFC3 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int GO_DONE:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int DONE:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int ADON:1; 
....................          unsigned int GO:1; 
....................          unsigned int CHS0:4; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int CHS:4; 
....................       }; 
.................... } ADCON0BITS; 
.................... ADCON0BITS ADCON0bits; 
.................... #byte ADCON0bits = 0xFC2 
.................... #byte ADCON0 = 0xFC2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PCFG0:4; 
....................          unsigned int VCFG0:2; 
....................       }; 
....................       struct { 
....................          unsigned int PCFG:4; 
....................          unsigned int VCFG:2; 
....................       }; 
.................... } ADCON1BITS; 
.................... ADCON1BITS ADCON1bits; 
.................... #byte ADCON1bits = 0xFC1 
.................... #byte ADCON1 = 0xFC1 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ADCS0:3; 
....................          unsigned int ACQT0:3; 
....................          unsigned int :1; 
....................          unsigned int ADFM:1; 
....................       }; 
....................       struct { 
....................          unsigned int ADCS:3; 
....................          unsigned int ACQT:3; 
....................       }; 
.................... } ADCON2BITS; 
.................... ADCON2BITS ADCON2bits; 
.................... #byte ADCON2bits = 0xFC0 
.................... #byte ADCON2 = 0xFC0 
....................  
.................... #word CCPR1 = 0xFBE 
.................... #byte CCPR1H = 0xFBF 
.................... #byte CCPR1L = 0xFBE 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CCP1M0:4; 
....................          unsigned int DC1B0:2; 
....................       }; 
....................       struct { 
....................          unsigned int CCP1M:4; 
....................          unsigned int DC1B:2; 
....................       }; 
.................... } CCP1CONBITS; 
.................... CCP1CONBITS CCP1CONbits; 
.................... #byte CCP1CONbits = 0xFBD 
.................... #byte CCP1CON = 0xFBD 
....................  
.................... #word ECCPR1 = 0xFBB 
.................... #byte ECCPR1H = 0xFBC 
.................... #byte ECCPR1L = 0xFBB 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int ECCP1M0:4; 
....................          unsigned int EDC1B0:2; 
....................          unsigned int EPWM1M0:2; 
....................       }; 
....................       struct { 
....................          unsigned int ECCP1M:4; 
....................          unsigned int EDC1B:2; 
....................          unsigned int EPWM1M:2; 
....................       }; 
.................... } ECCP1CONBITS; 
.................... ECCP1CONBITS ECCP1CONbits; 
.................... #byte ECCP1CONbits = 0xFBA 
.................... #byte ECCP1CON = 0xFBA 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int ABDEN:1; 
....................          unsigned int WUE:1; 
....................          unsigned int :1; 
....................          unsigned int BRG16:1; 
....................          unsigned int TXCKP:1; 
....................          unsigned int RXDTP:1; 
....................          unsigned int RCIDL:1; 
....................          unsigned int ABDOVF:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int SCKP:1; 
....................       }; 
....................    }; 
.................... } BAUDCONBITS; 
.................... BAUDCONBITS BAUDCONbits; 
.................... #byte BAUDCONbits = 0xFB8 
.................... #byte BAUDCON = 0xFB8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PDC0:7; 
....................          unsigned int PRSEN:1; 
....................       }; 
....................       struct { 
....................          unsigned int PDC:7; 
....................       }; 
.................... } ECCP1DELBITS; 
.................... ECCP1DELBITS ECCP1DELbits; 
.................... #byte ECCP1DELbits = 0xFB7 
.................... #byte ECCP1DEL = 0xFB7 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int PSSBD0:2; 
....................          unsigned int PSSAC0:2; 
....................          unsigned int ECCPAS0:3; 
....................          unsigned int ECCPASE:1; 
....................       }; 
....................       struct { 
....................          unsigned int PSSBD:2; 
....................          unsigned int PSSAC:2; 
....................          unsigned int ECCPAS:3; 
....................       }; 
.................... } ECCP1ASBITS; 
.................... ECCP1ASBITS ECCP1ASbits; 
.................... #byte ECCP1ASbits = 0xFB6 
.................... #byte ECCP1AS = 0xFB6 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int CVR0:4; 
....................          unsigned int CVRSS:1; 
....................          unsigned int CVRR:1; 
....................          unsigned int CVROE:1; 
....................          unsigned int CVREN:1; 
....................       }; 
....................       struct { 
....................          unsigned int CVR:4; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int CVREF:1; 
....................       }; 
....................    }; 
.................... } CVRCONBITS; 
.................... CVRCONBITS CVRCONbits; 
.................... #byte CVRCONbits = 0xFB5 
.................... #byte CVRCON = 0xFB5 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int CM0:3; 
....................          unsigned int CIS:1; 
....................          unsigned int C1INV:1; 
....................          unsigned int C2INV:1; 
....................          unsigned int C1OUT:1; 
....................          unsigned int C2OUT:1; 
....................       }; 
....................       struct { 
....................          unsigned int CM:3; 
....................       }; 
.................... } CMCONBITS; 
.................... CMCONBITS CMCONbits; 
.................... #byte CMCONbits = 0xFB4 
.................... #byte CMCON = 0xFB4 
....................  
.................... #word TMR3 = 0xFB2 
.................... #byte TMR3H = 0xFB3 
.................... #byte TMR3L = 0xFB2 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int TMR3ON:1; 
....................          unsigned int TMR3CS:1; 
....................          unsigned int T3SYNC:1; 
....................          unsigned int T3CCP1:1; 
....................          unsigned int T3CKPS0:2; 
....................          unsigned int T3ECCP1:1; 
....................          unsigned int RD16:1; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int T3CKPS:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int T3NSYNC:1; 
....................          unsigned int :3; 
....................          unsigned int T3CCP2:1; 
....................       }; 
....................    }; 
.................... } T3CONBITS; 
.................... T3CONBITS T3CONbits; 
.................... #byte T3CONbits = 0xFB1 
.................... #byte T3CON = 0xFB1 
....................  
.................... #byte SPBRGH = 0xFB0 
....................  
.................... #byte SPBRG = 0xFAF 
....................  
.................... #byte RCREG = 0xFAE 
....................  
.................... #byte TXREG = 0xFAD 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TX9D:1; 
....................    unsigned int TRMT:1; 
....................    unsigned int BRGH:1; 
....................    unsigned int SENDB:1; 
....................    unsigned int SYNC:1; 
....................    unsigned int TXEN:1; 
....................    unsigned int TX9:1; 
....................    unsigned int CSRC:1; 
.................... } TXSTABITS; 
.................... TXSTABITS TXSTAbits; 
.................... #byte TXSTAbits = 0xFAC 
.................... #byte TXSTA = 0xFAC 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int RX9D:1; 
....................          unsigned int OERR:1; 
....................          unsigned int FERR:1; 
....................          unsigned int ADDEN:1; 
....................          unsigned int CREN:1; 
....................          unsigned int SREN:1; 
....................          unsigned int RX9:1; 
....................          unsigned int SPEN:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int ADEN:1; 
....................       }; 
....................    }; 
.................... } RCSTABITS; 
.................... RCSTABITS RCSTAbits; 
.................... #byte RCSTAbits = 0xFAB 
.................... #byte RCSTA = 0xFAB 
....................  
.................... #byte EEADRH = 0xFAA 
....................  
.................... #byte EEADR = 0xFA9 
....................  
.................... #byte EEDATA = 0xFA8 
....................  
.................... #byte EECON2 = 0xFA7 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RD:1; 
....................    unsigned int WR:1; 
....................    unsigned int WREN:1; 
....................    unsigned int WRERR:1; 
....................    unsigned int FREE:1; 
....................    unsigned int :1; 
....................    unsigned int CFGS:1; 
....................    unsigned int EEPGD:1; 
.................... } EECON1BITS; 
.................... EECON1BITS EECON1bits; 
.................... #byte EECON1bits = 0xFA6 
.................... #byte EECON1 = 0xFA6 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int FIFOWMIP:1; 
....................          unsigned int RXBnIP:1; 
....................          unsigned int :2; 
....................          unsigned int TXBnIP:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int RXB0IP:1; 
....................          unsigned int RXB1IP:1; 
....................          unsigned int TXB0IP:1; 
....................          unsigned int TXB1IP:1; 
....................          unsigned int TXB2IP:1; 
....................          unsigned int ERRIP:1; 
....................          unsigned int WAKIP:1; 
....................          unsigned int IRXIP:1; 
....................       }; 
....................    }; 
.................... } IPR3BITS; 
.................... IPR3BITS IPR3bits; 
.................... #byte IPR3bits = 0xFA5 
.................... #byte IPR3 = 0xFA5 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int RXB0IF:1; 
....................          unsigned int RXB1IF:1; 
....................          unsigned int TXB0IF:1; 
....................          unsigned int TXB1IF:1; 
....................          unsigned int TXB2IF:1; 
....................          unsigned int ERRIF:1; 
....................          unsigned int WAKIF:1; 
....................          unsigned int IRXIF:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int FIFOWMIF:1; 
....................          unsigned int RXBnIF:1; 
....................          unsigned int :2; 
....................          unsigned int TXBnIF:1; 
....................       }; 
....................    }; 
.................... } PIR3BITS; 
.................... PIR3BITS PIR3bits; 
.................... #byte PIR3bits = 0xFA4 
.................... #byte PIR3 = 0xFA4 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int RXB0IE:1; 
....................          unsigned int RXB1IE:1; 
....................          unsigned int TXB0IE:1; 
....................          unsigned int TXB1IE:1; 
....................          unsigned int TXB2IE:1; 
....................          unsigned int ERRIE:1; 
....................          unsigned int WAKIE:1; 
....................          unsigned int IRXIE:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int FIFOWMIE:1; 
....................          unsigned int RXBnIE:1; 
....................          unsigned int :2; 
....................          unsigned int TXBnIE:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int FIFOMWIE:1; 
....................       }; 
....................    }; 
.................... } PIE3BITS; 
.................... PIE3BITS PIE3bits; 
.................... #byte PIE3bits = 0xFA3 
.................... #byte PIE3 = 0xFA3 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int LVDIP:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int ECCP1IP:1; 
....................          unsigned int TMR3IP:1; 
....................          unsigned int HLVDIP:1; 
....................          unsigned int BCLIP:1; 
....................          unsigned int EEIP:1; 
....................          unsigned int :1; 
....................          unsigned int CMIP:1; 
....................          unsigned int OSCFIP:1; 
....................       }; 
....................    }; 
.................... } IPR2BITS; 
.................... IPR2BITS IPR2bits; 
.................... #byte IPR2bits = 0xFA2 
.................... #byte IPR2 = 0xFA2 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int ECCP1IF:1; 
....................          unsigned int TMR3IF:1; 
....................          unsigned int HLVDIF:1; 
....................          unsigned int BCLIF:1; 
....................          unsigned int EEIF:1; 
....................          unsigned int :1; 
....................          unsigned int CMIF:1; 
....................          unsigned int OSCFIF:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int LVDIF:1; 
....................       }; 
....................    }; 
.................... } PIR2BITS; 
.................... PIR2BITS PIR2bits; 
.................... #byte PIR2bits = 0xFA1 
.................... #byte PIR2 = 0xFA1 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int ECCP1IE:1; 
....................          unsigned int TMR3IE:1; 
....................          unsigned int HLVDIE:1; 
....................          unsigned int BCLIE:1; 
....................          unsigned int EEIE:1; 
....................          unsigned int :1; 
....................          unsigned int CMIE:1; 
....................          unsigned int OSCFIE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int LVDIE:1; 
....................       }; 
....................    }; 
.................... } PIE2BITS; 
.................... PIE2BITS PIE2bits; 
.................... #byte PIE2bits = 0xFA0 
.................... #byte PIE2 = 0xFA0 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int TXBIP:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int TMR1IP:1; 
....................          unsigned int TMR2IP:1; 
....................          unsigned int CCP1IP:1; 
....................          unsigned int SSPIP:1; 
....................          unsigned int TXIP:1; 
....................          unsigned int RCIP:1; 
....................          unsigned int ADIP:1; 
....................          unsigned int PSPIP:1; 
....................       }; 
....................    }; 
.................... } IPR1BITS; 
.................... IPR1BITS IPR1bits; 
.................... #byte IPR1bits = 0xF9F 
.................... #byte IPR1 = 0xF9F 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TMR1IF:1; 
....................    unsigned int TMR2IF:1; 
....................    unsigned int CCP1IF:1; 
....................    unsigned int SSPIF:1; 
....................    unsigned int TXIF:1; 
....................    unsigned int RCIF:1; 
....................    unsigned int ADIF:1; 
....................    unsigned int PSPIF:1; 
.................... } PIR1BITS; 
.................... PIR1BITS PIR1bits; 
.................... #byte PIR1bits = 0xF9E 
.................... #byte PIR1 = 0xF9E 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TMR1IE:1; 
....................    unsigned int TMR2IE:1; 
....................    unsigned int CCP1IE:1; 
....................    unsigned int SSPIE:1; 
....................    unsigned int TXIE:1; 
....................    unsigned int RCIE:1; 
....................    unsigned int ADIE:1; 
....................    unsigned int PSPIE:1; 
.................... } PIE1BITS; 
.................... PIE1BITS PIE1bits; 
.................... #byte PIE1bits = 0xF9D 
.................... #byte PIE1 = 0xF9D 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int TUN0:5; 
....................          unsigned int :1; 
....................          unsigned int PLLEN:1; 
....................          unsigned int INTSRC:1; 
....................       }; 
....................       struct { 
....................          unsigned int TUN:5; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :7; 
....................          unsigned int INTSCR:1; 
....................       }; 
....................    }; 
.................... } OSCTUNEBITS; 
.................... OSCTUNEBITS OSCTUNEbits; 
.................... #byte OSCTUNEbits = 0xF9B 
.................... #byte OSCTUNE = 0xF9B 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISE0:1; 
....................    unsigned int TRISE1:1; 
....................    unsigned int TRISE2:1; 
....................    unsigned int TRISE3:1; 
....................    unsigned int TRISE4:1; 
....................    unsigned int TRISE5:1; 
....................    unsigned int TRISE6:1; 
....................    unsigned int TRISE7:1; 
.................... } TRISEBITS; 
.................... TRISEBITS TRISEbits; 
.................... #byte TRISEbits = 0xF96 
.................... #byte TRISE = 0xF96 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISD0:1; 
....................    unsigned int TRISD1:1; 
....................    unsigned int TRISD2:1; 
....................    unsigned int TRISD3:1; 
....................    unsigned int TRISD4:1; 
....................    unsigned int TRISD5:1; 
....................    unsigned int TRISD6:1; 
....................    unsigned int TRISD7:1; 
.................... } TRISDBITS; 
.................... TRISDBITS TRISDbits; 
.................... #byte TRISDbits = 0xF95 
.................... #byte TRISD = 0xF95 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISC0:1; 
....................    unsigned int TRISC1:1; 
....................    unsigned int TRISC2:1; 
....................    unsigned int TRISC3:1; 
....................    unsigned int TRISC4:1; 
....................    unsigned int TRISC5:1; 
....................    unsigned int TRISC6:1; 
....................    unsigned int TRISC7:1; 
.................... } TRISCBITS; 
.................... TRISCBITS TRISCbits; 
.................... #byte TRISCbits = 0xF94 
.................... #byte TRISC = 0xF94 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISB0:1; 
....................    unsigned int TRISB1:1; 
....................    unsigned int TRISB2:1; 
....................    unsigned int TRISB3:1; 
....................    unsigned int TRISB4:1; 
....................    unsigned int TRISB5:1; 
....................    unsigned int TRISB6:1; 
....................    unsigned int TRISB7:1; 
.................... } TRISBBITS; 
.................... TRISBBITS TRISBbits; 
.................... #byte TRISBbits = 0xF93 
.................... #byte TRISB = 0xF93 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int TRISA0:1; 
....................    unsigned int TRISA1:1; 
....................    unsigned int TRISA2:1; 
....................    unsigned int TRISA3:1; 
....................    unsigned int TRISA4:1; 
....................    unsigned int TRISA5:1; 
....................    unsigned int TRISA6:1; 
....................    unsigned int TRISA7:1; 
.................... } TRISABITS; 
.................... TRISABITS TRISAbits; 
.................... #byte TRISAbits = 0xF92 
.................... #byte TRISA = 0xF92 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATE0:1; 
....................    unsigned int LATE1:1; 
....................    unsigned int LATE2:1; 
....................    unsigned int LATE3:1; 
....................    unsigned int LATE4:1; 
....................    unsigned int LATE5:1; 
....................    unsigned int LATE6:1; 
....................    unsigned int LATE7:1; 
.................... } LATEBITS; 
.................... LATEBITS LATEbits; 
.................... #byte LATEbits = 0xF8D 
.................... #byte LATE = 0xF8D 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATD0:1; 
....................    unsigned int LATD1:1; 
....................    unsigned int LATD2:1; 
....................    unsigned int LATD3:1; 
....................    unsigned int LATD4:1; 
....................    unsigned int LATD5:1; 
....................    unsigned int LATD6:1; 
....................    unsigned int LATD7:1; 
.................... } LATDBITS; 
.................... LATDBITS LATDbits; 
.................... #byte LATDbits = 0xF8C 
.................... #byte LATD = 0xF8C 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATC0:1; 
....................    unsigned int LATC1:1; 
....................    unsigned int LATC2:1; 
....................    unsigned int LATC3:1; 
....................    unsigned int LATC4:1; 
....................    unsigned int LATC5:1; 
....................    unsigned int LATC6:1; 
....................    unsigned int LATC7:1; 
.................... } LATCBITS; 
.................... LATCBITS LATCbits; 
.................... #byte LATCbits = 0xF8B 
.................... #byte LATC = 0xF8B 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATB0:1; 
....................    unsigned int LATB1:1; 
....................    unsigned int LATB2:1; 
....................    unsigned int LATB3:1; 
....................    unsigned int LATB4:1; 
....................    unsigned int LATB5:1; 
....................    unsigned int LATB6:1; 
....................    unsigned int LATB7:1; 
.................... } LATBBITS; 
.................... LATBBITS LATBbits; 
.................... #byte LATBbits = 0xF8A 
.................... #byte LATB = 0xF8A 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int LATA0:1; 
....................    unsigned int LATA1:1; 
....................    unsigned int LATA2:1; 
....................    unsigned int LATA3:1; 
....................    unsigned int LATA4:1; 
....................    unsigned int LATA5:1; 
....................    unsigned int LATA6:1; 
....................    unsigned int LATA7:1; 
.................... } LATABITS; 
.................... LATABITS LATAbits; 
.................... #byte LATAbits = 0xF89 
.................... #byte LATA = 0xF89 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RE0:1; 
....................    unsigned int RE1:1; 
....................    unsigned int RE2:1; 
....................    unsigned int RE3:1; 
....................    unsigned int RE4:1; 
....................    unsigned int RE5:1; 
....................    unsigned int RE6:1; 
....................    unsigned int RE7:1; 
.................... } PORTEBITS; 
.................... PORTEBITS PORTEbits; 
.................... #byte PORTEbits = 0xF84 
.................... #byte PORTE = 0xF84 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RD0:1; 
....................    unsigned int RD1:1; 
....................    unsigned int RD2:1; 
....................    unsigned int RD3:1; 
....................    unsigned int RD4:1; 
....................    unsigned int RD5:1; 
....................    unsigned int RD6:1; 
....................    unsigned int RD7:1; 
.................... } PORTDBITS; 
.................... PORTDBITS PORTDbits; 
.................... #byte PORTDbits = 0xF83 
.................... #byte PORTD = 0xF83 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RC0:1; 
....................    unsigned int RC1:1; 
....................    unsigned int RC2:1; 
....................    unsigned int RC3:1; 
....................    unsigned int RC4:1; 
....................    unsigned int RC5:1; 
....................    unsigned int RC6:1; 
....................    unsigned int RC7:1; 
.................... } PORTCBITS; 
.................... PORTCBITS PORTCbits; 
.................... #byte PORTCbits = 0xF82 
.................... #byte PORTC = 0xF82 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RB0:1; 
....................    unsigned int RB1:1; 
....................    unsigned int RB2:1; 
....................    unsigned int RB3:1; 
....................    unsigned int RB4:1; 
....................    unsigned int RB5:1; 
....................    unsigned int RB6:1; 
....................    unsigned int RB7:1; 
.................... } PORTBBITS; 
.................... PORTBBITS PORTBbits; 
.................... #byte PORTBbits = 0xF81 
.................... #byte PORTB = 0xF81 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RA0:1; 
....................    unsigned int RA1:1; 
....................    unsigned int RA2:1; 
....................    unsigned int RA3:1; 
....................    unsigned int RA4:1; 
....................    unsigned int RA5:1; 
....................    unsigned int RA6:1; 
....................    unsigned int RA7:1; 
.................... } PORTABITS; 
.................... PORTABITS PORTAbits; 
.................... #byte PORTAbits = 0xF80 
.................... #byte PORTA = 0xF80 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int F:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int EWIN0:5; 
....................          unsigned int FIFOWM:1; 
....................          unsigned int MDSEL0:2; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int EWIN:5; 
....................          unsigned int :1; 
....................          unsigned int MDSEL:2; 
....................       }; 
.................... } ECANCONBITS; 
.................... ECANCONBITS ECANCONbits; 
.................... #byte ECANCONbits = 0xF77 
.................... #byte ECANCON = 0xF77 
....................  
.................... #byte TXERRCNT = 0xF76 
....................  
.................... #byte RXERRCNT = 0xF75 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :6; 
....................          unsigned int RXB1OVFL:1; 
....................          unsigned int FIFOEMPTY:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int EWARN:1; 
....................          unsigned int RXWARN:1; 
....................          unsigned int TXWARN:1; 
....................          unsigned int RXBP:1; 
....................          unsigned int TXBP:1; 
....................          unsigned int TXBO:1; 
....................          unsigned int RXBnOVFL:1; 
....................          unsigned int RXB0OVFL:1; 
....................       }; 
....................    }; 
.................... } COMSTATBITS; 
.................... COMSTATBITS COMSTATbits; 
.................... #byte COMSTATbits = 0xF74 
.................... #byte COMSTAT = 0xF74 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :4; 
....................    unsigned int CANCAP:1; 
....................    unsigned int ENDRHI:1; 
.................... } CIOCONBITS; 
.................... CIOCONBITS CIOCONbits; 
.................... #byte CIOCONbits = 0xF73 
.................... #byte CIOCON = 0xF73 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int SEG2PH0:3; 
....................          unsigned int :3; 
....................          unsigned int WAKFIL:1; 
....................          unsigned int WAKDIS:1; 
....................       }; 
....................       struct { 
....................          unsigned int SEG2PH:3; 
....................          unsigned int :3; 
....................       }; 
.................... } BRGCON3BITS; 
.................... BRGCON3BITS BRGCON3bits; 
.................... #byte BRGCON3bits = 0xF72 
.................... #byte BRGCON3 = 0xF72 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int PRSEG0:3; 
....................          unsigned int SEG1PH0:3; 
....................          unsigned int SAM:1; 
....................          unsigned int SEG2PHT:1; 
....................       }; 
....................       struct { 
....................          unsigned int PRSEG:3; 
....................          unsigned int SEG1PH:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :7; 
....................          unsigned int SEG2PHTS:1; 
....................       }; 
....................    }; 
.................... } BRGCON2BITS; 
.................... BRGCON2BITS BRGCON2bits; 
.................... #byte BRGCON2bits = 0xF71 
.................... #byte BRGCON2 = 0xF71 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int BRP0:6; 
....................          unsigned int SJW0:2; 
....................       }; 
....................       struct { 
....................          unsigned int BRP:6; 
....................          unsigned int SJW:2; 
....................       }; 
.................... } BRGCON1BITS; 
.................... BRGCON1BITS BRGCON1bits; 
.................... #byte BRGCON1bits = 0xF70 
.................... #byte BRGCON1 = 0xF70 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int FP1:3; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int FP0:1; 
....................          unsigned int WIN0_FP1:1; 
....................          unsigned int WIN1_FP2:1; 
....................          unsigned int WIN2_FP3:1; 
....................          unsigned int ABAT:1; 
....................          unsigned int REQOP0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int REQOP:3; 
....................       }; 
.................... } CANCONBITS; 
.................... CANCONBITS CANCONbits; 
.................... #byte CANCONbits = 0xF6F 
.................... #byte CANCON = 0xF6F 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EICODE0:1; 
....................          unsigned int EICODE1_ICODE0:1; 
....................          unsigned int EICODE2_ICODE1:1; 
....................          unsigned int EICODE3_ICODE2:1; 
....................          unsigned int EICODE4:1; 
....................          unsigned int OPMODE0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int OPMODE:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int EICODE1:3; 
....................       }; 
....................    }; 
.................... } CANSTATBITS; 
.................... CANSTATBITS CANSTATbits; 
.................... #byte CANSTATbits = 0xF6E 
.................... #byte CANSTAT = 0xF6E 
....................  
.................... #byte RXB0D7 = 0xF6D 
....................  
.................... #byte RXB0D6 = 0xF6C 
....................  
.................... #byte RXB0D5 = 0xF6B 
....................  
.................... #byte RXB0D4 = 0xF6A 
....................  
.................... #byte RXB0D3 = 0xF69 
....................  
.................... #byte RXB0D2 = 0xF68 
....................  
.................... #byte RXB0D1 = 0xF67 
....................  
.................... #byte RXB0D0 = 0xF66 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int DLC0:4; 
....................          unsigned int RB0:2; 
....................          unsigned int RXRTR:1; 
....................       }; 
....................       struct { 
....................          unsigned int DLC:4; 
....................          unsigned int RB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB0:2; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB:2; 
....................       }; 
.................... } RXB0DLCBITS; 
.................... RXB0DLCBITS RXB0DLCbits; 
.................... #byte RXB0DLCbits = 0xF65 
.................... #byte RXB0DLC = 0xF65 
....................  
.................... #byte RXB0EIDL = 0xF64 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXB0EIDHBITS; 
.................... RXB0EIDHBITS RXB0EIDHbits; 
.................... #byte RXB0EIDHbits = 0xF63 
.................... #byte RXB0EIDH = 0xF63 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXID:1; 
....................          unsigned int SRR:1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } RXB0SIDLBITS; 
.................... RXB0SIDLBITS RXB0SIDLbits; 
.................... #byte RXB0SIDLbits = 0xF62 
.................... #byte RXB0SIDL = 0xF62 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXB0SIDHBITS; 
.................... RXB0SIDHBITS RXB0SIDHbits; 
.................... #byte RXB0SIDHbits = 0xF61 
.................... #byte RXB0SIDH = 0xF61 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int FILHIT1:3; 
....................          unsigned int :1; 
....................          unsigned int RTRRO:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int FILHIT0:1; 
....................          unsigned int JTOFF_FILHIT1:1; 
....................          unsigned int RXB0DBEN_FILHIT2:1; 
....................          unsigned int RXRTRRO_FILHIT3:1; 
....................          unsigned int FILHIT4:1; 
....................          unsigned int RXM0_RTRRO:1; 
....................          unsigned int RXM1:1; 
....................          unsigned int RXFUL:1; 
....................       }; 
....................    }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :2; 
....................          unsigned int RXBODBEN:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int JTOFF:1; 
....................          unsigned int RXB0DBEN:1; 
....................          unsigned int RXRTRRO:1; 
....................          unsigned int :1; 
....................          unsigned int RXM0:1; 
....................       }; 
....................    }; 
.................... } RXB0CONBITS; 
.................... RXB0CONBITS RXB0CONbits; 
.................... #byte RXB0CONbits = 0xF60 
.................... #byte RXB0CON = 0xF60 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int FP0:1; 
....................          unsigned int WIN0_FP1:1; 
....................          unsigned int WIN1_FP2:1; 
....................          unsigned int WIN2_FP3:1; 
....................          unsigned int ABAT:1; 
....................          unsigned int REQOP0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int REQOP:3; 
....................       }; 
.................... } CANCON_RO0BITS; 
.................... CANCON_RO0BITS CANCON_RO0bits; 
.................... #byte CANCON_RO0bits = 0xF5F 
.................... #byte CANCON_RO0 = 0xF5F 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EICODE0:1; 
....................          unsigned int EICODE1_ICODE0:1; 
....................          unsigned int EICODE2_ICODE1:1; 
....................          unsigned int EICODE3_ICODE2:1; 
....................          unsigned int EICODE4:1; 
....................          unsigned int OPMODE0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int OPMODE:3; 
....................       }; 
.................... } CANSTAT_RO0BITS; 
.................... CANSTAT_RO0BITS CANSTAT_RO0bits; 
.................... #byte CANSTAT_RO0bits = 0xF5E 
.................... #byte CANSTAT_RO0 = 0xF5E 
....................  
.................... #byte RXB1D7 = 0xF5D 
....................  
.................... #byte RXB1D6 = 0xF5C 
....................  
.................... #byte RXB1D5 = 0xF5B 
....................  
.................... #byte RXB1D4 = 0xF5A 
....................  
.................... #byte RXB1D3 = 0xF59 
....................  
.................... #byte RXB1D2 = 0xF58 
....................  
.................... #byte RXB1D1 = 0xF57 
....................  
.................... #byte RXB1D0 = 0xF56 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int DLC0:4; 
....................          unsigned int RB0:2; 
....................          unsigned int RXRTR:1; 
....................       }; 
....................       struct { 
....................          unsigned int DLC:4; 
....................          unsigned int RB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB0:2; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB:2; 
....................       }; 
.................... } RXB1DLCBITS; 
.................... RXB1DLCBITS RXB1DLCbits; 
.................... #byte RXB1DLCbits = 0xF55 
.................... #byte RXB1DLC = 0xF55 
....................  
.................... #byte RXB1EIDL = 0xF54 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXB1EIDHBITS; 
.................... RXB1EIDHBITS RXB1EIDHbits; 
.................... #byte RXB1EIDHbits = 0xF53 
.................... #byte RXB1EIDH = 0xF53 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXID:1; 
....................          unsigned int SRR:1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } RXB1SIDLBITS; 
.................... RXB1SIDLBITS RXB1SIDLbits; 
.................... #byte RXB1SIDLbits = 0xF52 
.................... #byte RXB1SIDL = 0xF52 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXB1SIDHBITS; 
.................... RXB1SIDHBITS RXB1SIDHbits; 
.................... #byte RXB1SIDHbits = 0xF51 
.................... #byte RXB1SIDH = 0xF51 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int FILHIT3:1; 
....................          unsigned int :1; 
....................          unsigned int RTRRO:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int FILHIT0:3; 
....................          unsigned int RXRTRRO_FILHIT3:1; 
....................          unsigned int FILHIT4:1; 
....................          unsigned int RXM0_RTRRO:1; 
....................          unsigned int RXM1:1; 
....................          unsigned int RXFUL:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int FILHIT:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int RXRTRRO:1; 
....................          unsigned int :1; 
....................          unsigned int RXM0:1; 
....................       }; 
....................    }; 
.................... } RXB1CONBITS; 
.................... RXB1CONBITS RXB1CONbits; 
.................... #byte RXB1CONbits = 0xF50 
.................... #byte RXB1CON = 0xF50 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int FP0:1; 
....................          unsigned int WIN0_FP1:1; 
....................          unsigned int WIN1_FP2:1; 
....................          unsigned int WIN2_FP3:1; 
....................          unsigned int ABAT:1; 
....................          unsigned int REQOP0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int REQOP:3; 
....................       }; 
.................... } CANCON_RO1BITS; 
.................... CANCON_RO1BITS CANCON_RO1bits; 
.................... #byte CANCON_RO1bits = 0xF4F 
.................... #byte CANCON_RO1 = 0xF4F 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EICODE0:1; 
....................          unsigned int EICODE1_ICODE0:1; 
....................          unsigned int EICODE2_ICODE1:1; 
....................          unsigned int EICODE3_ICODE2:1; 
....................          unsigned int EICODE4:1; 
....................          unsigned int OPMODE0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int OPMODE:3; 
....................       }; 
.................... } CANSTAT_RO1BITS; 
.................... CANSTAT_RO1BITS CANSTAT_RO1bits; 
.................... #byte CANSTAT_RO1bits = 0xF4E 
.................... #byte CANSTAT_RO1 = 0xF4E 
....................  
.................... #byte TXB0D7 = 0xF4D 
....................  
.................... #byte TXB0D6 = 0xF4C 
....................  
.................... #byte TXB0D5 = 0xF4B 
....................  
.................... #byte TXB0D4 = 0xF4A 
....................  
.................... #byte TXB0D3 = 0xF49 
....................  
.................... #byte TXB0D2 = 0xF48 
....................  
.................... #byte TXB0D1 = 0xF47 
....................  
.................... #byte TXB0D0 = 0xF46 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int DLC0:4; 
....................          unsigned int :2; 
....................          unsigned int TXRTR:1; 
....................       }; 
....................       struct { 
....................          unsigned int DLC:4; 
....................          unsigned int :2; 
....................       }; 
.................... } TXB0DLCBITS; 
.................... TXB0DLCBITS TXB0DLCbits; 
.................... #byte TXB0DLCbits = 0xF45 
.................... #byte TXB0DLC = 0xF45 
....................  
.................... #byte TXB0EIDL = 0xF44 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } TXB0EIDHBITS; 
.................... TXB0EIDHBITS TXB0EIDHbits; 
.................... #byte TXB0EIDHbits = 0xF43 
.................... #byte TXB0EIDH = 0xF43 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDE:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } TXB0SIDLBITS; 
.................... TXB0SIDLBITS TXB0SIDLbits; 
.................... #byte TXB0SIDLbits = 0xF42 
.................... #byte TXB0SIDL = 0xF42 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } TXB0SIDHBITS; 
.................... TXB0SIDHBITS TXB0SIDHbits; 
.................... #byte TXB0SIDHbits = 0xF41 
.................... #byte TXB0SIDH = 0xF41 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int TXPRI0:2; 
....................          unsigned int :1; 
....................          unsigned int TXREQ:1; 
....................          unsigned int TXERR:1; 
....................          unsigned int TXLARB:1; 
....................          unsigned int TXABT:1; 
....................          unsigned int TXBIF:1; 
....................       }; 
....................       struct { 
....................          unsigned int TXPRI:2; 
....................       }; 
.................... } TXB0CONBITS; 
.................... TXB0CONBITS TXB0CONbits; 
.................... #byte TXB0CONbits = 0xF40 
.................... #byte TXB0CON = 0xF40 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int FP0:1; 
....................          unsigned int WIN0_FP1:1; 
....................          unsigned int WIN1_FP2:1; 
....................          unsigned int WIN2_FP3:1; 
....................          unsigned int ABAT:1; 
....................          unsigned int REQOP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int REQOP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN:3; 
....................       }; 
.................... } CANCON_RO2BITS; 
.................... CANCON_RO2BITS CANCON_RO2bits; 
.................... #byte CANCON_RO2bits = 0xF3F 
.................... #byte CANCON_RO2 = 0xF3F 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EICODE0:1; 
....................          unsigned int EICODE1_ICODE0:1; 
....................          unsigned int EICODE2_ICODE1:1; 
....................          unsigned int EICODE3_ICODE2:1; 
....................          unsigned int EICODE4:1; 
....................          unsigned int OPMODE0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int OPMODE:3; 
....................       }; 
.................... } CANSTAT_RO2BITS; 
.................... CANSTAT_RO2BITS CANSTAT_RO2bits; 
.................... #byte CANSTAT_RO2bits = 0xF3E 
.................... #byte CANSTAT_RO2 = 0xF3E 
....................  
.................... #byte TXB1D7 = 0xF3D 
....................  
.................... #byte TXB1D6 = 0xF3C 
....................  
.................... #byte TXB1D5 = 0xF3B 
....................  
.................... #byte TXB1D4 = 0xF3A 
....................  
.................... #byte TXB1D3 = 0xF39 
....................  
.................... #byte TXB1D2 = 0xF38 
....................  
.................... #byte TXB1D1 = 0xF37 
....................  
.................... #byte TXB1D0 = 0xF36 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int DLC0:4; 
....................          unsigned int :2; 
....................          unsigned int TXRTR:1; 
....................       }; 
....................       struct { 
....................          unsigned int DLC:4; 
....................          unsigned int :2; 
....................       }; 
.................... } TXB1DLCBITS; 
.................... TXB1DLCBITS TXB1DLCbits; 
.................... #byte TXB1DLCbits = 0xF35 
.................... #byte TXB1DLC = 0xF35 
....................  
.................... #byte TXB1EIDL = 0xF34 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } TXB1EIDHBITS; 
.................... TXB1EIDHBITS TXB1EIDHbits; 
.................... #byte TXB1EIDHbits = 0xF33 
.................... #byte TXB1EIDH = 0xF33 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDE:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } TXB1SIDLBITS; 
.................... TXB1SIDLBITS TXB1SIDLbits; 
.................... #byte TXB1SIDLbits = 0xF32 
.................... #byte TXB1SIDL = 0xF32 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } TXB1SIDHBITS; 
.................... TXB1SIDHBITS TXB1SIDHbits; 
.................... #byte TXB1SIDHbits = 0xF31 
.................... #byte TXB1SIDH = 0xF31 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int TXPRI0:2; 
....................          unsigned int :1; 
....................          unsigned int TXREQ:1; 
....................          unsigned int TXERR:1; 
....................          unsigned int TXLARB:1; 
....................          unsigned int TXABT:1; 
....................          unsigned int TXBIF:1; 
....................       }; 
....................       struct { 
....................          unsigned int TXPRI:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :7; 
....................          unsigned int TXBIFTXB1CON:1; 
....................       }; 
....................    }; 
.................... } TXB1CONBITS; 
.................... TXB1CONBITS TXB1CONbits; 
.................... #byte TXB1CONbits = 0xF30 
.................... #byte TXB1CON = 0xF30 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int FP0:1; 
....................          unsigned int WIN0_FP1:1; 
....................          unsigned int WIN1_FP2:1; 
....................          unsigned int WIN2_FP3:1; 
....................          unsigned int ABAT:1; 
....................          unsigned int REQOP0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int REQOP:3; 
....................       }; 
.................... } CANCON_RO3BITS; 
.................... CANCON_RO3BITS CANCON_RO3bits; 
.................... #byte CANCON_RO3bits = 0xF2F 
.................... #byte CANCON_RO3 = 0xF2F 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EICODE0:1; 
....................          unsigned int EICODE1_ICODE0:1; 
....................          unsigned int EICODE2_ICODE1:1; 
....................          unsigned int EICODE3_ICODE2:1; 
....................          unsigned int EICODE4:1; 
....................          unsigned int OPMODE0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int OPMODE:3; 
....................       }; 
.................... } CANSTAT_RO3BITS; 
.................... CANSTAT_RO3BITS CANSTAT_RO3bits; 
.................... #byte CANSTAT_RO3bits = 0xF2E 
.................... #byte CANSTAT_RO3 = 0xF2E 
....................  
.................... #byte TXB2D7 = 0xF2D 
....................  
.................... #byte TXB2D6 = 0xF2C 
....................  
.................... #byte TXB2D5 = 0xF2B 
....................  
.................... #byte TXB2D4 = 0xF2A 
....................  
.................... #byte TXB2D3 = 0xF29 
....................  
.................... #byte TXB2D2 = 0xF28 
....................  
.................... #byte TXB2D1 = 0xF27 
....................  
.................... #byte TXB2D0 = 0xF26 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int DLC0:4; 
....................          unsigned int :2; 
....................          unsigned int TXRTR:1; 
....................       }; 
....................       struct { 
....................          unsigned int DLC:4; 
....................          unsigned int :2; 
....................       }; 
.................... } TXB2DLCBITS; 
.................... TXB2DLCBITS TXB2DLCbits; 
.................... #byte TXB2DLCbits = 0xF25 
.................... #byte TXB2DLC = 0xF25 
....................  
.................... #byte TXB2EIDL = 0xF24 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } TXB2EIDHBITS; 
.................... TXB2EIDHBITS TXB2EIDHbits; 
.................... #byte TXB2EIDHbits = 0xF23 
.................... #byte TXB2EIDH = 0xF23 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDE:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } TXB2SIDLBITS; 
.................... TXB2SIDLBITS TXB2SIDLbits; 
.................... #byte TXB2SIDLbits = 0xF22 
.................... #byte TXB2SIDL = 0xF22 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } TXB2SIDHBITS; 
.................... TXB2SIDHBITS TXB2SIDHbits; 
.................... #byte TXB2SIDHbits = 0xF21 
.................... #byte TXB2SIDH = 0xF21 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :7; 
....................          unsigned int TXBIFBXB2CON:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int TXPRI0:2; 
....................          unsigned int :1; 
....................          unsigned int TXREQ:1; 
....................          unsigned int TXERR:1; 
....................          unsigned int TXLARB:1; 
....................          unsigned int TXABT:1; 
....................          unsigned int TXBIF:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int TXPRI:2; 
....................       }; 
.................... } TXB2CONBITS; 
.................... TXB2CONBITS TXB2CONbits; 
.................... #byte TXB2CONbits = 0xF20 
.................... #byte TXB2CON = 0xF20 
....................  
.................... #byte RXM1EIDL = 0xF1F 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXM1EIDHBITS; 
.................... RXM1EIDHBITS RXM1EIDHbits; 
.................... #byte RXM1EIDHbits = 0xF1E 
.................... #byte RXM1EIDH = 0xF1E 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } RXM1SIDLBITS; 
.................... RXM1SIDLBITS RXM1SIDLbits; 
.................... #byte RXM1SIDLbits = 0xF1D 
.................... #byte RXM1SIDL = 0xF1D 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXM1SIDHBITS; 
.................... RXM1SIDHBITS RXM1SIDHbits; 
.................... #byte RXM1SIDHbits = 0xF1C 
.................... #byte RXM1SIDH = 0xF1C 
....................  
.................... #byte RXM0EIDL = 0xF1B 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXM0EIDHBITS; 
.................... RXM0EIDHBITS RXM0EIDHbits; 
.................... #byte RXM0EIDHbits = 0xF1A 
.................... #byte RXM0EIDH = 0xF1A 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } RXM0SIDLBITS; 
.................... RXM0SIDLBITS RXM0SIDLbits; 
.................... #byte RXM0SIDLbits = 0xF19 
.................... #byte RXM0SIDL = 0xF19 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXM0SIDHBITS; 
.................... RXM0SIDHBITS RXM0SIDHbits; 
.................... #byte RXM0SIDHbits = 0xF18 
.................... #byte RXM0SIDH = 0xF18 
....................  
.................... #byte RXF5EIDL = 0xF17 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF5EIDHBITS; 
.................... RXF5EIDHBITS RXF5EIDHbits; 
.................... #byte RXF5EIDHbits = 0xF16 
.................... #byte RXF5EIDH = 0xF16 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................    }; 
.................... } RXF5SIDLBITS; 
.................... RXF5SIDLBITS RXF5SIDLbits; 
.................... #byte RXF5SIDLbits = 0xF15 
.................... #byte RXF5SIDL = 0xF15 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF5SIDHBITS; 
.................... RXF5SIDHBITS RXF5SIDHbits; 
.................... #byte RXF5SIDHbits = 0xF14 
.................... #byte RXF5SIDH = 0xF14 
....................  
.................... #byte RXF4EIDL = 0xF13 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF4EIDHBITS; 
.................... RXF4EIDHBITS RXF4EIDHbits; 
.................... #byte RXF4EIDHbits = 0xF12 
.................... #byte RXF4EIDH = 0xF12 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................    }; 
.................... } RXF4SIDLBITS; 
.................... RXF4SIDLBITS RXF4SIDLbits; 
.................... #byte RXF4SIDLbits = 0xF11 
.................... #byte RXF4SIDL = 0xF11 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF4SIDHBITS; 
.................... RXF4SIDHBITS RXF4SIDHbits; 
.................... #byte RXF4SIDHbits = 0xF10 
.................... #byte RXF4SIDH = 0xF10 
....................  
.................... #byte RXF3EIDL = 0xF0F 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF3EIDHBITS; 
.................... RXF3EIDHBITS RXF3EIDHbits; 
.................... #byte RXF3EIDHbits = 0xF0E 
.................... #byte RXF3EIDH = 0xF0E 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } RXF3SIDLBITS; 
.................... RXF3SIDLBITS RXF3SIDLbits; 
.................... #byte RXF3SIDLbits = 0xF0D 
.................... #byte RXF3SIDL = 0xF0D 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF3SIDHBITS; 
.................... RXF3SIDHBITS RXF3SIDHbits; 
.................... #byte RXF3SIDHbits = 0xF0C 
.................... #byte RXF3SIDH = 0xF0C 
....................  
.................... #byte RXF2EIDL = 0xF0B 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF2EIDHBITS; 
.................... RXF2EIDHBITS RXF2EIDHbits; 
.................... #byte RXF2EIDHbits = 0xF0A 
.................... #byte RXF2EIDH = 0xF0A 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................    }; 
.................... } RXF2SIDLBITS; 
.................... RXF2SIDLBITS RXF2SIDLbits; 
.................... #byte RXF2SIDLbits = 0xF09 
.................... #byte RXF2SIDL = 0xF09 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF2SIDHBITS; 
.................... RXF2SIDHBITS RXF2SIDHbits; 
.................... #byte RXF2SIDHbits = 0xF08 
.................... #byte RXF2SIDH = 0xF08 
....................  
.................... #byte RXF1EIDL = 0xF07 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF1EIDHBITS; 
.................... RXF1EIDHBITS RXF1EIDHbits; 
.................... #byte RXF1EIDHbits = 0xF06 
.................... #byte RXF1EIDH = 0xF06 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } RXF1SIDLBITS; 
.................... RXF1SIDLBITS RXF1SIDLbits; 
.................... #byte RXF1SIDLbits = 0xF05 
.................... #byte RXF1SIDL = 0xF05 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF1SIDHBITS; 
.................... RXF1SIDHBITS RXF1SIDHbits; 
.................... #byte RXF1SIDHbits = 0xF04 
.................... #byte RXF1SIDH = 0xF04 
....................  
.................... #byte RXF0EIDL = 0xF03 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF0EIDHBITS; 
.................... RXF0EIDHBITS RXF0EIDHbits; 
.................... #byte RXF0EIDHbits = 0xF02 
.................... #byte RXF0EIDH = 0xF02 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................    }; 
.................... } RXF0SIDLBITS; 
.................... RXF0SIDLBITS RXF0SIDLbits; 
.................... #byte RXF0SIDLbits = 0xF01 
.................... #byte RXF0SIDL = 0xF01 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF0SIDHBITS; 
.................... RXF0SIDHBITS RXF0SIDHbits; 
.................... #byte RXF0SIDHbits = 0xF00 
.................... #byte RXF0SIDH = 0xF00 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int FP0:1; 
....................          unsigned int WIN0_FP1:1; 
....................          unsigned int WIN1_FP2:1; 
....................          unsigned int WIN2_FP3:1; 
....................          unsigned int ABAT:1; 
....................          unsigned int REQOP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int REQOP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN:3; 
....................       }; 
.................... } CANCON_RO4BITS; 
.................... CANCON_RO4BITS CANCON_RO4bits; 
.................... #byte CANCON_RO4bits = 0xE7F 
.................... #byte CANCON_RO4 = 0xE7F 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EICODE0:1; 
....................          unsigned int EICODE1_ICODE0:1; 
....................          unsigned int EICODE2_ICODE1:1; 
....................          unsigned int EICODE3_ICODE2:1; 
....................          unsigned int EICODE4:1; 
....................          unsigned int OPMODE0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int OPMODE:3; 
....................       }; 
.................... } CANSTAT_RO4BITS; 
.................... CANSTAT_RO4BITS CANSTAT_RO4bits; 
.................... #byte CANSTAT_RO4bits = 0xE7E 
.................... #byte CANSTAT_RO4 = 0xE7E 
....................  
.................... #byte B5D7 = 0xE7D 
....................  
.................... #byte B5D6 = 0xE7C 
....................  
.................... #byte B5D5 = 0xE7B 
....................  
.................... #byte B5D4 = 0xE7A 
....................  
.................... #byte B5D3 = 0xE79 
....................  
.................... #byte B5D2 = 0xE78 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :3; 
....................    unsigned int B57D23:1; 
.................... } B5D2BITS; 
.................... B5D2BITS B5D2bits; 
.................... #byte B5D2bits = 0xE78 
.................... #byte B5D2 = 0xE78 
....................  
.................... #byte B5D1 = 0xE77 
....................  
.................... #byte B5D0 = 0xE76 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :7; 
....................    unsigned int B57D07:1; 
.................... } B5D0BITS; 
.................... B5D0BITS B5D0bits; 
.................... #byte B5D0bits = 0xE76 
.................... #byte B5D0 = 0xE76 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB0:2; 
....................          unsigned int RXRTR:1; 
....................       }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int DLC0:4; 
....................          unsigned int RB0:2; 
....................          unsigned int RXRTR_TXRTR:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int DLC:4; 
....................          unsigned int RB:2; 
....................       }; 
.................... } B5DLCBITS; 
.................... B5DLCBITS B5DLCbits; 
.................... #byte B5DLCbits = 0xE75 
.................... #byte B5DLC = 0xE75 
....................  
.................... #byte B5EIDL = 0xE74 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } B5EIDHBITS; 
.................... B5EIDHBITS B5EIDHbits; 
.................... #byte B5EIDHbits = 0xE73 
.................... #byte B5EIDH = 0xE73 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDEN:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDE:1; 
....................          unsigned int SRR:1; 
....................          unsigned int SID0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXID:1; 
....................       }; 
....................    }; 
.................... } B5SIDLBITS; 
.................... B5SIDLBITS B5SIDLbits; 
.................... #byte B5SIDLbits = 0xE72 
.................... #byte B5SIDL = 0xE72 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } B5SIDHBITS; 
.................... B5SIDHBITS B5SIDHbits; 
.................... #byte B5SIDHbits = 0xE71 
.................... #byte B5SIDH = 0xE71 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int RXRTRRO:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int TXPRI0:2; 
....................          unsigned int RTREN:1; 
....................          unsigned int TXREQ:1; 
....................          unsigned int TXERR:1; 
....................          unsigned int TXLARB:1; 
....................          unsigned int TXABT:1; 
....................          unsigned int TXBIF:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int TXPRI:2; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int FILHIT0:5; 
....................          unsigned int RTRRO:1; 
....................          unsigned int RXM1:1; 
....................          unsigned int RXFUL:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int FILHIT:5; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int FILHIT0_TXPRI0:1; 
....................          unsigned int FILHIT1_TXPRI1:1; 
....................          unsigned int FILHIT2_RTREN:1; 
....................          unsigned int FILHIT3_TXREQ:1; 
....................          unsigned int FILHIT4_TXERR:1; 
....................          unsigned int RXRTRRO_TXLARB:1; 
....................          unsigned int RXM1_TXABT:1; 
....................          unsigned int RXFUL_TXBIF:1; 
....................       }; 
....................    }; 
.................... } B5CONBITS; 
.................... B5CONBITS B5CONbits; 
.................... #byte B5CONbits = 0xE70 
.................... #byte B5CON = 0xE70 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int FP0:1; 
....................          unsigned int WIN0_FP1:1; 
....................          unsigned int WIN1_FP2:1; 
....................          unsigned int WIN2_FP3:1; 
....................          unsigned int ABAT:1; 
....................          unsigned int REQOP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int REQOP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN:3; 
....................       }; 
.................... } CANCON_RO5BITS; 
.................... CANCON_RO5BITS CANCON_RO5bits; 
.................... #byte CANCON_RO5bits = 0xE6F 
.................... #byte CANCON_RO5 = 0xE6F 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EICODE0:1; 
....................          unsigned int EICODE1_ICODE0:1; 
....................          unsigned int EICODE2_ICODE1:1; 
....................          unsigned int EICODE3_ICODE2:1; 
....................          unsigned int EICODE4:1; 
....................          unsigned int OPMODE0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int OPMODE:3; 
....................       }; 
.................... } CANSTAT_RO5BITS; 
.................... CANSTAT_RO5BITS CANSTAT_RO5bits; 
.................... #byte CANSTAT_RO5bits = 0xE6E 
.................... #byte CANSTAT_RO5 = 0xE6E 
....................  
.................... #byte B4D7 = 0xE6D 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :7; 
....................    unsigned int B46D77:1; 
.................... } B4D7BITS; 
.................... B4D7BITS B4D7bits; 
.................... #byte B4D7bits = 0xE6D 
.................... #byte B4D7 = 0xE6D 
....................  
.................... #byte B4D6 = 0xE6C 
....................  
.................... #byte B4D5 = 0xE6B 
....................  
.................... #byte B4D4 = 0xE6A 
....................  
.................... #byte B4D3 = 0xE69 
....................  
.................... #byte B4D2 = 0xE68 
....................  
.................... #byte B4D1 = 0xE67 
....................  
.................... #byte B4D0 = 0xE66 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :6; 
....................          unsigned int RXRTR:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB0:2; 
....................          unsigned int TXRTR:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int DLC0:4; 
....................          unsigned int RB0:2; 
....................          unsigned int RXRTR_TXRTR:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int DLC:4; 
....................          unsigned int RB:2; 
....................       }; 
.................... } B4DLCBITS; 
.................... B4DLCBITS B4DLCbits; 
.................... #byte B4DLCbits = 0xE65 
.................... #byte B4DLC = 0xE65 
....................  
.................... #byte B4EIDL = 0xE64 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } B4EIDHBITS; 
.................... B4EIDHBITS B4EIDHbits; 
.................... #byte B4EIDHbits = 0xE63 
.................... #byte B4EIDH = 0xE63 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDE:1; 
....................          unsigned int SRR:1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXID:1; 
....................       }; 
....................    }; 
.................... } B4SIDLBITS; 
.................... B4SIDLBITS B4SIDLbits; 
.................... #byte B4SIDLbits = 0xE62 
.................... #byte B4SIDL = 0xE62 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } B4SIDHBITS; 
.................... B4SIDHBITS B4SIDHbits; 
.................... #byte B4SIDHbits = 0xE61 
.................... #byte B4SIDH = 0xE61 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int RXRTRRO:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int FILHIT0_TXPRI0:1; 
....................          unsigned int FILHIT1_TXPRI1:1; 
....................          unsigned int FILHIT2_RTREN:1; 
....................          unsigned int FILHIT3_TXREQ:1; 
....................          unsigned int FILHIT4_TXERR:1; 
....................          unsigned int RXRTRRO_TXLARB:1; 
....................          unsigned int RXM1_TXABT:1; 
....................          unsigned int RXFUL_TXBIF:1; 
....................       }; 
....................    }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int FILHIT0:5; 
....................          unsigned int RTRRO:1; 
....................          unsigned int RXM1:1; 
....................          unsigned int RXFUL:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int FILHIT:5; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int TXPRI0:2; 
....................          unsigned int RTREN:1; 
....................          unsigned int TXREQ:1; 
....................          unsigned int TXERR:1; 
....................          unsigned int TXLARB:1; 
....................          unsigned int TXABT:1; 
....................          unsigned int TXBIF:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int TXPRI:2; 
....................       }; 
.................... } B4CONBITS; 
.................... B4CONBITS B4CONbits; 
.................... #byte B4CONbits = 0xE60 
.................... #byte B4CON = 0xE60 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int FP0:1; 
....................          unsigned int WIN0_FP1:1; 
....................          unsigned int WIN1_FP2:1; 
....................          unsigned int WIN2_FP3:1; 
....................          unsigned int ABAT:1; 
....................          unsigned int REQOP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int REQOP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN:3; 
....................       }; 
.................... } CANCON_RO6BITS; 
.................... CANCON_RO6BITS CANCON_RO6bits; 
.................... #byte CANCON_RO6bits = 0xE5F 
.................... #byte CANCON_RO6 = 0xE5F 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EICODE0:1; 
....................          unsigned int EICODE1_ICODE0:1; 
....................          unsigned int EICODE2_ICODE1:1; 
....................          unsigned int EICODE3_ICODE2:1; 
....................          unsigned int EICODE4:1; 
....................          unsigned int OPMODE0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int OPMODE:3; 
....................       }; 
.................... } CANSTAT_RO6BITS; 
.................... CANSTAT_RO6BITS CANSTAT_RO6bits; 
.................... #byte CANSTAT_RO6bits = 0xE5E 
.................... #byte CANSTAT_RO6 = 0xE5E 
....................  
.................... #byte B3D7 = 0xE5D 
....................  
.................... #byte B3D6 = 0xE5C 
....................  
.................... #byte B3D5 = 0xE5B 
....................  
.................... #byte B3D4 = 0xE5A 
....................  
.................... #byte B3D3 = 0xE59 
....................  
.................... #byte B3D2 = 0xE58 
....................  
.................... #byte B3D1 = 0xE57 
....................  
.................... #byte B3D0 = 0xE56 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :6; 
....................          unsigned int RXRTR:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB0:2; 
....................          unsigned int TXRTR:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int DLC0:4; 
....................          unsigned int RB0:2; 
....................          unsigned int RXRTR_TXRTR:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int DLC:4; 
....................          unsigned int RB:2; 
....................       }; 
.................... } B3DLCBITS; 
.................... B3DLCBITS B3DLCbits; 
.................... #byte B3DLCbits = 0xE55 
.................... #byte B3DLC = 0xE55 
....................  
.................... #byte B3EIDL = 0xE54 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } B3EIDHBITS; 
.................... B3EIDHBITS B3EIDHbits; 
.................... #byte B3EIDHbits = 0xE53 
.................... #byte B3EIDH = 0xE53 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDE:1; 
....................          unsigned int SRR:1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXID:1; 
....................       }; 
....................    }; 
.................... } B3SIDLBITS; 
.................... B3SIDLBITS B3SIDLbits; 
.................... #byte B3SIDLbits = 0xE52 
.................... #byte B3SIDL = 0xE52 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } B3SIDHBITS; 
.................... B3SIDHBITS B3SIDHbits; 
.................... #byte B3SIDHbits = 0xE51 
.................... #byte B3SIDH = 0xE51 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int RXRTRRO:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int TXPRI0:2; 
....................          unsigned int RTREN:1; 
....................          unsigned int TXREQ:1; 
....................          unsigned int TXERR:1; 
....................          unsigned int TXLARB:1; 
....................          unsigned int TXABT:1; 
....................          unsigned int TXBIF:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int TXPRI:2; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int FILHIT0_TXPRI0:1; 
....................          unsigned int FILHIT1_TXPRI1:1; 
....................          unsigned int FILHIT2_RTREN:1; 
....................          unsigned int FILHIT3_TXREQ:1; 
....................          unsigned int FILHIT4_TXERR:1; 
....................          unsigned int RXRTRRO_TXLARB:1; 
....................          unsigned int RXM1_TXABT:1; 
....................          unsigned int RXFUL_TXBIF:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int FILHIT0:5; 
....................          unsigned int RTRRO:1; 
....................          unsigned int RXM1:1; 
....................          unsigned int RXFUL:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int FILHIT:5; 
....................       }; 
.................... } B3CONBITS; 
.................... B3CONBITS B3CONbits; 
.................... #byte B3CONbits = 0xE50 
.................... #byte B3CON = 0xE50 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int FP0:1; 
....................          unsigned int WIN0_FP1:1; 
....................          unsigned int WIN1_FP2:1; 
....................          unsigned int WIN2_FP3:1; 
....................          unsigned int ABAT:1; 
....................          unsigned int REQOP0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int REQOP:3; 
....................       }; 
.................... } CANCON_RO7BITS; 
.................... CANCON_RO7BITS CANCON_RO7bits; 
.................... #byte CANCON_RO7bits = 0xE4F 
.................... #byte CANCON_RO7 = 0xE4F 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EICODE0:1; 
....................          unsigned int EICODE1_ICODE0:1; 
....................          unsigned int EICODE2_ICODE1:1; 
....................          unsigned int EICODE3_ICODE2:1; 
....................          unsigned int EICODE4:1; 
....................          unsigned int OPMODE0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int OPMODE:3; 
....................       }; 
.................... } CANSTAT_RO7BITS; 
.................... CANSTAT_RO7BITS CANSTAT_RO7bits; 
.................... #byte CANSTAT_RO7bits = 0xE4E 
.................... #byte CANSTAT_RO7 = 0xE4E 
....................  
.................... #byte B2D7 = 0xE4D 
....................  
.................... #byte B2D6 = 0xE4C 
....................  
.................... #byte B2D5 = 0xE4B 
....................  
.................... #byte B2D4 = 0xE4A 
....................  
.................... #byte B2D3 = 0xE49 
....................  
.................... #byte B2D2 = 0xE48 
....................  
.................... #byte B2D1 = 0xE47 
....................  
.................... #byte B2D0 = 0xE46 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :6; 
....................          unsigned int RXRTR:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB0:2; 
....................          unsigned int TXRTR:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int DLC0:4; 
....................          unsigned int RB0:2; 
....................          unsigned int RXRTR_TXRTR:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int DLC:4; 
....................          unsigned int RB:2; 
....................       }; 
.................... } B2DLCBITS; 
.................... B2DLCBITS B2DLCbits; 
.................... #byte B2DLCbits = 0xE45 
.................... #byte B2DLC = 0xE45 
....................  
.................... #byte B2EIDL = 0xE44 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } B2EIDHBITS; 
.................... B2EIDHBITS B2EIDHbits; 
.................... #byte B2EIDHbits = 0xE43 
.................... #byte B2EIDH = 0xE43 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXID:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDE:1; 
....................          unsigned int SRR:1; 
....................          unsigned int SID0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } B2SIDLBITS; 
.................... B2SIDLBITS B2SIDLbits; 
.................... #byte B2SIDLbits = 0xE42 
.................... #byte B2SIDL = 0xE42 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } B2SIDHBITS; 
.................... B2SIDHBITS B2SIDHbits; 
.................... #byte B2SIDHbits = 0xE41 
.................... #byte B2SIDH = 0xE41 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int RXRTRRO:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int TXPRI0:2; 
....................          unsigned int RTREN:1; 
....................          unsigned int TXREQ:1; 
....................          unsigned int TXERR:1; 
....................          unsigned int TXLARB:1; 
....................          unsigned int TXABT:1; 
....................          unsigned int TXBIF:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int TXPRI:2; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int FILHIT0_TXPRI0:1; 
....................          unsigned int FILHIT1_TXPRI1:1; 
....................          unsigned int FILHIT2_RTREN:1; 
....................          unsigned int FILHIT3_TXREQ:1; 
....................          unsigned int FILHIT4_TXERR:1; 
....................          unsigned int RXRTRRO_TXLARB:1; 
....................          unsigned int RXM1_TXABT:1; 
....................          unsigned int RXFUL_TXBIF:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int FILHIT0:5; 
....................          unsigned int RTRRO:1; 
....................          unsigned int RXM1:1; 
....................          unsigned int RXFUL:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int FILHIT:5; 
....................       }; 
.................... } B2CONBITS; 
.................... B2CONBITS B2CONbits; 
.................... #byte B2CONbits = 0xE40 
.................... #byte B2CON = 0xE40 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int FP0:1; 
....................          unsigned int WIN0_FP1:1; 
....................          unsigned int WIN1_FP2:1; 
....................          unsigned int WIN2_FP3:1; 
....................          unsigned int ABAT:1; 
....................          unsigned int REQOP0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int REQOP:3; 
....................       }; 
.................... } CANCON_RO8BITS; 
.................... CANCON_RO8BITS CANCON_RO8bits; 
.................... #byte CANCON_RO8bits = 0xE3F 
.................... #byte CANCON_RO8 = 0xE3F 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EICODE0:1; 
....................          unsigned int EICODE1_ICODE0:1; 
....................          unsigned int EICODE2_ICODE1:1; 
....................          unsigned int EICODE3_ICODE2:1; 
....................          unsigned int EICODE4:1; 
....................          unsigned int OPMODE0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int OPMODE:3; 
....................       }; 
.................... } CANSTAT_RO8BITS; 
.................... CANSTAT_RO8BITS CANSTAT_RO8bits; 
.................... #byte CANSTAT_RO8bits = 0xE3E 
.................... #byte CANSTAT_RO8 = 0xE3E 
....................  
.................... #byte B1D7 = 0xE3D 
....................  
.................... #byte B1D6 = 0xE3C 
....................  
.................... #byte B1D5 = 0xE3B 
....................  
.................... #byte B1D4 = 0xE3A 
....................  
.................... #byte B1D3 = 0xE39 
....................  
.................... #byte B1D2 = 0xE38 
....................  
.................... #byte B1D1 = 0xE37 
....................  
.................... #byte B1D0 = 0xE36 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :6; 
....................          unsigned int RXRTR:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB0:2; 
....................          unsigned int TXRTR:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int DLC0:4; 
....................          unsigned int RB0:2; 
....................          unsigned int RXRTR_TXRTR:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int DLC:4; 
....................          unsigned int RB:2; 
....................       }; 
.................... } B1DLCBITS; 
.................... B1DLCBITS B1DLCbits; 
.................... #byte B1DLCbits = 0xE35 
.................... #byte B1DLC = 0xE35 
....................  
.................... #byte B1EIDL = 0xE34 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } B1EIDHBITS; 
.................... B1EIDHBITS B1EIDHbits; 
.................... #byte B1EIDHbits = 0xE33 
.................... #byte B1EIDH = 0xE33 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDE:1; 
....................          unsigned int SRR:1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXID:1; 
....................       }; 
....................    }; 
.................... } B1SIDLBITS; 
.................... B1SIDLBITS B1SIDLbits; 
.................... #byte B1SIDLbits = 0xE32 
.................... #byte B1SIDL = 0xE32 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } B1SIDHBITS; 
.................... B1SIDHBITS B1SIDHbits; 
.................... #byte B1SIDHbits = 0xE31 
.................... #byte B1SIDH = 0xE31 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int RXRTRRO:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int TXPRI0:2; 
....................          unsigned int RTREN:1; 
....................          unsigned int TXREQ:1; 
....................          unsigned int TXERR:1; 
....................          unsigned int TXLARB:1; 
....................          unsigned int TXABT:1; 
....................          unsigned int TXBIF:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int TXPRI:2; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int FILHIT0:5; 
....................          unsigned int RTRRO:1; 
....................          unsigned int RXM1:1; 
....................          unsigned int RXFUL:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int FILHIT:5; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int FILHIT0_TXPRI0:1; 
....................          unsigned int FILHIT1_TXPRI1:1; 
....................          unsigned int FILHIT2_RTREN:1; 
....................          unsigned int FILHIT3_TXREQ:1; 
....................          unsigned int FILHIT4_TXERR:1; 
....................          unsigned int RXRTRRO_TXLARB:1; 
....................          unsigned int RXM1_TXABT:1; 
....................          unsigned int RXFUL_TXBIF:1; 
....................       }; 
....................    }; 
.................... } B1CONBITS; 
.................... B1CONBITS B1CONbits; 
.................... #byte B1CONbits = 0xE30 
.................... #byte B1CON = 0xE30 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int FP0:1; 
....................          unsigned int WIN0_FP1:1; 
....................          unsigned int WIN1_FP2:1; 
....................          unsigned int WIN2_FP3:1; 
....................          unsigned int ABAT:1; 
....................          unsigned int REQOP0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int REQOP:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int WIN:3; 
....................       }; 
.................... } CANCON_RO9BITS; 
.................... CANCON_RO9BITS CANCON_RO9bits; 
.................... #byte CANCON_RO9bits = 0xE2F 
.................... #byte CANCON_RO9 = 0xE2F 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int EICODE0:1; 
....................          unsigned int EICODE1_ICODE0:1; 
....................          unsigned int EICODE2_ICODE1:1; 
....................          unsigned int EICODE3_ICODE2:1; 
....................          unsigned int EICODE4:1; 
....................          unsigned int OPMODE0:3; 
....................       }; 
....................       struct { 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int OPMODE:3; 
....................       }; 
.................... } CANSTAT_RO9BITS; 
.................... CANSTAT_RO9BITS CANSTAT_RO9bits; 
.................... #byte CANSTAT_RO9bits = 0xE2E 
.................... #byte CANSTAT_RO9 = 0xE2E 
....................  
.................... #byte B0D7 = 0xE2D 
....................  
.................... #byte B0D6 = 0xE2C 
....................  
.................... #byte B0D5 = 0xE2B 
....................  
.................... #byte B0D4 = 0xE2A 
....................  
.................... #byte B0D3 = 0xE29 
....................  
.................... #byte B0D2 = 0xE28 
....................  
.................... #byte B0D1 = 0xE27 
....................  
.................... #byte B0D0 = 0xE26 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :6; 
....................          unsigned int RXRTR:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB0:2; 
....................          unsigned int TXRTR:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int :4; 
....................          unsigned int RESRB:2; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int DLC0:4; 
....................          unsigned int RB0:2; 
....................          unsigned int RXRTR_TXRTR:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int DLC:4; 
....................          unsigned int RB:2; 
....................       }; 
.................... } B0DLCBITS; 
.................... B0DLCBITS B0DLCbits; 
.................... #byte B0DLCbits = 0xE25 
.................... #byte B0DLC = 0xE25 
....................  
.................... #byte B0EIDL = 0xE24 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } B0EIDHBITS; 
.................... B0EIDHBITS B0EIDHbits; 
.................... #byte B0EIDHbits = 0xE23 
.................... #byte B0EIDH = 0xE23 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXID:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDE:1; 
....................          unsigned int SRR:1; 
....................          unsigned int SID0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } B0SIDLBITS; 
.................... B0SIDLBITS B0SIDLbits; 
.................... #byte B0SIDLbits = 0xE22 
.................... #byte B0SIDL = 0xE22 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } B0SIDHBITS; 
.................... B0SIDHBITS B0SIDHbits; 
.................... #byte B0SIDHbits = 0xE21 
.................... #byte B0SIDH = 0xE21 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :5; 
....................          unsigned int RXRTRRO:1; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int TXPRI0:2; 
....................          unsigned int RTREN:1; 
....................          unsigned int TXREQ:1; 
....................          unsigned int TXERR:1; 
....................          unsigned int TXLARB:1; 
....................          unsigned int TXABT:1; 
....................          unsigned int TXBIF:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int TXPRI:2; 
....................       }; 
....................  
....................    union { 
....................       struct { 
....................          unsigned int FILHIT0_TXPRI0:1; 
....................          unsigned int FILHIT1_TXPRI1:1; 
....................          unsigned int FILHIT2_RTREN:1; 
....................          unsigned int FILHIT3_TXREQ:1; 
....................          unsigned int FILHIT4_TXERR:1; 
....................          unsigned int RXRTRRO_TXLARB:1; 
....................          unsigned int RXM1_TXABT:1; 
....................          unsigned int RXFUL_TXBIF:1; 
....................       }; 
....................    }; 
....................  
....................       struct { 
....................          unsigned int FILHIT0:5; 
....................          unsigned int RTRRO:1; 
....................          unsigned int RXM1:1; 
....................          unsigned int RXFUL:1; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int FILHIT:5; 
....................       }; 
.................... } B0CONBITS; 
.................... B0CONBITS B0CONbits; 
.................... #byte B0CONbits = 0xE20 
.................... #byte B0CON = 0xE20 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :2; 
....................    unsigned int TXB0IE:1; 
....................    unsigned int TXB1IE:1; 
....................    unsigned int TXB2IE:1; 
.................... } TXBIEBITS; 
.................... TXBIEBITS TXBIEbits; 
.................... #byte TXBIEbits = 0xDFC 
.................... #byte TXBIE = 0xDFC 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RXB0IE:1; 
....................    unsigned int RXB1IE:1; 
....................    unsigned int B0IE:1; 
....................    unsigned int B1IE:1; 
....................    unsigned int B2IE:1; 
....................    unsigned int B3IE:1; 
....................    unsigned int B4IE:1; 
....................    unsigned int B5IE:1; 
.................... } BIE0BITS; 
.................... BIE0BITS BIE0bits; 
.................... #byte BIE0bits = 0xDFA 
.................... #byte BIE0 = 0xDFA 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int :2; 
....................    unsigned int B0TXEN:1; 
....................    unsigned int B1TXEN:1; 
....................    unsigned int B2TXEN:1; 
....................    unsigned int B3TXEN:1; 
....................    unsigned int B4TXEN:1; 
....................    unsigned int B5TXEN:1; 
.................... } BSEL0BITS; 
.................... BSEL0BITS BSEL0bits; 
.................... #byte BSEL0bits = 0xDF8 
.................... #byte BSEL0 = 0xDF8 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int FIL12_0:2; 
....................          unsigned int FIL13_0:2; 
....................          unsigned int FIL14_0:2; 
....................          unsigned int FIL15_0:2; 
....................       }; 
....................       struct { 
....................          unsigned int FIL12_:2; 
....................          unsigned int FIL13_:2; 
....................          unsigned int FIL14_:2; 
....................          unsigned int FIL15_:2; 
....................       }; 
.................... } MSEL3BITS; 
.................... MSEL3BITS MSEL3bits; 
.................... #byte MSEL3bits = 0xDF3 
.................... #byte MSEL3 = 0xDF3 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int FIL8_0:2; 
....................          unsigned int FIL9_0:2; 
....................          unsigned int FIL10_0:2; 
....................          unsigned int FIL11_0:2; 
....................       }; 
....................       struct { 
....................          unsigned int FIL8_:2; 
....................          unsigned int FIL9_:2; 
....................          unsigned int FIL10_:2; 
....................          unsigned int FIL11_:2; 
....................       }; 
.................... } MSEL2BITS; 
.................... MSEL2BITS MSEL2bits; 
.................... #byte MSEL2bits = 0xDF2 
.................... #byte MSEL2 = 0xDF2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int FIL4_0:2; 
....................          unsigned int FIL5_0:2; 
....................          unsigned int FIL6_0:2; 
....................          unsigned int FIL7_0:2; 
....................       }; 
....................       struct { 
....................          unsigned int FIL4_:2; 
....................          unsigned int FIL5_:2; 
....................          unsigned int FIL6_:2; 
....................          unsigned int FIL7_:2; 
....................       }; 
.................... } MSEL1BITS; 
.................... MSEL1BITS MSEL1bits; 
.................... #byte MSEL1bits = 0xDF1 
.................... #byte MSEL1 = 0xDF1 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int FIL0_0:2; 
....................          unsigned int FIL1_0:2; 
....................          unsigned int FIL2_0:2; 
....................          unsigned int FIL3_0:2; 
....................       }; 
....................       struct { 
....................          unsigned int FIL0_:2; 
....................          unsigned int FIL1_:2; 
....................          unsigned int FIL2_:2; 
....................          unsigned int FIL3_:2; 
....................       }; 
.................... } MSEL0BITS; 
.................... MSEL0BITS MSEL0bits; 
.................... #byte MSEL0bits = 0xDF0 
.................... #byte MSEL0 = 0xDF0 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int F14BP_0:4; 
....................          unsigned int F15BP_0:4; 
....................       }; 
....................       struct { 
....................          unsigned int F14BP_:4; 
....................          unsigned int F15BP_:4; 
....................       }; 
.................... } RXFBCON7BITS; 
.................... RXFBCON7BITS RXFBCON7bits; 
.................... #byte RXFBCON7bits = 0xDE7 
.................... #byte RXFBCON7 = 0xDE7 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int F12BP_0:4; 
....................          unsigned int F13BP_0:4; 
....................       }; 
....................       struct { 
....................          unsigned int F12BP_:4; 
....................          unsigned int F13BP_:4; 
....................       }; 
.................... } RXFBCON6BITS; 
.................... RXFBCON6BITS RXFBCON6bits; 
.................... #byte RXFBCON6bits = 0xDE6 
.................... #byte RXFBCON6 = 0xDE6 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int F10BP_0:4; 
....................          unsigned int F11BP_0:4; 
....................       }; 
....................       struct { 
....................          unsigned int F10BP_:4; 
....................          unsigned int F11BP_:4; 
....................       }; 
.................... } RXFBCON5BITS; 
.................... RXFBCON5BITS RXFBCON5bits; 
.................... #byte RXFBCON5bits = 0xDE5 
.................... #byte RXFBCON5 = 0xDE5 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int F8BP_0:4; 
....................          unsigned int F9BP_0:4; 
....................       }; 
....................       struct { 
....................          unsigned int F8BP_:4; 
....................          unsigned int F9BP_:4; 
....................       }; 
.................... } RXFBCON4BITS; 
.................... RXFBCON4BITS RXFBCON4bits; 
.................... #byte RXFBCON4bits = 0xDE4 
.................... #byte RXFBCON4 = 0xDE4 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int F6BP_0:4; 
....................          unsigned int F7BP_0:4; 
....................       }; 
....................       struct { 
....................          unsigned int F6BP_:4; 
....................          unsigned int F7BP_:4; 
....................       }; 
.................... } RXFBCON3BITS; 
.................... RXFBCON3BITS RXFBCON3bits; 
.................... #byte RXFBCON3bits = 0xDE3 
.................... #byte RXFBCON3 = 0xDE3 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int F4BP_0:4; 
....................          unsigned int F5BP_0:4; 
....................       }; 
....................       struct { 
....................          unsigned int F4BP_:4; 
....................          unsigned int F5BP_:4; 
....................       }; 
.................... } RXFBCON2BITS; 
.................... RXFBCON2BITS RXFBCON2bits; 
.................... #byte RXFBCON2bits = 0xDE2 
.................... #byte RXFBCON2 = 0xDE2 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int F2BP_0:4; 
....................          unsigned int F3BP_0:4; 
....................       }; 
....................       struct { 
....................          unsigned int F2BP_:4; 
....................          unsigned int F3BP_:4; 
....................       }; 
.................... } RXFBCON1BITS; 
.................... RXFBCON1BITS RXFBCON1bits; 
.................... #byte RXFBCON1bits = 0xDE1 
.................... #byte RXFBCON1 = 0xDE1 
....................  
.................... typedef union  
....................  { 
....................       struct { 
....................          unsigned int F0BP_0:4; 
....................          unsigned int F1BP_0:4; 
....................       }; 
....................       struct { 
....................          unsigned int F0BP_:4; 
....................          unsigned int F1BP_:4; 
....................       }; 
.................... } RXFBCON0BITS; 
.................... RXFBCON0BITS RXFBCON0bits; 
.................... #byte RXFBCON0bits = 0xDE0 
.................... #byte RXFBCON0 = 0xDE0 
....................  
.................... #byte SDFLC = 0xDD8 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RXF8EN:1; 
....................    unsigned int RXF9EN:1; 
....................    unsigned int RXF10EN:1; 
....................    unsigned int RXF11EN:1; 
....................    unsigned int RXF12EN:1; 
....................    unsigned int RXF13EN:1; 
....................    unsigned int RXF14EN:1; 
....................    unsigned int RXF15EN:1; 
.................... } RXFCON1BITS; 
.................... RXFCON1BITS RXFCON1bits; 
.................... #byte RXFCON1bits = 0xDD5 
.................... #byte RXFCON1 = 0xDD5 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int RXF0EN:1; 
....................    unsigned int RXF1EN:1; 
....................    unsigned int RXF2EN:1; 
....................    unsigned int RXF3EN:1; 
....................    unsigned int RXF4EN:1; 
....................    unsigned int RXF5EN:1; 
....................    unsigned int RXF6EN:1; 
....................    unsigned int RXF7EN:1; 
.................... } RXFCON0BITS; 
.................... RXFCON0BITS RXFCON0bits; 
.................... #byte RXFCON0bits = 0xDD4 
.................... #byte RXFCON0 = 0xDD4 
....................  
.................... #byte RXF15EIDL = 0xD93 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF15EIDHBITS; 
.................... RXF15EIDHBITS RXF15EIDHbits; 
.................... #byte RXF15EIDHbits = 0xD92 
.................... #byte RXF15EIDH = 0xD92 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } RXF15SIDLBITS; 
.................... RXF15SIDLBITS RXF15SIDLbits; 
.................... #byte RXF15SIDLbits = 0xD91 
.................... #byte RXF15SIDL = 0xD91 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF15SIDHBITS; 
.................... RXF15SIDHBITS RXF15SIDHbits; 
.................... #byte RXF15SIDHbits = 0xD90 
.................... #byte RXF15SIDH = 0xD90 
....................  
.................... #byte RXF14EIDL = 0xD8B 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF14EIDHBITS; 
.................... RXF14EIDHBITS RXF14EIDHbits; 
.................... #byte RXF14EIDHbits = 0xD8A 
.................... #byte RXF14EIDH = 0xD8A 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................    }; 
.................... } RXF14SIDLBITS; 
.................... RXF14SIDLBITS RXF14SIDLbits; 
.................... #byte RXF14SIDLbits = 0xD89 
.................... #byte RXF14SIDL = 0xD89 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF14SIDHBITS; 
.................... RXF14SIDHBITS RXF14SIDHbits; 
.................... #byte RXF14SIDHbits = 0xD88 
.................... #byte RXF14SIDH = 0xD88 
....................  
.................... #byte RXF13EIDL = 0xD87 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF13EIDHBITS; 
.................... RXF13EIDHBITS RXF13EIDHbits; 
.................... #byte RXF13EIDHbits = 0xD86 
.................... #byte RXF13EIDH = 0xD86 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................    }; 
.................... } RXF13SIDLBITS; 
.................... RXF13SIDLBITS RXF13SIDLbits; 
.................... #byte RXF13SIDLbits = 0xD85 
.................... #byte RXF13SIDL = 0xD85 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF13SIDHBITS; 
.................... RXF13SIDHBITS RXF13SIDHbits; 
.................... #byte RXF13SIDHbits = 0xD84 
.................... #byte RXF13SIDH = 0xD84 
....................  
.................... #byte RXF12EIDL = 0xD83 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF12EIDHBITS; 
.................... RXF12EIDHBITS RXF12EIDHbits; 
.................... #byte RXF12EIDHbits = 0xD82 
.................... #byte RXF12EIDH = 0xD82 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } RXF12SIDLBITS; 
.................... RXF12SIDLBITS RXF12SIDLbits; 
.................... #byte RXF12SIDLbits = 0xD81 
.................... #byte RXF12SIDL = 0xD81 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF12SIDHBITS; 
.................... RXF12SIDHBITS RXF12SIDHbits; 
.................... #byte RXF12SIDHbits = 0xD80 
.................... #byte RXF12SIDH = 0xD80 
....................  
.................... #byte RXF11EIDL = 0xD7B 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF11EIDHBITS; 
.................... RXF11EIDHBITS RXF11EIDHbits; 
.................... #byte RXF11EIDHbits = 0xD7A 
.................... #byte RXF11EIDH = 0xD7A 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } RXF11SIDLBITS; 
.................... RXF11SIDLBITS RXF11SIDLbits; 
.................... #byte RXF11SIDLbits = 0xD79 
.................... #byte RXF11SIDL = 0xD79 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF11SIDHBITS; 
.................... RXF11SIDHBITS RXF11SIDHbits; 
.................... #byte RXF11SIDHbits = 0xD78 
.................... #byte RXF11SIDH = 0xD78 
....................  
.................... #byte RXF10EIDL = 0xD77 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF10EIDHBITS; 
.................... RXF10EIDHBITS RXF10EIDHbits; 
.................... #byte RXF10EIDHbits = 0xD76 
.................... #byte RXF10EIDH = 0xD76 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................    }; 
.................... } RXF10SIDLBITS; 
.................... RXF10SIDLBITS RXF10SIDLbits; 
.................... #byte RXF10SIDLbits = 0xD75 
.................... #byte RXF10SIDL = 0xD75 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF10SIDHBITS; 
.................... RXF10SIDHBITS RXF10SIDHbits; 
.................... #byte RXF10SIDHbits = 0xD74 
.................... #byte RXF10SIDH = 0xD74 
....................  
.................... #byte RXF9EIDL = 0xD73 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF9EIDHBITS; 
.................... RXF9EIDHBITS RXF9EIDHbits; 
.................... #byte RXF9EIDHbits = 0xD72 
.................... #byte RXF9EIDH = 0xD72 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } RXF9SIDLBITS; 
.................... RXF9SIDLBITS RXF9SIDLbits; 
.................... #byte RXF9SIDLbits = 0xD71 
.................... #byte RXF9SIDL = 0xD71 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF9SIDHBITS; 
.................... RXF9SIDHBITS RXF9SIDHbits; 
.................... #byte RXF9SIDHbits = 0xD70 
.................... #byte RXF9SIDH = 0xD70 
....................  
.................... #byte RXF8EIDL = 0xD6B 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF8EIDHBITS; 
.................... RXF8EIDHBITS RXF8EIDHbits; 
.................... #byte RXF8EIDHbits = 0xD6A 
.................... #byte RXF8EIDH = 0xD6A 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } RXF8SIDLBITS; 
.................... RXF8SIDLBITS RXF8SIDLbits; 
.................... #byte RXF8SIDLbits = 0xD69 
.................... #byte RXF8SIDL = 0xD69 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF8SIDHBITS; 
.................... RXF8SIDHBITS RXF8SIDHbits; 
.................... #byte RXF8SIDHbits = 0xD68 
.................... #byte RXF8SIDH = 0xD68 
....................  
.................... #byte RXF7EIDL = 0xD67 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF7EIDHBITS; 
.................... RXF7EIDHBITS RXF7EIDHbits; 
.................... #byte RXF7EIDHbits = 0xD66 
.................... #byte RXF7EIDH = 0xD66 
....................  
.................... typedef union  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................    }; 
.................... } RXF7SIDLBITS; 
.................... RXF7SIDLBITS RXF7SIDLbits; 
.................... #byte RXF7SIDLbits = 0xD65 
.................... #byte RXF7SIDL = 0xD65 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF7SIDHBITS; 
.................... RXF7SIDHBITS RXF7SIDHbits; 
.................... #byte RXF7SIDHbits = 0xD64 
.................... #byte RXF7SIDH = 0xD64 
....................  
.................... #byte RXF6EIDL = 0xD63 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int EID8:2; 
....................    unsigned int EID10:6; 
.................... } RXF6EIDHBITS; 
.................... RXF6EIDHBITS RXF6EIDHbits; 
.................... #byte RXF6EIDHbits = 0xD62 
.................... #byte RXF6EIDH = 0xD62 
....................  
.................... typedef struct  
....................  { 
....................    union { 
....................       struct { 
....................          unsigned int :3; 
....................          unsigned int EXIDE:1; 
....................       }; 
....................  
....................       struct { 
....................          unsigned int EID16:2; 
....................          unsigned int :1; 
....................          unsigned int EXIDEN:1; 
....................          unsigned int :1; 
....................          unsigned int SID0:3; 
....................       }; 
....................    }; 
....................       struct { 
....................          unsigned int EID1:2; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int :1; 
....................          unsigned int SID:3; 
....................       }; 
.................... } RXF6SIDLBITS; 
.................... RXF6SIDLBITS RXF6SIDLbits; 
.................... #byte RXF6SIDLbits = 0xD61 
.................... #byte RXF6SIDL = 0xD61 
....................  
.................... typedef struct  
....................  { 
....................    unsigned int SID3:7; 
....................    unsigned int SID10:1; 
.................... } RXF6SIDHBITS; 
.................... RXF6SIDHBITS RXF6SIDHbits; 
.................... #byte RXF6SIDHbits = 0xD60 
.................... #byte RXF6SIDH = 0xD60 
....................  
....................  
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1) 
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(rom char *s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... #FUSES WDT128                	//Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT            	//No brownout reset 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES BBSIZ1K               	//1K words Boot Block size 
.................... #FUSES NOXINST               	//Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(crystal=8MHz) 
*
051A:  MOVLW  03
051C:  MOVWF  FEA
051E:  MOVLW  94
0520:  MOVWF  FE9
0522:  MOVF   FEF,W
0524:  BZ    0540
0526:  MOVLW  02
0528:  MOVWF  01
052A:  CLRF   00
052C:  DECFSZ 00,F
052E:  BRA    052C
0530:  DECFSZ 01,F
0532:  BRA    052A
0534:  MOVLW  97
0536:  MOVWF  00
0538:  DECFSZ 00,F
053A:  BRA    0538
053C:  DECFSZ FEF,F
053E:  BRA    0526
0540:  RETURN 0
....................  
....................  
.................... #if defined(__PCH__) 
....................    #define GetSystemClock()       getenv("CLOCK") 
....................    #define GetInstructionClock()  (GetSystemClock()/4) 
....................    #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... #else 
....................    #define GetSystemClock()       getenv("CLOCK") 
....................    #define GetInstructionClock()  (GetSystemClock()/2) 
....................    #define GetPeripheralClock()   (GetSystemClock()/2) 
.................... #endif 
....................  
.................... #define MIN(a,b)  ((a > b) ? b : a) 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk2.h" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
....................  
.................... #ifndef __CCS_STACKTSK2_H__ 
.................... #define __CCS_STACKTSK2_H__ 
....................  
.................... #if !defined(debug_mpfs2) 
....................  #define debug_mpfs2(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q) 
.................... #else 
....................  #define __DO_DEBUG_MPFS2 
.................... #endif 
....................  
.................... #if defined(__PCH__) && !defined(__18CXX) 
....................  #define __18CXX 
.................... #endif 
....................  
.................... #define SIZEOF_MAC_HEADER 14 
....................  
.................... // override delay.c/delay.h with CCS compatible code 
.................... #define __DELAY_H 
.................... #define Delay10us(x) delay_us((uint16_t)10*(uint16_t)x) 
.................... #define DelayMs(x)   delay_ms(x) 
....................  
.................... #define __WF_DEBUG_STRINGS_H  //don't include this file 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
1B4A:  MOVFF  1B,3A8
1B4E:  MOVFF  1A,3A7
1B52:  MOVFF  19,3A6
1B56:  MOVFF  18,3A5
1B5A:  MOVLW  41
1B5C:  MOVLB  3
1B5E:  MOVWF  xAC
1B60:  MOVLW  C6
1B62:  MOVWF  xAB
1B64:  MOVLW  4E
1B66:  MOVWF  xAA
1B68:  MOVLW  6D
1B6A:  MOVWF  xA9
1B6C:  MOVLB  0
1B6E:  BRA    1AA4
1B70:  MOVLW  39
1B72:  MOVLB  3
1B74:  ADDWF  00,W
1B76:  MOVWF  18
1B78:  MOVLW  30
1B7A:  ADDWFC 01,W
1B7C:  MOVWF  19
1B7E:  MOVLW  00
1B80:  ADDWFC 02,W
1B82:  MOVWF  1A
1B84:  MOVLW  00
1B86:  ADDWFC 03,W
1B88:  MOVWF  1B
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
1B8A:  MOVFF  1A,00
1B8E:  MOVFF  1B,01
1B92:  CLRF   02
1B94:  CLRF   03
1B96:  MOVFF  1B,3A7
1B9A:  MOVFF  1A,3A6
1B9E:  MOVFF  1B,3A9
1BA2:  MOVFF  1A,3A8
1BA6:  MOVLW  7F
1BA8:  MOVWF  xAB
1BAA:  SETF   xAA
1BAC:  MOVLB  0
1BAE:  BRA    1B02
1BB0:  MOVFF  00,01
1BB4:  MOVFF  03,02
1BB8:  RETURN 0
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................  #include "PIC18F4585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1) 
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(rom char *s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
.................... #ifndef __TCPIPCONFIG_H 
.................... #define __TCPIPCONFIG_H 
....................  
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
.................... #include "Compiler.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Compiler and hardware specific definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Compiler.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, PIC24E, dsPIC30F, dsPIC33F,  
....................  *               dsPIC33E, PIC32 
....................  * Compiler:        Microchip C32 v1.00 or higher 
....................  *               Microchip C30 v3.01 or higher 
....................  *               Microchip C18 v3.13 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights  
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and  
....................  * distribute:  
....................  * (i)  the Software when embedded on a Microchip microcontroller or  
....................  *      digital signal controller product ("Device") which is  
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c and  
....................  *      ENC28J60.h ported to a non-Microchip device used in  
....................  *      conjunction with a Microchip ethernet controller for the  
....................  *      sole purpose of interfacing with the ethernet controller.  
....................  * 
....................  * You should refer to the license agreement accompanying this  
....................  * Software for additional information regarding your rights and  
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT  
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT  
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A  
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL  
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR  
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF  
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS  
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER  
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT  
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * 10/03/2006   Original, copied from old Compiler.h 
....................  * 11/07/2007   Reorganized and simplified 
....................  * 03/31/2010   Removed dependency on WORD and DWORD typedefs 
....................  * 04/14/2010   Added defines to uniquely identify each compiler 
....................  ********************************************************************/ 
.................... #ifndef __COMPILER_H 
.................... #define __COMPILER_H 
....................  
.................... // Include proper device header file 
.................... #if defined(__18CXX) && !defined(HI_TECH_C)    
....................    // PIC18 processor with Microchip C18 compiler 
....................     #define COMPILER_MPLAB_C18 
....................     #include <p18cxxx.h> 
.................... #elif defined(__PICC18__) && defined(HI_TECH_C)    
....................    // PIC18 processor with (Microchip) HI-TECH PICC-18 compiler 
....................    #if !defined(__18CXX) 
....................       #define __18CXX 
....................    #endif 
....................     #define COMPILER_HITECH_PICC18 
....................    #include <htc.h> 
.................... #elif (defined(__PIC24F__) || defined(__PIC24FK__)) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Fxxxx.h> 
.................... #elif defined(__PIC24H__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24H processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Hxxxx.h> 
.................... #elif defined(__PIC24E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // PIC24E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p24Exxxx.h> 
.................... #elif defined(__dsPIC33F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Fxxxx.h> 
.................... #elif defined(__dsPIC33E__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC33E processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p33Exxxx.h> 
.................... #elif defined(__dsPIC30F__) && defined(__C30__)   // Microchip C30 compiler 
....................    // dsPIC30F processor 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30fxxxx.h> 
.................... #elif defined(__C30__)      // Microchip C30 compiler, but targeting "generic-16bit" processor. 
....................     #define COMPILER_MPLAB_C30 
....................    #include <p30sim.h> 
....................    // Define some useful inline assembly functions which are normally in the  
....................    // processor header files, but absent from the generic p30sim.h file. 
....................    #if !defined(Nop) 
....................       #define Nop()    __builtin_nop() 
....................       #define ClrWdt() {__asm__ volatile ("clrwdt");} 
....................       #define Sleep()  {__asm__ volatile ("pwrsav #0");} 
....................       #define Idle()   {__asm__ volatile ("pwrsav #1");} 
....................    #endif 
.................... #elif defined(__PIC32MX__)   // Microchip C32 compiler 
....................    #if !defined(__C32__) 
....................       #define __C32__ 
....................    #endif 
....................     #define COMPILER_MPLAB_C32 
....................    #include <p32xxxx.h> 
....................    #include <plib.h> 
.................... #else 
....................    #error Unknown processor or compiler.  See Compiler.h 
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... #include <stdlib.h> 
.................... #include <string.h> 
....................  
....................  
.................... // Base RAM and ROM pointer types for given architecture 
.................... #if defined(__PCH__) || defined(__PCD__) 
....................    #define PTR_BASE      unsigned int16 
....................    #define ROM_PTR_BASE   unsigned int32 
.................... #elif defined(__PIC32MX__) 
....................    #define PTR_BASE      unsigned long 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #elif defined(__C30__) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short 
.................... #elif defined(COMPILER_MPLAB_C18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned short long 
.................... #elif defined(COMPILER_HITECH_PICC18) 
....................    #define PTR_BASE      unsigned short 
....................    #define ROM_PTR_BASE   unsigned long 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all except Microchip MPLAB C Compiler for PIC18 MCUs (C18) 
.................... #if !defined(COMPILER_MPLAB_C18) 
....................    #define memcmppgm2ram(a,b,c)   memcmp(a,b,c) 
....................    #define strcmppgm2ram(a,b)      strcmp(a,b) 
....................   #if defined(__PCD__) 
....................    #warning temporary 4.121 fix 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b|0x8000,c) 
....................   #else 
....................    #define memcpypgm2ram(a,b,c)   memcpy(a,b,c) 
....................   #endif 
....................    #define strcpypgm2ram(a,b)      strcpy(a,b) 
....................    #define strncpypgm2ram(a,b,c)   strncpy(a,b,c) 
....................    #define strstrrampgm(a,b)      strstr(a,b) 
....................    #define   strlenpgm(a)         strlen(a) 
....................    #define strchrpgm(a,b)         strchr(a,b) 
....................    #define strcatpgm2ram(a,b)      strcat(a,b) 
.................... #endif 
....................  
....................  
.................... // Definitions that apply to all 8-bit products 
.................... // (PIC18) 
.................... #if defined(__18CXX) 
....................    #define   __attribute__(a) 
....................  
....................     #define FAR                         far 
....................  
....................    // Microchip C18 specific defines 
....................    #if defined(COMPILER_MPLAB_C18) 
....................        #define ROM                    rom 
....................    #endif 
....................     
....................    // HI TECH PICC-18 specific defines 
....................    #if defined(COMPILER_HITECH_PICC18) 
....................        #define ROM                    const 
....................       #define rom 
....................        #define Nop()                  asm("NOP"); 
....................       #define ClrWdt()            asm("CLRWDT"); 
....................        #define Reset()               asm("RESET"); 
....................    #endif 
....................      
.................... // Definitions that apply to all 16-bit and 32-bit products 
.................... // (PIC24F, PIC24H, dsPIC30F, dsPIC33F, and PIC32) 
.................... #else 
....................    #define   ROM                  const 
....................  
....................    // 16-bit specific defines (PIC24F, PIC24H, dsPIC30F, dsPIC33F) 
....................    #if defined(__C30__) && !defined(__PCD__) 
....................       #define Reset()            asm("reset") 
....................         #define FAR                 __attribute__((far)) 
....................    #endif 
....................  
....................    // 32-bit specific defines (PIC32) 
....................    #if defined(__PIC32MX__) 
....................       #define persistent 
....................       #define far 
....................         #define FAR 
....................       #define Reset()            SoftReset() 
....................       #define ClrWdt()         (WDTCONSET = _WDTCON_WDTCLR_MASK) 
....................  
....................       // MPLAB C Compiler for PIC32 MCUs version 1.04 and below don't have a  
....................       // Nop() function. However, version 1.05 has Nop() declared as _nop(). 
....................       #if !defined(Nop) && (__C32_VERSION__ <= 104) 
....................          #define Nop()            asm("nop") 
....................       #endif 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define STACK_USE_ICMP_SERVER    1 
.................... #define STACK_USE_TCP            1 
.................... #define STACK_USE_DHCP_CLIENT    1 
....................  
.................... #define STACK_CCS_SMTP_TX_SIZE    0 
.................... #define STACK_CCS_SMTP_RX_SIZE    0 
....................  
.................... #define STACK_USE_CCS_HTTP2_SERVER 
.................... #define STACK_CCS_HTTP2_SERVER_TX_SIZE    1500 
.................... #define STACK_CCS_HTTP2_SERVER_RX_SIZE    500 
.................... #define HTTP_NUM_SOCKETS                  1 
.................... #define HTTP_PORT                         (80u) 
.................... #define HTTP_USE_DOUBLE_ESCAPE            1 
.................... #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start) 
....................  
.................... #define STACK_MY_TELNET_SERVER_TX_SIZE    0 
.................... #define STACK_MY_TELNET_SERVER_RX_SIZE    0 
....................  
.................... #define MY_DEFAULT_HOST_NAME      "CCS_EXAMPLES" 
....................  
.................... #define MY_DEFAULT_MAC_BYTE1      (0x0) 
.................... #define MY_DEFAULT_MAC_BYTE2      (0x20) 
.................... #define MY_DEFAULT_MAC_BYTE3      (0x30) 
.................... #define MY_DEFAULT_MAC_BYTE4      (0x40) 
.................... #define MY_DEFAULT_MAC_BYTE5      (0x50) 
.................... #define MY_DEFAULT_MAC_BYTE6      (0x60) 
....................  
.................... #define TCP_CONFIGURATION      1 
....................  
.................... #define TCP_ETH_RAM_SIZE (STACK_CCS_SMTP_TX_SIZE + \ 
....................                           STACK_CCS_SMTP_RX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_TX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_RX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_TX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_RX_SIZE + \ 
....................                           100*TCP_CONFIGURATION) 
....................  
.................... // Define names of socket types 
.................... #define TCP_PURPOSE_GENERIC_TCP_CLIENT 0 
.................... #define TCP_PURPOSE_GENERIC_TCP_SERVER 1 
.................... #define TCP_PURPOSE_TELNET             2 
.................... #define TCP_PURPOSE_FTP_COMMAND        3 
.................... #define TCP_PURPOSE_FTP_DATA           4 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_TX 5 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_RX 6 
.................... #define TCP_PURPOSE_UART_2_TCP_BRIDGE  7 
.................... #define TCP_PURPOSE_HTTP_SERVER        8 
.................... #define TCP_PURPOSE_DEFAULT            9 
.................... #define TCP_PURPOSE_BERKELEY_SERVER    10 
.................... #define TCP_PURPOSE_BERKELEY_CLIENT    11 
.................... #define TCP_PURPOSE_CCS_SMTP           0x40 
....................  
.................... typedef struct 
.................... { 
....................    BYTE vSocketPurpose; 
....................    BYTE vMemoryMedium; 
....................    WORD wTXBufferSize; 
....................    WORD wRXBufferSize; 
.................... } TCPSocketInitializer_t; 
....................  
.................... #if TCP_CONFIGURATION > 0 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................          {TCP_PURPOSE_HTTP_SERVER, TCP_ETH_RAM, STACK_CCS_HTTP2_SERVER_TX_SIZE, STACK_CCS_HTTP2_SERVER_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_SMTP_CLIENT) 
....................          {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, STACK_CCS_SMTP_TX_SIZE, STACK_CCS_SMTP_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_MY_TELNET_SERVER) 
....................          {TCP_PURPOSE_TELNET, TCP_ETH_RAM, STACK_MY_TELNET_SERVER_TX_SIZE, STACK_MY_TELNET_SERVER_RX_SIZE}, 
....................       #endif 
....................    }; 
.................... #else 
....................    #undef TCP_CONFIGURATION 
....................    #define TCP_CONFIGURATION 1 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, 250, 250} 
....................    }; 
.................... #endif 
....................  
.................... #ifndef MAX_HTTP_CONNECTIONS 
....................    #define  MAX_HTTP_CONNECTIONS 1 
.................... #endif 
.................... #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS 7 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definitions 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST,  
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS,  
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook/CCS      WIFI networkType added to AppConfig, hopefully 
....................  *                         this doesn't conflict with EZ_CONFIG_STORE.  
....................  *                      WIFI adhocBehavior added to AppConfig. 
....................  ********************************************************************/ 
.................... #ifndef __STACK_TSK_H 
.................... #define __STACK_TSK_H 
....................  
.................... #if defined (WF_CS_TRIS) 
....................     #include "WF_Config.h"      
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 ) 
.................... #error Invalid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
.................... // Check for potential configuration errors in "TCPIPConfig.h" 
.................... #if (MAX_HTTP_CONNECTIONS <= 0 || MAX_HTTP_CONNECTIONS > 255 ) 
.................... #error Invalid MAX_HTTP_CONNECTIONS value specified. 
.................... #endif 
....................  
.................... // Structure to contain a MAC address 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... // Definition to represent an IP address 
.................... #define IP_ADDR      DWORD_VAL 
....................  
.................... // Address structure for a node 
.................... typedef struct __attribute__((__packed__)) 
.................... { 
....................     IP_ADDR     IPAddr; 
....................     MAC_ADDR    MACAddr; 
.................... } NODE_INFO; 
....................  
.................... // Application-dependent structure used to contain address information 
.................... typedef struct __attribute__((__packed__)) appConfigStruct  
.................... { 
....................    IP_ADDR      MyIPAddr;               // IP address 
....................    IP_ADDR      MyMask;                 // Subnet mask 
....................    IP_ADDR      MyGateway;              // Default Gateway 
....................    IP_ADDR      PrimaryDNSServer;       // Primary DNS Server 
....................    IP_ADDR      SecondaryDNSServer;     // Secondary DNS Server 
....................    IP_ADDR      DefaultIPAddr;          // Default IP address 
....................    IP_ADDR      DefaultMask;            // Default subnet mask 
....................    BYTE      NetBIOSName[16];        // NetBIOS name 
....................    struct 
....................    { 
....................       unsigned char : 6; 
....................       unsigned char bIsDHCPEnabled : 1; 
....................       unsigned char bInConfigMode : 1; 
....................    } Flags;                            // Flag structure 
....................    MAC_ADDR   MyMACAddr;              // Application MAC address 
....................  
.................... #if defined(WF_CS_TRIS) 
....................    BYTE      MySSID[32];             // Wireless SSID (if using MRF24W) 
....................    BYTE        SsidLength;             // number of bytes in SSID 
....................    BYTE        SecurityMode;           // WF_SECURITY_OPEN or one of the other security modes 
....................    BYTE        SecurityKey[64];        // WiFi Security key, or passphrase.    
....................    BYTE        SecurityKeyLength;      // number of bytes in security key (can be 0) 
....................    BYTE        WepKeyIndex;            // WEP key index (only valid for WEP) 
....................    BYTE        networkType; 
....................    BYTE        adhocBehavior; 
....................     #if defined(EZ_CONFIG_STORE) // WLAN configuration data stored to NVM 
....................     BYTE        dataValid; 
....................     //BYTE        networkType; 
....................     BYTE        saveSecurityInfo;       // Save 32-byte PSK 
....................     #endif 
.................... #endif 
....................     
.................... #if defined(STACK_USE_SNMP_SERVER) || defined(STACK_USE_SNMPV3_SERVER) 
....................    // SNMPv2C Read community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE readCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1];  
....................  
....................    // SNMPv2C Write community names 
....................    // SNMP_COMMUNITY_MAX_LEN (8) + 1 null termination byte 
....................    BYTE writeCommunity[SNMP_MAX_COMMUNITY_SUPPORT][SNMP_COMMUNITY_MAX_LEN+1]; 
....................  
....................    UINT32 SnmpEngineBootRcrd; 
.................... #endif 
....................  
.................... } APP_CONFIG; 
....................  
.................... #ifndef THIS_IS_STACK_APPLICATION 
....................     extern APP_CONFIG AppConfig; 
.................... #endif 
....................  
....................  
.................... void StackInit(void); 
.................... void StackTask(void); 
.................... void StackApplications(void); 
.................... #endif 
....................  
.................... #include "TCPIP Stack/Helpers.h" 
.................... /********************************************************************* 
....................  Header file for Helpers.c 
....................   
....................  FileName:      Helpers.h 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
.................... 		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
.................... 		used in conjunction with a Microchip ethernet controller for 
.................... 		the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release 
....................   5.36        Updated compile time check for ultoa(); 
....................  ********************************************************************/ 
.................... #ifndef __HELPERS_H 
.................... #define __HELPERS_H 
....................  
....................  
.................... #if !defined(__18CXX) || defined(HI_TECH_C) 
.................... 	char *strupr(char* s); 
.................... #endif 
....................  
.................... // Implement consistent ultoa() function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
.................... 	// C32 < 1.12 and C30 < v3.25 need this 2 parameter stack implemented function 
.................... 	void ultoa(DWORD Value, BYTE* Buffer); 
.................... #elif defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	// C18 already has a 2 parameter ultoa() function 
.................... 	#include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... #include <string.h> 
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #else 
.................... 	// HI-TECH PICC-18 PRO 9.63, C30 v3.25+, and C32 v1.12+ already have a ultoa() stdlib  
.................... 	// library function, but it requires 3 parameters.  The TCP/IP Stack  
.................... 	// assumes the C18 style 2 parameter ultoa() function, so we shall  
.................... 	// create a macro to automatically convert the code. 
.................... 	#include <stdlib.h> 
.................... 	#define ultoa(val,buf)	ultoa((char*)(buf),(val),10) 
.................... #endif 
....................  
.................... #if defined(DEBUG) 
.................... 	#define DebugPrint(a)	{putrsUART(a);} 
.................... #else 
.................... 	#define DebugPrint(a) 
.................... #endif 
....................  
.................... DWORD	LFSRSeedRand(DWORD dwSeed); 
.................... WORD	LFSRRand(void); 
.................... DWORD	GenerateRandomDWORD(void); 
.................... void 	uitoa(WORD Value, BYTE* Buffer); 
.................... void 	UnencodeURL(BYTE* URL); 
.................... WORD 	Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... WORD	Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen); 
.................... BOOL	StringToIPAddress(BYTE* str, IP_ADDR* IPAddress); 
.................... BYTE 	ReadStringUART(BYTE* Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
.................... signed char stricmppgm2ram(BYTE* a, ROM BYTE* b); 
.................... char * 	strnchr(const char *searchString, size_t count, char c); 
.................... size_t  strncpy_m(char* destStr, size_t destSize, int nStrings, ...); 
....................  
.................... #if defined(__18CXX) 
.................... 	BOOL	ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress); 
.................... #else 
.................... 	// Non-ROM variant for C30 and C32 
.................... 	#define ROMStringToIPAddress(a,b)	StringToIPAddress((BYTE*)a,b) 
.................... #endif 
....................  
....................  
.................... WORD    swaps(WORD v); 
....................  
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v); 
.................... #else 
.................... DWORD   swapl(DWORD v); 
.................... #endif 
....................  
.................... WORD    CalcIPChecksum(BYTE* buffer, WORD len); 
....................  
....................  
.................... #if defined(__18CXX) 
.................... 	DWORD leftRotateDWORD(DWORD val, BYTE bits); 
.................... #else 
.................... 	// Rotations are more efficient in C30 and C32 
.................... 	#define leftRotateDWORD(x, n) (((x) << (n)) | ((x) >> (32-(n)))) 
.................... #endif 
....................  
.................... void FormatNetBIOSName(BYTE Name[16]); 
....................  
....................  
.................... // Protocols understood by the ExtractURLFields() function.  IMPORTANT: If you  
.................... // need to reorder these (change their constant values), you must also reorder  
.................... // the constant arrays in ExtractURLFields(). 
.................... typedef enum 
.................... { 
.................... 	PROTOCOL_HTTP = 0u, 
.................... 	PROTOCOL_HTTPS, 
.................... 	PROTOCOL_MMS, 
.................... 	PROTOCOL_RTSP 
.................... } PROTOCOLS; 
....................  
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen); 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive); 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/Delay.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  General Delay rouines 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Delay.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/9/02  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     6/10/02 Fixed C18 ms and us routines 
....................  * Howard Schlunder		4/04/06	Changed for C30 
....................  ********************************************************************/ 
.................... #ifndef __DELAY_H 
.................... #define __DELAY_H 
....................  
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#include <delays.h> 
.................... #endif 
....................  
.................... #if !defined(GetInstructionClock) 
.................... 	#error GetInstructionClock() must be defined. 
.................... #endif 
....................  
.................... #if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 	#define Delay10us(us)		Delay10TCYx(((GetInstructionClock()/1000000)*(us))) 
.................... 	#define DelayMs(ms)												\ 
.................... 	do																\ 
.................... 	{																\ 
.................... 		unsigned int _iTemp = (ms); 								\ 
.................... 		while(_iTemp--)												\ 
.................... 			Delay1KTCYx((GetInstructionClock()+999999)/1000000);	\ 
.................... 	} while(0) 
....................  
.................... #elif defined(__C30__) || defined(__C32__) 
.................... 	void Delay10us(DWORD dwCount); 
.................... 	void DelayMs(WORD ms); 
....................  
.................... #else 
.................... 	#define Delay10us(x)			\ 
.................... 	do 								\ 
.................... 	{								\ 
.................... 		unsigned long _dcnt;		\ 
.................... 		_dcnt=x*((unsigned long)(0.00001/(1.0/GetInstructionClock())/6));	\ 
.................... 		while(_dcnt--);				\ 
.................... 	} while(0) 
.................... 	void DelayMs(WORD ms); 
.................... #endif 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/Tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __TICK_H 
.................... #define __TICK_H 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // All TICKS are stored as 32-bit unsigned integers. 
.................... // This is deprecated since it conflicts with other TICK definitions used in  
.................... // other Microchip software libraries and therefore poses a merge and maintence  
.................... // problem.  Instead of using the TICK data type, just use the base DWORD data  
.................... // type instead. 
.................... typedef __attribute__((__deprecated__)) DWORD TICK; 
....................  
.................... // This value is used by TCP and other modules to implement timeout actions. 
.................... // For this definition, the Timer must be initialized to use a 1:256 prescalar  
.................... // in Tick.c.  If using a 32kHz watch crystal as the time base, modify the  
.................... // Tick.c file to use no prescalar. 
.................... #define TICKS_PER_SECOND		((GetPeripheralClock()+128ull)/256ull)	// Internal core clock drives timer with 1:256 prescaler 
.................... //#define TICKS_PER_SECOND		(32768ul)								// 32kHz crystal drives timer with no scalar 
....................  
.................... // Represents one second in Ticks 
.................... #define TICK_SECOND				((QWORD)TICKS_PER_SECOND) 
.................... // Represents one minute in Ticks 
.................... #define TICK_MINUTE				((QWORD)TICKS_PER_SECOND*60ull) 
.................... // Represents one hour in Ticks 
.................... #define TICK_HOUR				((QWORD)TICKS_PER_SECOND*3600ull) 
....................  
....................  
.................... void TickInit(void); 
.................... DWORD TickGet(void); 
.................... DWORD TickGetDiv256(void); 
.................... DWORD TickGetDiv64K(void); 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue); 
.................... void TickUpdate(void); 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  ********************************************************************/ 
.................... #ifndef __MAC_H 
.................... #define __MAC_H 
....................  
.................... #include "HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(WF_CS_TRIS) 
....................    // Do not use the DMA and other goodies that Microchip Ethernet modules have 
....................    #define NON_MCHP_MAC 
.................... #endif 
....................  
.................... #if defined(ENC_CS_TRIS) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the MRF24WB10 but not both ENC_CS_TRIS and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(WF_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENCX24J600 or the MRF24WB10 but not both ENC100_INTERFACE_MODE and WF_CS_TRIS." 
.................... #endif 
.................... #if defined(ENC100_INTERFACE_MODE) && defined(ENC_CS_TRIS) 
....................    #error "Error in HardwareProfile.h.  Must select either the ENC28J60 or the ENCX24J600 but not both ENC_CS_TRIS and ENC100_INTERFACE_MODE." 
.................... #endif 
....................  
....................  
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "TCPIP Stack/ETH97J60.h" 
.................... #elif defined(ENC_CS_TRIS) || defined(WF_CS_TRIS) 
....................    #include "TCPIP Stack/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  ********************************************************************/ 
....................  
.................... #ifndef __ENC28J60_H 
.................... #define __ENC28J60_H 
.................... #include "GenericTypeDefs.h" 
.................... /******************************************************************* 
....................  
....................                   Generic Type Definitions 
....................  
.................... ******************************************************************** 
....................  FileName:        GenericTypeDefs.h 
....................  Dependencies:    None 
....................  Processor:       PIC10, PIC12, PIC16, PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:        MPLAB C Compilers for PIC18, PIC24, dsPIC, & PIC32 
....................                   Hi-Tech PICC PRO, Hi-Tech PICC18 PRO 
....................  Company:         Microchip Technology Inc. 
....................  
....................  Software License Agreement 
....................  
....................  The software supplied herewith by Microchip Technology Incorporated 
....................  (the "Company") is intended and supplied to you, the Company's 
....................  customer, for use solely and exclusively with products manufactured 
....................  by the Company. 
....................  
....................  The software is owned by the Company and/or its supplier, and is 
....................  protected under applicable copyright laws. All rights are reserved. 
....................  Any use in violation of the foregoing restrictions may subject the 
....................  user to criminal sanctions under applicable laws, as well as to 
....................  civil liability for the breach of the terms and conditions of this 
....................  license. 
....................  
....................  THIS SOFTWARE IS PROVIDED IN AN "AS IS" CONDITION. NO WARRANTIES, 
....................  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  
.................... ******************************************************************** 
....................  File Description: 
....................  
....................  Change History: 
....................   Rev   Date         Description 
....................   1.1   09/11/06     Add base signed types 
....................   1.2   02/28/07     Add QWORD, LONGLONG, QWORD_VAL 
....................   1.3   02/06/08     Add def's for PIC32 
....................   1.4   08/08/08     Remove LSB/MSB Macros, adopted by Peripheral lib 
....................   1.5   08/14/08     Simplify file header 
....................   2.0   07/13/09     Updated for new release of coding standards 
.................... *******************************************************************/ 
....................  
.................... #ifndef __GENERIC_TYPE_DEFS_H_ 
.................... #define __GENERIC_TYPE_DEFS_H_ 
....................  
.................... /* Specify an extension for GCC based compilers */ 
.................... #if defined(__GNUC__) 
.................... #define __EXTENSION __extension__ 
.................... #else 
.................... #define __EXTENSION 
.................... #endif 
....................  
.................... #if !defined(__PACKED) 
....................     #define __PACKED 
.................... #endif 
....................  
.................... /* get compiler defined type definitions (NULL, size_t, etc) */ 
.................... #include <stddef.h>  
....................  
.................... typedef enum _BOOL { FALSE = 0, TRUE } BOOL;    /* Undefined size */ 
.................... typedef enum _BIT { CLEAR = 0, SET } BIT; 
....................  
.................... #define PUBLIC                                  /* Function attributes */ 
.................... #define PROTECTED 
.................... #define PRIVATE   static 
....................  
.................... /* INT is processor specific in length may vary in size */ 
.................... typedef signed int          INT; 
.................... typedef signed char         INT8; 
.................... typedef signed short int    INT16; 
.................... typedef signed long int     INT32; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef signed long long    INT64; 
.................... #endif 
....................  
.................... /* UINT is processor specific in length may vary in size */ 
.................... typedef unsigned int        UINT; 
.................... typedef unsigned char       UINT8; 
.................... typedef unsigned short int  UINT16; 
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef unsigned short long UINT24; 
.................... #endif 
.................... typedef unsigned long int   UINT32;     /* other name for 32-bit integer */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... __EXTENSION typedef unsigned long long  UINT64; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT8 Val; 
....................     struct 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................     } bits; 
.................... } UINT8_VAL, UINT8_BITS; 
....................  
.................... typedef union  
.................... { 
....................     UINT16 Val; 
....................     UINT8 v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................     } bits; 
.................... } UINT16_VAL, UINT16_BITS; 
....................  
.................... /* 24-bit type only available on C18 */ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... typedef union 
.................... { 
....................     UINT24 Val; 
....................     UINT8 v[3] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................     } bits; 
.................... } UINT24_VAL, UINT24_BITS; 
.................... #endif 
....................  
.................... typedef union 
.................... { 
....................     UINT32 Val; 
....................     UINT16 w[2] __PACKED; 
....................     UINT8  v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         UINT8 LB; 
....................         UINT8 HB; 
....................         UINT8 UB; 
....................         UINT8 MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         UINT16_VAL low; 
....................         UINT16_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................     } bits; 
.................... } UINT32_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... #if !defined(__18CXX) 
.................... typedef union 
.................... { 
....................     UINT64 Val; 
....................     UINT32 d[2] __PACKED; 
....................     UINT16 w[4] __PACKED; 
....................     UINT8 v[8]  __PACKED; 
....................     struct __PACKED 
....................     { 
....................         UINT32 LD; 
....................         UINT32 HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         UINT16 LW; 
....................         UINT16 HW; 
....................         UINT16 UW; 
....................         UINT16 MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION UINT8 b0:1; 
....................         __EXTENSION UINT8 b1:1; 
....................         __EXTENSION UINT8 b2:1; 
....................         __EXTENSION UINT8 b3:1; 
....................         __EXTENSION UINT8 b4:1; 
....................         __EXTENSION UINT8 b5:1; 
....................         __EXTENSION UINT8 b6:1; 
....................         __EXTENSION UINT8 b7:1; 
....................         __EXTENSION UINT8 b8:1; 
....................         __EXTENSION UINT8 b9:1; 
....................         __EXTENSION UINT8 b10:1; 
....................         __EXTENSION UINT8 b11:1; 
....................         __EXTENSION UINT8 b12:1; 
....................         __EXTENSION UINT8 b13:1; 
....................         __EXTENSION UINT8 b14:1; 
....................         __EXTENSION UINT8 b15:1; 
....................         __EXTENSION UINT8 b16:1; 
....................         __EXTENSION UINT8 b17:1; 
....................         __EXTENSION UINT8 b18:1; 
....................         __EXTENSION UINT8 b19:1; 
....................         __EXTENSION UINT8 b20:1; 
....................         __EXTENSION UINT8 b21:1; 
....................         __EXTENSION UINT8 b22:1; 
....................         __EXTENSION UINT8 b23:1; 
....................         __EXTENSION UINT8 b24:1; 
....................         __EXTENSION UINT8 b25:1; 
....................         __EXTENSION UINT8 b26:1; 
....................         __EXTENSION UINT8 b27:1; 
....................         __EXTENSION UINT8 b28:1; 
....................         __EXTENSION UINT8 b29:1; 
....................         __EXTENSION UINT8 b30:1; 
....................         __EXTENSION UINT8 b31:1; 
....................         __EXTENSION UINT8 b32:1; 
....................         __EXTENSION UINT8 b33:1; 
....................         __EXTENSION UINT8 b34:1; 
....................         __EXTENSION UINT8 b35:1; 
....................         __EXTENSION UINT8 b36:1; 
....................         __EXTENSION UINT8 b37:1; 
....................         __EXTENSION UINT8 b38:1; 
....................         __EXTENSION UINT8 b39:1; 
....................         __EXTENSION UINT8 b40:1; 
....................         __EXTENSION UINT8 b41:1; 
....................         __EXTENSION UINT8 b42:1; 
....................         __EXTENSION UINT8 b43:1; 
....................         __EXTENSION UINT8 b44:1; 
....................         __EXTENSION UINT8 b45:1; 
....................         __EXTENSION UINT8 b46:1; 
....................         __EXTENSION UINT8 b47:1; 
....................         __EXTENSION UINT8 b48:1; 
....................         __EXTENSION UINT8 b49:1; 
....................         __EXTENSION UINT8 b50:1; 
....................         __EXTENSION UINT8 b51:1; 
....................         __EXTENSION UINT8 b52:1; 
....................         __EXTENSION UINT8 b53:1; 
....................         __EXTENSION UINT8 b54:1; 
....................         __EXTENSION UINT8 b55:1; 
....................         __EXTENSION UINT8 b56:1; 
....................         __EXTENSION UINT8 b57:1; 
....................         __EXTENSION UINT8 b58:1; 
....................         __EXTENSION UINT8 b59:1; 
....................         __EXTENSION UINT8 b60:1; 
....................         __EXTENSION UINT8 b61:1; 
....................         __EXTENSION UINT8 b62:1; 
....................         __EXTENSION UINT8 b63:1; 
....................     } bits; 
.................... } UINT64_VAL; 
.................... #endif /* __18CXX */ 
....................  
.................... /***********************************************************************************/ 
....................  
.................... /* Alternate definitions */ 
.................... typedef void                    VOID; 
....................  
.................... typedef char                    CHAR8; 
.................... typedef unsigned char           UCHAR8; 
....................  
.................... #ifdef BYTE 
.................... #undef BYTE 
.................... #endif 
.................... typedef unsigned char           BYTE;                           /* 8-bit unsigned  */ 
.................... typedef unsigned short int      WORD;                           /* 16-bit unsigned */ 
.................... typedef unsigned long           DWORD;                          /* 32-bit unsigned */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef unsigned long long      QWORD;                          /* 64-bit unsigned */ 
.................... typedef signed char             CHAR;                           /* 8-bit signed    */ 
.................... typedef signed short int        SHORT;                          /* 16-bit signed   */ 
.................... typedef signed long             LONG;                           /* 32-bit signed   */ 
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... __EXTENSION 
.................... typedef signed long long        LONGLONG;                       /* 64-bit signed   */ 
.................... typedef union 
.................... { 
....................     BYTE Val; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................     } bits; 
.................... } BYTE_VAL, BYTE_BITS; 
....................  
.................... typedef union 
.................... { 
....................     WORD Val; 
....................     BYTE v[2] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................     } bits; 
.................... } WORD_VAL, WORD_BITS; 
....................  
.................... typedef union 
.................... { 
....................     DWORD Val; 
....................     WORD w[2] __PACKED; 
....................     BYTE v[4] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct __PACKED 
....................     { 
....................         WORD_VAL low; 
....................         WORD_VAL high; 
....................     }wordUnion; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
.................... /* MPLAB C Compiler for PIC18 does not support 64-bit integers */ 
.................... typedef union 
.................... { 
....................     QWORD Val; 
....................     DWORD d[2] __PACKED; 
....................     WORD w[4] __PACKED; 
....................     BYTE v[8] __PACKED; 
....................     struct __PACKED 
....................     { 
....................         DWORD LD; 
....................         DWORD HD; 
....................     } dword; 
....................     struct __PACKED 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................         WORD UW; 
....................         WORD MW; 
....................     } word; 
....................     struct __PACKED 
....................     { 
....................         __EXTENSION BYTE b0:1; 
....................         __EXTENSION BYTE b1:1; 
....................         __EXTENSION BYTE b2:1; 
....................         __EXTENSION BYTE b3:1; 
....................         __EXTENSION BYTE b4:1; 
....................         __EXTENSION BYTE b5:1; 
....................         __EXTENSION BYTE b6:1; 
....................         __EXTENSION BYTE b7:1; 
....................         __EXTENSION BYTE b8:1; 
....................         __EXTENSION BYTE b9:1; 
....................         __EXTENSION BYTE b10:1; 
....................         __EXTENSION BYTE b11:1; 
....................         __EXTENSION BYTE b12:1; 
....................         __EXTENSION BYTE b13:1; 
....................         __EXTENSION BYTE b14:1; 
....................         __EXTENSION BYTE b15:1; 
....................         __EXTENSION BYTE b16:1; 
....................         __EXTENSION BYTE b17:1; 
....................         __EXTENSION BYTE b18:1; 
....................         __EXTENSION BYTE b19:1; 
....................         __EXTENSION BYTE b20:1; 
....................         __EXTENSION BYTE b21:1; 
....................         __EXTENSION BYTE b22:1; 
....................         __EXTENSION BYTE b23:1; 
....................         __EXTENSION BYTE b24:1; 
....................         __EXTENSION BYTE b25:1; 
....................         __EXTENSION BYTE b26:1; 
....................         __EXTENSION BYTE b27:1; 
....................         __EXTENSION BYTE b28:1; 
....................         __EXTENSION BYTE b29:1; 
....................         __EXTENSION BYTE b30:1; 
....................         __EXTENSION BYTE b31:1; 
....................         __EXTENSION BYTE b32:1; 
....................         __EXTENSION BYTE b33:1; 
....................         __EXTENSION BYTE b34:1; 
....................         __EXTENSION BYTE b35:1; 
....................         __EXTENSION BYTE b36:1; 
....................         __EXTENSION BYTE b37:1; 
....................         __EXTENSION BYTE b38:1; 
....................         __EXTENSION BYTE b39:1; 
....................         __EXTENSION BYTE b40:1; 
....................         __EXTENSION BYTE b41:1; 
....................         __EXTENSION BYTE b42:1; 
....................         __EXTENSION BYTE b43:1; 
....................         __EXTENSION BYTE b44:1; 
....................         __EXTENSION BYTE b45:1; 
....................         __EXTENSION BYTE b46:1; 
....................         __EXTENSION BYTE b47:1; 
....................         __EXTENSION BYTE b48:1; 
....................         __EXTENSION BYTE b49:1; 
....................         __EXTENSION BYTE b50:1; 
....................         __EXTENSION BYTE b51:1; 
....................         __EXTENSION BYTE b52:1; 
....................         __EXTENSION BYTE b53:1; 
....................         __EXTENSION BYTE b54:1; 
....................         __EXTENSION BYTE b55:1; 
....................         __EXTENSION BYTE b56:1; 
....................         __EXTENSION BYTE b57:1; 
....................         __EXTENSION BYTE b58:1; 
....................         __EXTENSION BYTE b59:1; 
....................         __EXTENSION BYTE b60:1; 
....................         __EXTENSION BYTE b61:1; 
....................         __EXTENSION BYTE b62:1; 
....................         __EXTENSION BYTE b63:1; 
....................     } bits; 
.................... } QWORD_VAL; 
....................  
.................... #undef __EXTENSION 
....................  
.................... #endif /* __GENERIC_TYPE_DEFS_H_ */ 
....................  
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		WORD	 		ByteCount; 
.................... 		unsigned char	CollisionCount:4; 
.................... 		unsigned char	CRCError:1; 
.................... 		unsigned char	LengthCheckError:1; 
.................... 		unsigned char	LengthOutOfRange:1; 
.................... 		unsigned char	Done:1; 
.................... 		unsigned char	Multicast:1; 
.................... 		unsigned char	Broadcast:1; 
.................... 		unsigned char	PacketDefer:1; 
.................... 		unsigned char	ExcessiveDefer:1; 
.................... 		unsigned char	MaximumCollisions:1; 
.................... 		unsigned char	LateCollision:1; 
.................... 		unsigned char	Giant:1; 
.................... 		unsigned char	Underrun:1; 
.................... 		WORD 	 		BytesTransmittedOnWire; 
.................... 		unsigned char	ControlFrame:1; 
.................... 		unsigned char	PAUSEControlFrame:1; 
.................... 		unsigned char	BackpressureApplied:1; 
.................... 		unsigned char	VLANTaggedFrame:1; 
.................... 		unsigned char	Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	BYTE v[4]; 
.................... 	struct { 
.................... 		WORD	 		ByteCount; 
.................... 		unsigned char	PreviouslyIgnored:1; 
.................... 		unsigned char	RXDCPreviouslySeen:1; 
.................... 		unsigned char	CarrierPreviouslySeen:1; 
.................... 		unsigned char	CodeViolation:1; 
.................... 		unsigned char	CRCError:1; 
.................... 		unsigned char	LengthCheckError:1; 
.................... 		unsigned char	LengthOutOfRange:1; 
.................... 		unsigned char	ReceiveOk:1; 
.................... 		unsigned char	Multicast:1; 
.................... 		unsigned char	Broadcast:1; 
.................... 		unsigned char	DribbleNibble:1; 
.................... 		unsigned char	ControlFrame:1; 
.................... 		unsigned char	PauseControlFrame:1; 
.................... 		unsigned char	UnsupportedOpcode:1; 
.................... 		unsigned char	VLANType:1; 
.................... 		unsigned char	Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG  
.................... { 
.................... 	BYTE Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char :1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char BUFER:1; 
.................... 		unsigned char INT:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char :3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
.................... 		 
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
.................... 		 
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
.................... 		 
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
.................... 		 
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDREN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDREN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
.................... 		 
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char :1; 
.................... 	} MACON4bits; 
.................... 		 
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char :6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
.................... 		 
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char :5; 
.................... 	} MISTATbits; 
.................... 		 
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char :5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char :5; 
.................... 	} ECOCONbits2; 
.................... 		 
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char :5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char :5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	WORD Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned PDPXMD:1; 
.................... 		unsigned :2; 
.................... 		unsigned PPWRSV:1; 
.................... 		unsigned :2; 
.................... 		unsigned PLOOPBK:1; 
.................... 		unsigned PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned JBSTAT:1; 
.................... 		unsigned LLSTAT:1; 
.................... 		unsigned :5; 
.................... 		unsigned :3; 
.................... 		unsigned PHDPX:1; 
.................... 		unsigned PFDPX:1; 
.................... 		unsigned :3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		unsigned PREV0:1; 
.................... 		unsigned PREV1:1; 
.................... 		unsigned PREV2:1; 
.................... 		unsigned PREV3:1; 
.................... 		unsigned PPN0:1; 
.................... 		unsigned PPN1:1; 
.................... 		unsigned PPN2:1; 
.................... 		unsigned PPN3:1; 
.................... 		unsigned PPN4:1; 
.................... 		unsigned PPN5:1; 
.................... 		unsigned PID19:1; 
.................... 		unsigned PID20:1; 
.................... 		unsigned PID21:1; 
.................... 		unsigned PID22:1; 
.................... 		unsigned PID23:1; 
.................... 		unsigned PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		unsigned PREV:4; 
.................... 		unsigned PPNL:4; 
.................... 		unsigned PPNH:2; 
.................... 		unsigned PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		unsigned :8; 
.................... 		unsigned HDLDIS:1; 
.................... 		unsigned :1; 
.................... 		unsigned JABBER:1; 
.................... 		unsigned :2; 
.................... 		unsigned TXDIS:1; 
.................... 		unsigned FRCLNK:1; 
.................... 		unsigned :1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		unsigned :5; 
.................... 		unsigned PLRITY:1; 
.................... 		unsigned :2; 
.................... 		unsigned :1; 
.................... 		unsigned DPXSTAT:1; 
.................... 		unsigned LSTAT:1; 
.................... 		unsigned COLSTAT:1; 
.................... 		unsigned RXSTAT:1; 
.................... 		unsigned TXSTAT:1; 
.................... 		unsigned :2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned PGEIE:1; 
.................... 		unsigned :2; 
.................... 		unsigned PLNKIE:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		unsigned :2; 
.................... 		unsigned PGIF:1; 
.................... 		unsigned :1; 
.................... 		unsigned PLNKIF:1; 
.................... 		unsigned :3; 
.................... 		unsigned :8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ0:1; 
.................... 		unsigned LFRQ1:1; 
.................... 		unsigned LBCFG0:1; 
.................... 		unsigned LBCFG1:1; 
.................... 		unsigned LBCFG2:1; 
.................... 		unsigned LBCFG3:1; 
.................... 		unsigned LACFG0:1; 
.................... 		unsigned LACFG1:1; 
.................... 		unsigned LACFG2:1; 
.................... 		unsigned LACFG3:1; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		unsigned :1; 
.................... 		unsigned STRCH:1; 
.................... 		unsigned LFRQ:2; 
.................... 		unsigned LBCFG:4; 
.................... 		unsigned LACFG:4; 
.................... 		unsigned :4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
.................... 	 
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFER		(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
.................... 	 
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
.................... 	 
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
.................... 	 
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
.................... 	 
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
.................... 	 
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDREN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
.................... 	 
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
.................... 	 
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
.................... 	 
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
.................... 	 
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "TCPIP Stack/ENCX24J600.h" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or WiFi MRF24WB10 must be present. 
.................... #endif 
....................  
....................  
.................... #define MAC_TX_BUFFER_SIZE         (1500ul) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct   
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................    MAC_ADDR        DestMACAddr; 
....................    MAC_ADDR        SourceMACAddr; 
....................    WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
....................  
.................... #define MAC_IP         (0x00u) 
.................... #define MAC_ARP        (0x06u) 
.................... #define MAC_UNKNOWN    (0xFFu) 
....................  
....................  
.................... #if !defined(STACK_USE_HTTP2_SERVER) 
....................    #define RESERVED_HTTP_MEMORY 0ul 
.................... #endif 
....................  
.................... #if !defined(STACK_USE_SSL) 
....................    #define RESERVED_SSL_MEMORY 0ul 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #define MAX_PACKET_SIZE     (1514ul) 
.................... #endif 
....................  
.................... // MAC RAM definitions 
.................... #if defined(ENC100_INTERFACE_MODE) 
....................    #define RESERVED_CRYPTO_MEMORY   (128ul) 
....................    #define RAMSIZE         (24*1024ul) 
....................    #define TXSTART       (0x0000ul) 
....................    #define RXSTART       ((TXSTART + 1518ul + TCP_ETH_RAM_SIZE + RESERVED_HTTP_MEMORY + RESERVED_SSL_MEMORY + RESERVED_CRYPTO_MEMORY + 1ul) & 0xFFFE) 
....................    #define   RXSTOP         (RAMSIZE-1ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + 1518ul) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_CRYPTOB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(WF_CS_TRIS) 
....................    #define RAMSIZE       (14170ul - 8192ul - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define TXSTART       (RAMSIZE - (4ul + MAX_PACKET_SIZE + 4ul)) 
....................    #define RXSTART       (0ul) 
....................    #define RXSTOP         ((TXSTART-2ul) | 0x0001ul) 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 4ul) 
....................    #define BASE_SCRATCH_ADDR (BASE_TX_ADDR + (MAX_PACKET_SIZE + 4ul)) 
....................    #define BASE_HTTPB_ADDR  (BASE_SCRATCH_ADDR) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
....................    #define BASE_TCB_ADDR   (BASE_SSLB_ADDR + RESERVED_SSL_MEMORY) 
.................... #elif defined(__PIC32MX__) && defined(_ETH) && !defined(ENC_CS_TRIS) 
....................    #define BASE_TX_ADDR   (MACGetTxBaseAddr()) 
....................    #define BASE_HTTPB_ADDR   (MACGetHttpBaseAddr()) 
....................    #define BASE_SSLB_ADDR   (MACGetSslBaseAddr()) 
....................    #define RXSIZE         (EMAC_RX_BUFF_SIZE) 
....................    #define RAMSIZE         (2*RXSIZE)   // not used but silences the compiler 
.................... #else   // ENC28J60 or PIC18F97J60 family internal Ethernet controller 
....................    #define RAMSIZE         (8*1024ul) 
....................    #define TXSTART       (RAMSIZE - (1ul+1518ul+7ul) - TCP_ETH_RAM_SIZE - RESERVED_HTTP_MEMORY - RESERVED_SSL_MEMORY) 
....................    #define RXSTART         (0ul)                  // Should be an even memory address; must be 0 for errata 
....................    #define   RXSTOP         ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
....................    #define RXSIZE         (RXSTOP-RXSTART+1ul) 
....................    #define BASE_TX_ADDR   (TXSTART + 1ul) 
....................    #define BASE_TCB_ADDR   (BASE_TX_ADDR + (1514ul+7ul)) 
....................    #define BASE_HTTPB_ADDR (BASE_TCB_ADDR + TCP_ETH_RAM_SIZE) 
....................    #define BASE_SSLB_ADDR   (BASE_HTTPB_ADDR + RESERVED_HTTP_MEMORY) 
.................... #endif 
....................  
.................... #if (RXSIZE < 1400) || (RXSIZE > RAMSIZE) 
....................    #error Warning, Ethernet RX buffer is tiny.  Reduce TCP socket count, the size of each TCP socket, or move sockets to a different RAM 
.................... #endif 
....................  
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void   MACEDPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... #if defined(ENC_CS_TRIS) || defined(ENC100_INTERFACE_MODE) || \ 
....................    (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... #endif 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
.................... // ENC28J60 specific 
.................... void   SetCLKOUT(BYTE NewConfig); 
.................... BYTE   GetCLKOUT(void); 
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
....................  
.................... void MACInit(void); 
.................... void MACProcess(void); 
.................... BOOL MACIsLinked(void); 
....................  
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void MACSetReadPtrInRx(WORD offset); 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address); 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address); 
.................... BYTE MACGet(void); 
.................... WORD MACGetArray(BYTE *val, WORD len); 
.................... void MACDiscardRx(void); 
.................... WORD MACGetFreeRxSize(void); 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len); 
.................... BOOL MACIsMemCopyDone(void); 
....................  
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen); 
.................... BOOL MACIsTxReady(void); 
.................... void MACPut(BYTE val); 
.................... void MACPutArray(BYTE *val, WORD len); 
.................... void MACFlush(void); 
....................  
....................  
.................... // ROM function variants for PIC18 
.................... #if defined(__18CXX) 
....................    void MACPutROMArray(ROM BYTE *val, WORD len); 
.................... #else 
....................    #define MACPutROMArray(a,b)   MACPutArray((BYTE*)a,b) 
.................... #endif 
....................  
.................... // PIC32MX with embedded ETHC functions 
.................... #if defined(__PIC32MX__) && defined(_ETH) 
....................    PTR_BASE MACGetTxBaseAddr(void); 
....................    PTR_BASE MACGetHttpBaseAddr(void); 
....................    PTR_BASE MACGetSslBaseAddr(void); 
.................... #endif 
....................  
....................     
.................... #endif 
....................  
.................... #include "TCPIP Stack/IP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  ********************************************************************/ 
.................... #ifndef __IP_H 
.................... #define __IP_H 
....................  
....................  
.................... #define IP_PROT_ICMP    (1u) 
.................... #define IP_PROT_TCP     (6u) 
.................... #define IP_PROT_UDP     (17u) 
....................  
....................  
.................... // IP packet header definition 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
.................... } IP_HEADER; 
....................  
.................... // IP Pseudo header as defined by RFC 793 (needed for TCP and UDP  
.................... // checksum calculations/verification) 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD Length; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define SwapPseudoHeader(h)  (h.Length = swaps(h.Length)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady()       MACIsTxReady() 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(b) MACSetWritePtr(b + BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "TCPIP Stack/ARP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.h and ARPTsk.h into ARP.h 
....................  ********************************************************************/ 
.................... #ifndef __ARP_H 
.................... #define __ARP_H 
....................  
.................... #ifdef STACK_CLIENT_MODE 
....................    void ARPInit(void); 
.................... #else 
....................    #define ARPInit() 
.................... #endif 
....................  
.................... #define ARP_OPERATION_REQ       0x0001u      // Operation code indicating an ARP Request 
.................... #define ARP_OPERATION_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
....................  
....................  
.................... // ARP packet structure 
.................... typedef struct  
.................... #if defined(__CCS__) 
.................... __attribute__((packed)) 
.................... #else 
.................... __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................     WORD        HardwareType;   // Link-layer protocol type (Ethernet is 1). 
....................     WORD        Protocol;       // The upper-layer protocol issuing an ARP request (0x0800 for IPv4).. 
....................     BYTE        MACAddrLen;     // MAC address length (6). 
....................     BYTE        ProtocolLen;    // Length of addresses used in the upper-layer protocol (4). 
....................     WORD        Operation;      // The operation the sender is performing (ARP_REQ or ARP_RESP). 
....................     MAC_ADDR    SenderMACAddr;  // The sender's hardware (MAC) address. 
....................     IP_ADDR     SenderIPAddr;   // The sender's IP address. 
....................     MAC_ADDR    TargetMACAddr;  // The target node's hardware (MAC) address. 
....................     IP_ADDR     TargetIPAddr;   // The target node's IP address. 
.................... } ARP_PACKET; 
....................  
.................... BOOL ARPProcess(void); 
.................... void ARPResolve(IP_ADDR* IPAddr); 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr); 
.................... void SwapARPPacket(ARP_PACKET* p); 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    /* API specific Definitions */ 
....................    #define ARP_REQ       0x0001u      // Operation code indicating an ARP Request 
....................    #define ARP_RESP      0x0002u      // Operation code indicating an ARP Response 
....................  
....................    struct arp_app_callbacks { 
....................        BOOL used; 
....................        void (*ARPPkt_notify)(DWORD SenderIPAddr, DWORD TargetIPAddr,  
....................                              MAC_ADDR* SenderMACAddr, MAC_ADDR* TargetMACAddr, BYTE op_req); 
....................    }; 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app); 
....................    BOOL ARPDeRegisterCallbacks(CHAR id); 
.................... #endif 
....................    BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ); 
.................... #endif 
....................  
....................  
....................  
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... /********************************************************************* 
....................  * 
....................  *               External serial data EEPROM Access Defs. 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        XEEPROM.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/20/02     Original (Rev. 1.0) 
.................... ********************************************************************/ 
.................... #ifndef __XEEPROM_H 
.................... #define __XEEPROM_H 
....................  
.................... #include "HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BOOL XEE_RESULT; 
.................... #define XEE_SUCCESS FALSE 
....................  
.................... #if defined(EEPROM_CS_TRIS)	 
.................... 	void XEEInit(void); 
.................... 	XEE_RESULT XEEBeginWrite(DWORD address); 
.................... 	XEE_RESULT XEEWrite(BYTE val); 
.................... 	void XEEWriteArray(BYTE *val, WORD wLen); 
.................... 	XEE_RESULT XEEEndWrite(void); 
.................... 	XEE_RESULT XEEBeginRead(DWORD address); 
.................... 	BYTE XEERead(void); 
.................... 	XEE_RESULT XEEReadArray(DWORD address, BYTE *buffer, WORD length); 
.................... 	XEE_RESULT XEEEndRead(void); 
.................... 	BOOL XEEIsBusy(void); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI EEPROM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI EERPOM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI EEPROM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void 		You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void 		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BYTE 		You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	XEE_RESULT	You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	BOOL 		You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define XEEInit()				You_cannot_call_the_XEEInit_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginWrite(a) 		You_cannot_call_the_XEEBeginWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWrite(a)				You_cannot_call_the_XEEWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEWriteArray(a,b)		You_cannot_call_the_XEEWriteArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndWrite()			You_cannot_call_the_XEEEndWrite_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEBeginRead(a)			You_cannot_call_the_XEEBeginRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEERead(a)				You_cannot_call_the_XEERead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEReadArray(a, b, c)	You_cannot_call_the_XEEReadArray_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEEndRead()			You_cannot_call_the_XEEEndRead_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define XEEIsBusy()				You_cannot_call_the_XEEIsBusy_function_without_defining_EEPROM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... /********************************************************************* 
....................  * 
....................  *  SPI Flash Memory Driver Header 
....................  *	- Tested to be compatible with SST25VF016B 
....................  *  - Expected compatibility with other SST (Microchip) SST25 series  
....................  *    devices 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIFlash.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * E. Wood				3/20/08	Original 
.................... ********************************************************************/ 
.................... #ifndef __SPIFLASH_H 
.................... #define __SPIFLASH_H 
....................  
.................... #include "HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define SPI_FLASH_SECTOR_SIZE		(4096ul) 
.................... #define SPI_FLASH_PAGE_SIZE			(0ul)		// SST has no page boundary requirements 
....................  
.................... #define SPI_FLASH_SECTOR_MASK		(SPI_FLASH_SECTOR_SIZE - 1) 
....................  
....................  
.................... #if defined(SPIFLASH_CS_TRIS) 
.................... 	void SPIFlashInit(void);		 
.................... 	void SPIFlashReadArray(DWORD dwAddress, BYTE *vData, WORD wLen); 
.................... 	void SPIFlashBeginWrite(DWORD dwAddr); 
.................... 	void SPIFlashWrite(BYTE vData); 
.................... 	void SPIFlashWriteArray(BYTE *vData, WORD wLen); 
.................... 	void SPIFlashEraseSector(DWORD dwAddr); 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI Flash chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI Flash chip, it  
.................... 	// means you have enabled a stack feature that requires SPI Flash hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIFlashInit()				You_cannot_call_the_SPIFlashInit_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashReadArray(a,b,c)	You_cannot_call_the_SPIFlashReadArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashBeginWrite(a)		You_cannot_call_the_SPIFlashBeginWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWrite(a)			You_cannot_call_the_SPIFlashWrite_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashWriteArray(a,b)		You_cannot_call_the_SPIFlashWriteArray_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIFlashEraseSector(a)		You_cannot_call_the_SPIFlashEraseSector_function_without_defining_SPIFLASH_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/SPIRAM.h" 
.................... /********************************************************************* 
....................  * 
....................  * Data SPI RAM Access Routines 
....................  *  -Tested with AMI Semiconductor N256S0830HDA 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        SPIRAM.h 
....................  * Dependencies:    Compiler.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * \file SPIRAM.h 
....................  * \author Howard Henry Schlunder 
....................  * \date 25 July 2007 
.................... ********************************************************************/ 
.................... #ifndef __SPIRAM_H 
.................... #define __SPIRAM_H 
....................  
.................... #include "HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(SPIRAM_CS_TRIS) 
.................... 	void SPIRAMInit(void); 
.................... 	void SPIRAMGetArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	void SPIRAMPutArray(WORD wAddress, BYTE *vData, WORD wLength); 
.................... 	 
.................... 	#define SPIRAMPutString(a,b)			SPIRAMPutArray(a, strlen((char*)b)) 
.................... 	 
.................... 	#if defined(__18CXX) 
.................... 		void SPIRAMPutROMArray(WORD wAddress, ROM BYTE *vData, WORD wLength); 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutROMArray(a, strlenpgm((ROM char*)b)) 
.................... 	#else 
.................... 		#define SPIRAMPutROMString(a,b)		SPIRAMPutArray(a, strlen((char*)b)) 
.................... 		#define SPIRAMPutROMArray(a,b,c)	SPIRAMPutROMArray(a, b, c) 
.................... 	#endif 
.................... #else 
.................... 	// If you get any of these linker errors, it means that you either have an  
.................... 	// error in your HardwareProfile.h or TCPIPConfig.h definitions.  The code  
.................... 	// is attempting to call a function that can't possibly work because you  
.................... 	// have not specified what pins and SPI module the physical SPI SRAM chip  
.................... 	// is connected to.  Alternatively, if you don't have an SPI SRAM chip, it  
.................... 	// means you have enabled a stack feature that requires SPI SRAM hardware. 
.................... 	// In this case, you need to edit TCPIPConfig.h and disable this stack  
.................... 	// feature.  The linker error tells you which object file this error was  
.................... 	// generated from.  It should be a clue as to what feature you need to  
.................... 	// disable. 
.................... 	void You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	void You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first(void); 
.................... 	#define SPIRAMInit()				You_cannot_call_the_SPIRAMInit_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMGetArray(a,b,c)		You_cannot_call_the_SPIRAMGetArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutArray(a,b,c)		You_cannot_call_the_SPIRAMPutArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutString(a,b)		You_cannot_call_the_SPIRAMPutString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMArray(a,b,c)	You_cannot_call_the_SPIRAMPutROMArray_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... 	#define SPIRAMPutROMString(a,b)		You_cannot_call_the_SPIRAMPutROMString_function_without_defining_SPIRAM_CS_TRIS_in_HardwareProfile_h_first() 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  UDP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  ********************************************************************/ 
.................... #ifndef __UDP_H 
.................... #define __UDP_H 
....................  
.................... // Stores a UDP Port Number 
.................... typedef WORD UDP_PORT; 
....................  
.................... // Provides a handle to a UDP Socket 
.................... typedef BYTE UDP_SOCKET; 
....................  
.................... // UDP States  
.................... typedef enum 
.................... { 
.................... 	UDP_DNS_IS_RESOLVED,		// Special state for UDP client mode sockets 
.................... 	UDP_DNS_RESOLVE,		// Special state for UDP client mode sockets 
.................... 	UDP_GATEWAY_SEND_ARP,	// Special state for UDP client mode sockets 
.................... 	UDP_GATEWAY_GET_ARP,		// Special state for UDP client mode sockets	 
....................     UDP_CLOSED,				// Socket is idle and unallocated 
.................... 	UDP_OPENED 
.................... } UDP_STATE; 
....................  
....................  
.................... // Stores information about a current UDP socket 
.................... typedef struct 
.................... { 
.................... 	union 
.................... 	{ 
.................... 		NODE_INFO	remoteNode;		// 10 bytes for MAC and IP address 
.................... 		DWORD		remoteHost;		// RAM or ROM pointer to a hostname string (ex: "www.microchip.com") 
.................... 	} remote; 
....................     //NODE_INFO   remoteNode;		// IP and MAC of remote node 
....................     UDP_PORT    remotePort;		// Remote node's UDP port number 
....................     UDP_PORT    localPort;		// Local UDP port number, or INVALID_UDP_PORT when free 
....................     UDP_STATE smState;			// State of this socket 
....................     DWORD retryInterval; 
.................... 	BYTE retryCount; 
.................... 	struct 
.................... 	{ 
.................... 		unsigned char bRemoteHostIsROM : 1;	// Remote host is stored in ROM 
.................... 	}flags; 
.................... 	WORD eventTime; 
.................... } UDP_SOCKET_INFO; 
....................  
....................  
.................... #define INVALID_UDP_SOCKET      (0xffu)		// Indicates a UDP socket that is not valid 
.................... #define INVALID_UDP_PORT        (0ul)		// Indicates a UDP port that is not valid 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	External Global Variables 
....................   ***************************************************************************/ 
.................... #if !defined(__UDP_C) 
....................     extern UDP_SOCKET activeUDPSocket; 
....................     extern UDP_SOCKET_INFO  UDPSocketInfo[MAX_UDP_SOCKETS]; 
.................... 	extern WORD UDPTxCount; 
.................... 	extern WORD UDPRxCount; 
.................... #endif 
....................  
.................... // Stores the header of a UDP packet 
.................... typedef struct 
.................... { 
....................     UDP_PORT    SourcePort;				// Source UDP port 
....................     UDP_PORT    DestinationPort;		// Destination UDP port 
....................     WORD        Length;					// Length of data 
....................     WORD        Checksum;				// UDP checksum of the data 
.................... } UDP_HEADER; 
....................  
....................  
.................... // Create a server socket and ignore dwRemoteHost. 
.................... #define UDP_OPEN_SERVER		0u 
.................... #if defined(STACK_CLIENT_MODE) 
.................... 	#if defined(STACK_USE_DNS) 
.................... 		// Create a client socket and use dwRemoteHost as a RAM pointer to a hostname string. 
.................... 		#define UDP_OPEN_RAM_HOST	1u 
.................... 		// Create a client socket and use dwRemoteHost as a ROM pointer to a hostname string. 
.................... 		#define UDP_OPEN_ROM_HOST	2u 
.................... 	#else 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use UDP_OPEN_RAM_HOST while the DNS client module is not enabled.  
.................... 		#define UDP_OPEN_RAM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_UDP_OPEN_RAM_HOST 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use UDP_OPEN_ROM_HOST while the DNS client module is not enabled.  
.................... 		#define UDP_OPEN_ROM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_UDP_OPEN_ROM_HOST 
.................... 	#endif 
.................... 	// Create a client socket and use dwRemoteHost as a literal IP address. 
.................... 	#define UDP_OPEN_IP_ADDRESS	3u 
.................... #endif 
....................  
.................... // Create a client socket and use dwRemoteHost as a pointer to a NODE_INFO structure containing the exact remote IP address and MAC address to use. 
.................... #define UDP_OPEN_NODE_INFO	4u 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Function Prototypes 
....................   ***************************************************************************/ 
.................... void UDPInit(void); 
.................... void UDPTask(void); 
.................... UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort,UDP_PORT remotePort); 
....................  
.................... //UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO *remoteNode, UDP_PORT remotePort); 
.................... void UDPClose(UDP_SOCKET s); 
.................... BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len); 
....................  
.................... void UDPSetTxBuffer(WORD wOffset); 
.................... void UDPSetRxBuffer(WORD wOffset); 
.................... WORD UDPIsPutReady(UDP_SOCKET s); 
.................... BOOL UDPPut(BYTE v); 
.................... WORD UDPPutArray(BYTE *cData, WORD wDataLen); 
.................... BYTE* UDPPutString(BYTE *strData); 
.................... void UDPFlush(void); 
....................  
.................... // ROM function variants for PIC18 
.................... #if defined(__18CXX) 
.................... 	WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen); 
.................... 	ROM BYTE* UDPPutROMString(ROM BYTE *strData); 
.................... #else 
.................... 	#define UDPPutROMArray(a,b)	UDPPutArray((BYTE*)a,b) 
.................... 	#define UDPPutROMString(a)	UDPPutString((BYTE*)a) 
.................... #endif 
....................  
.................... WORD UDPIsGetReady(UDP_SOCKET s); 
.................... BOOL UDPGet(BYTE *v); 
.................... WORD UDPGetArray(BYTE *cData, WORD wDataLen); 
.................... void UDPDiscard(void); 
.................... BOOL UDPIsOpened(UDP_SOCKET socket); 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................     UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO* remoteNode,  
....................                         UDP_PORT remotePort) 
....................  
....................   Summary: 
....................     Macro of the legacy version of UDPOpen. 
....................      
....................   Description: 
....................     UDPOpen is a macro replacement of the legacy implementation of UDPOpen. 
....................     Creates a UDP socket handle for transmiting or receiving UDP packets.   
....................     Call this function to obtain a handle required by other UDP function. 
....................  
....................   Precondition: 
....................     UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................     localPort - UDP port number to listen on.  If 0, stack will dynamically  
....................         assign a unique port number to use. 
....................     remoteNode - Pointer to remote node info (MAC and IP address) for this 
....................         connection.  If this is a server socket (receives the first packet)  
....................         or the destination is the broadcast address, then this parameter 
....................         should be NULL. 
....................     remotePort - For client sockets, the remote port number. 
....................  
....................   Return Values: 
....................     Success - 
....................         A UDP socket handle that can be used for subsequent UDP API calls. 
....................     Failure - 
....................         INVALID_UDP_SOCKET.  This function fails when no more UDP socket  
....................         handles are available.  Increase MAX_UDP_SOCKETS to make more sockets  
....................         available. 
....................      
....................   Remarks: 
....................     When finished using the UDP socket handle, call the UDPClose() function  
....................     to free the socket and delete the handle. 
....................   ***************************************************************************/ 
.................... #define UDPOpen(localPort,remoteNode,remotePort)  UDPOpenEx((DWORD)remoteNode,UDP_OPEN_NODE_INFO,localPort,remotePort) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01  	Original        (Rev 1.0) 
....................  * Howard Schlunder		11/30/06	See "TCPIP Stack Version.txt" file 
....................  ********************************************************************/ 
.................... #ifndef __TCP_HITECH_WORKAROUND_H 
.................... #define __TCP_HITECH_WORKAROUND_H 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Type Definitions 
....................   ***************************************************************************/ 
....................  
.................... // A TCP_SOCKET is stored as a single BYTE 
.................... typedef BYTE TCP_SOCKET; 
....................  
.................... #define INVALID_SOCKET      (0xFE)	// The socket is invalid or could not be opened 
.................... #define UNKNOWN_SOCKET      (0xFF)	// The socket is not known 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	State Machine Variables 
....................   ***************************************************************************/ 
....................  
.................... // TCP States as defined by RFC 793 
.................... typedef enum 
.................... { 
.................... 	TCP_GET_DNS_MODULE,		// Special state for TCP client mode sockets 
.................... 	TCP_DNS_RESOLVE,		// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_SEND_ARP,	// Special state for TCP client mode sockets 
.................... 	TCP_GATEWAY_GET_ARP,	// Special state for TCP client mode sockets 
....................  
....................     TCP_LISTEN,				// Socket is listening for connections 
....................     TCP_SYN_SENT,			// A SYN has been sent, awaiting an SYN+ACK 
....................     TCP_SYN_RECEIVED,		// A SYN has been received, awaiting an ACK 
....................     TCP_ESTABLISHED,		// Socket is connected and connection is established 
....................     TCP_FIN_WAIT_1,			// FIN WAIT state 1 
....................     TCP_FIN_WAIT_2,			// FIN WAIT state 2 
....................     TCP_CLOSING,			// Socket is closing 
.................... //	TCP_TIME_WAIT, state is not implemented 
.................... 	TCP_CLOSE_WAIT,			// Waiting to close the socket 
....................     TCP_LAST_ACK,			// The final ACK has been sent 
....................     TCP_CLOSED,				// Socket is idle and unallocated 
....................  
....................     TCP_CLOSED_BUT_RESERVED	// Special state for TCP client mode sockets.  Socket is idle, but still allocated pending application closure of the handle. 
.................... } TCP_STATE; 
....................  
.................... typedef enum 
.................... { 
.................... 	SSL_NONE = 0,			// No security is enabled 
.................... 	SSL_HANDSHAKING,		// Handshake is progressing (no application data allowed) 
.................... 	SSL_ESTABLISHED,		// Connection is established and secured 
.................... 	SSL_CLOSED				// Connection has been closed (no applicaiton data is allowed) 
.................... } SSL_STATE; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // TCP Control Block (TCB) stub data storage.  Stubs are stored in local PIC RAM for speed. 
.................... // Current size is 34 bytes (PIC18), 36 bytes (PIC24/dsPIC), or 56 (PIC32) 
.................... typedef struct 
.................... { 
.................... 	PTR_BASE bufferTxStart;		// First byte of TX buffer 
.................... 	PTR_BASE bufferRxStart;		// First byte of RX buffer.  TX buffer ends 1 byte prior 
.................... 	PTR_BASE bufferEnd;			// Last byte of RX buffer 
.................... 	PTR_BASE txHead;			// Head pointer for TX 
.................... 	PTR_BASE txTail;			// Tail pointer for TX 
.................... 	PTR_BASE rxHead;			// Head pointer for RX 
.................... 	PTR_BASE rxTail;			// Tail pointer for RX 
....................     DWORD eventTime;			// Packet retransmissions, state changes 
.................... 	WORD eventTime2;			// Window updates, automatic transmission 
.................... 	union 
.................... 	{ 
.................... 		WORD delayedACKTime;	// Delayed Acknowledgement timer 
.................... 		WORD closeWaitTime;		// TCP_CLOSE_WAIT timeout timer 
.................... 	} OverlappedTimers; 
....................     TCP_STATE smState;			// State of this socket 
....................     struct 
....................     { 
.................... 	    unsigned char vUnackedKeepalives : 3;		// Count of how many keepalives have been sent with no response 
....................         unsigned char bServer : 1;					// Socket should return to listening state when closed 
.................... 		unsigned char bTimerEnabled	: 1;			// Timer is enabled 
.................... 		unsigned char bTimer2Enabled : 1;			// Second timer is enabled 
.................... 		unsigned char bDelayedACKTimerEnabled : 1;	// DelayedACK timer is enabled 
.................... 		unsigned char bOneSegmentReceived : 1;		// A segment has been received 
.................... 		unsigned char bHalfFullFlush : 1;			// Flush is for being half full 
.................... 		unsigned char bTXASAP : 1;					// Transmit as soon as possible (for Flush) 
.................... 		unsigned char bTXASAPWithoutTimerReset : 1;	// Transmit as soon as possible (for Flush), but do not reset retransmission timers 
.................... 		unsigned char bTXFIN : 1;					// FIN needs to be transmitted 
.................... 		unsigned char bSocketReset : 1;				// Socket has been reset (self-clearing semaphore) 
.................... 		unsigned char bSSLHandshaking : 1;			// Socket is in an SSL handshake 
.................... 		unsigned char filler : 2;					// Future expansion 
....................     } Flags; 
.................... 	WORD_VAL remoteHash;	// Consists of remoteIP, remotePort, localPort for connected sockets.  It is a localPort number only for listening server sockets. 
....................  
....................     #if defined(STACK_USE_SSL) 
....................     PTR_BASE sslTxHead;		// Position of data being written in next SSL application record 
....................     						//   Also serves as cache of localSSLPort when smState = TCP_LISTENING 
....................     PTR_BASE sslRxHead;		// Position of incoming data not yet handled by SSL 
....................     BYTE sslStubID;			// Which sslStub is associated with this connection 
....................     BYTE sslReqMessage;		// Currently requested SSL message 
....................     #endif 
....................  
.................... 	BYTE vMemoryMedium;		// Which memory medium the TCB is actually stored 
.................... 	 
.................... } TCB_STUB; 
....................  
.................... // Remainder of TCP Control Block data. 
.................... // The rest of the TCB is stored in Ethernet buffer RAM or elsewhere as defined by vMemoryMedium. 
.................... // Current size is 41 (PIC18), 42 (PIC24/dsPIC), or 48 bytes (PIC32) 
.................... typedef struct 
.................... { 
.................... 	DWORD		retryInterval;			// How long to wait before retrying transmission 
.................... 	DWORD		MySEQ;					// Local sequence number 
.................... 	DWORD		RemoteSEQ;				// Remote sequence number 
.................... 	PTR_BASE	txUnackedTail;			// TX tail pointer for data that is not yet acked 
....................     WORD_VAL	remotePort;				// Remote port number 
....................     WORD_VAL	localPort;				// Local port number 
.................... 	WORD		remoteWindow;			// Remote window size 
.................... 	WORD		wFutureDataSize;		// How much out-of-order data has been received 
.................... 	union 
.................... 	{ 
.................... 		NODE_INFO	niRemoteMACIP;		// 10 bytes for MAC and IP address 
.................... 		DWORD		dwRemoteHost;		// RAM or ROM pointer to a hostname string (ex: "www.microchip.com") 
.................... 	} remote; 
.................... 	SHORT		sHoleSize;				// Size of the hole, or -1 for none exists.  (0 indicates hole has just been filled) 
....................     struct 
....................     { 
....................         unsigned char bFINSent : 1;		// A FIN has been sent 
.................... 		unsigned char bSYNSent : 1;		// A SYN has been sent 
.................... 		unsigned char bRemoteHostIsROM : 1;	// Remote host is stored in ROM 
.................... 		unsigned char bRXNoneACKed1 : 1;	// A duplicate ACK was likely received 
.................... 		unsigned char bRXNoneACKed2 : 1;	// A second duplicate ACK was likely received 
.................... 		unsigned char filler : 3;		// future use 
....................     } flags; 
.................... 	WORD		wRemoteMSS;				// Maximum Segment Size option advirtised by the remote node during initial handshaking 
....................     #if defined(STACK_USE_SSL) 
....................     WORD_VAL	localSSLPort;			// Local SSL port number (for listening sockets) 
....................     #endif 
.................... 	BYTE		retryCount;				// Counter for transmission retries 
.................... 	BYTE		vSocketPurpose;			// Purpose of socket (as defined in TCPIPConfig.h) 
.................... } TCB; 
....................  
.................... // Information about a socket 
.................... typedef struct 
.................... { 
.................... 	NODE_INFO remote;		// NODE_INFO structure for remote node 
.................... 	WORD_VAL remotePort;	// Port number associated with remote node 
.................... } SOCKET_INFO; 
....................  
.................... /**************************************************************************** 
....................   Section: 
.................... 	Function Declarations 
....................   ***************************************************************************/ 
....................  
.................... void TCPInit(void); 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP); 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP); 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP); 
.................... void TCPDisconnect(TCP_SOCKET hTCP); 
.................... void TCPClose(TCP_SOCKET hTCP); 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP); 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte); 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* Data, WORD Len); 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* Data); 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP); 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP); 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte); 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD count); 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart); 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart); 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
.................... void TCPDiscard(TCP_SOCKET hTCP); 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len); 
.................... void TCPTick(void); 
.................... void TCPFlush(TCP_SOCKET hTCP); 
....................  
.................... // Create a server socket and ignore dwRemoteHost. 
.................... #define TCP_OPEN_SERVER		0u 
.................... #if defined(STACK_CLIENT_MODE) 
.................... 	#if defined(STACK_USE_DNS) 
.................... 		// Create a client socket and use dwRemoteHost as a RAM pointer to a hostname string. 
.................... 		#define TCP_OPEN_RAM_HOST	1u 
.................... 		// Create a client socket and use dwRemoteHost as a ROM pointer to a hostname string. 
.................... 		#define TCP_OPEN_ROM_HOST	2u 
.................... 	#else 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_RAM_HOST 
.................... 		// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while the DNS client module is not enabled.  
.................... 		#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_USE_DNS_to_use_TCP_OPEN_ROM_HOST 
.................... 	#endif 
.................... 	// Create a client socket and use dwRemoteHost as a literal IP address. 
.................... 	#define TCP_OPEN_IP_ADDRESS	3u 
.................... 	// Create a client socket and use dwRemoteHost as a pointer to a NODE_INFO structure containing the exact remote IP address and MAC address to use. 
.................... 	#define TCP_OPEN_NODE_INFO	4u 
.................... #else 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_RAM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_RAM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_RAM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_ROM_HOST while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_ROM_HOST	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_ROM_HOST 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_IP_ADDRESS while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_IP_ADDRESS	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_IP_ADDRESS 
.................... 	// Emit an undeclared identifier diagnostic if code tries to use TCP_OPEN_NODE_INFO while STACK_CLIENT_MODE feature is not enabled.  
.................... 	#define TCP_OPEN_NODE_INFO	You_need_to_enable_STACK_CLIENT_MODE_to_use_TCP_OPEN_NODE_INFO 
.................... #endif 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose); 
....................  
.................... #if defined(__18CXX) 
.................... 	WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare); 
....................  
.................... 	/***************************************************************************** 
.................... 	  Summary: 
.................... 		Alias to TCPFindROMArrayEx with no length parameter. 
.................... 	 
.................... 	  Description: 
.................... 		This function is an alias to TCPFindROMArrayEx with no length parameter.   
.................... 		It is provided for backwards compatibility with an older API. 
.................... 	  ***************************************************************************/ 
.................... 	#define TCPFindROMArray(a,b,c,d,e)		TCPFindROMArrayEx(a,b,c,d,0,e) 
.................... 	 
.................... 	WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* Data, WORD Len); 
.................... 	ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* Data); 
.................... #else 
.................... 	#define TCPFindROMArray(a,b,c,d,e) 		TCPFindArray(a,(BYTE*)b,c,d,e) 
.................... 	#define TCPFindROMArrayEx(a,b,c,d,e,f) 	TCPFindArrayEx(a,(BYTE*)b,c,d,e,f) 
.................... 	#define TCPPutROMArray(a,b,c)			TCPPutArray(a,(BYTE*)b,c) 
.................... 	#define TCPPutROMString(a,b)			TCPPutString(a,(BYTE*)b) 
.................... #endif 
....................  
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP); 
.................... // Alias to TCPIsGetReady provided for API completeness 
.................... #define TCPGetRxFIFOFull(a)					TCPIsGetReady(a) 
.................... // Alias to TCPIsPutReady provided for API completeness 
.................... #define TCPGetTxFIFOFree(a) 				TCPIsPutReady(a) 
....................  
.................... #define TCP_ADJUST_GIVE_REST_TO_RX	0x01u	// Resize flag: extra bytes go to RX  
.................... #define TCP_ADJUST_GIVE_REST_TO_TX	0x02u	// Resize flag: extra bytes go to TX 
.................... #define TCP_ADJUST_PRESERVE_RX		0x04u	// Resize flag: attempt to preserve RX buffer 
.................... #define TCP_ADJUST_PRESERVE_TX		0x08u	// Resize flag: attempt to preserve TX buffer 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags); 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host); 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType); 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP); 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port); 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg); 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP); 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP); 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP); 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len); 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len); 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone); 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP); 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP); 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFind(a,b,c,d)					TCPFindEx(a,b,c,0,d) 
....................  
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPFindArrayEx with no length parameter. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPFindArrayEx with no length parameter.  It is 
.................... 	provided for backwards compatibility with an older API. 
....................   ***************************************************************************/ 
.................... #define TCPFindArray(a,b,c,d,e)				TCPFindArrayEx(a,b,c,d,0,e) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a server. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for server sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPListen(port)			TCPOpen(0, TCP_OPEN_SERVER, port, TCP_PURPOSE_DEFAULT) 
....................  
.................... /***************************************************************************** 
....................   Summary: 
.................... 	Alias to TCPOpen as a client. 
....................  
....................   Description: 
.................... 	This function is an alias to TCPOpen for client sockets.  It is provided 
.................... 	for backwards compatibility with older versions of the stack.  New 
.................... 	applications should use the TCPOpen API instead. 
....................   ***************************************************************************/ 
.................... #define TCPConnect(remote,port)	TCPOpen((DWORD)remote, TCP_OPEN_NODE_INFO, port, TCP_PURPOSE_DEFAULT) 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  DHCP Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        DHCP.h 
....................  * Dependencies:    TCPIPStack.h 
....................  *                  UDP.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
....................  ********************************************************************/ 
.................... #ifndef __DHCP_H 
.................... #define __DHCP_H 
....................  
.................... // UDP client port for DHCP Client transactions 
.................... #define DHCP_CLIENT_PORT                (68u) 
.................... // UDP listening port for DHCP Server messages 
.................... #define DHCP_SERVER_PORT                (67u) 
....................  
.................... #define BOOT_REQUEST                    (1u)   // BOOT_REQUEST DHCP type 
.................... #define BOOT_REPLY                      (2u)   // BOOT_REPLY DHCP type 
.................... #define BOOT_HW_TYPE                    (1u)   // BOOT_HW_TYPE DHCP type 
.................... #define BOOT_LEN_OF_HW_TYPE             (6u)   // BOOT_LEN_OF_HW_TYPE DHCP type 
....................  
.................... #define DHCP_MESSAGE_TYPE               (53u)   // DHCP Message Type constant 
.................... #define DHCP_MESSAGE_TYPE_LEN           (1u)   // Length of DHCP Message Type 
....................  
.................... #define DHCP_UNKNOWN_MESSAGE            (0u)   // Code for unknown DHCP message 
....................  
.................... #define DHCP_DISCOVER_MESSAGE           (1u)   // DCHP Discover Message 
.................... #define DHCP_OFFER_MESSAGE              (2u)   // DHCP Offer Message 
.................... #define DHCP_REQUEST_MESSAGE            (3u)   // DHCP Request message 
.................... #define DHCP_DECLINE_MESSAGE            (4u)   // DHCP Decline Message 
.................... #define DHCP_ACK_MESSAGE                (5u)   // DHCP ACK Message 
.................... #define DHCP_NAK_MESSAGE                (6u)   // DHCP NAK Message 
.................... #define DHCP_RELEASE_MESSAGE            (7u)   // DCHP Release message 
....................  
.................... #define DHCP_SERVER_IDENTIFIER          (54u)   // DHCP Server Identifier 
.................... #define DHCP_SERVER_IDENTIFIER_LEN      (4u)   // DHCP Server Identifier length 
....................  
.................... #define DHCP_OPTION_ACK_MESSAGE         (53u)   // DHCP_OPTION_ACK_MESSAGE Type 
.................... #define DHCP_PARAM_REQUEST_LIST         (55u)   // DHCP_PARAM_REQUEST_LIST Type 
.................... #define DHCP_PARAM_REQUEST_LIST_LEN     (4u)   // DHCP_PARAM_REQUEST_LIST_LEN Type 
.................... #define DHCP_PARAM_REQUEST_IP_ADDRESS       (50u)   // DHCP_PARAM_REQUEST_IP_ADDRESS Type 
.................... #define DHCP_PARAM_REQUEST_IP_ADDRESS_LEN   (4u)   // DHCP_PARAM_REQUEST_IP_ADDRESS_LEN Type 
.................... #define DHCP_SUBNET_MASK                (1u)   // DHCP_SUBNET_MASK Type 
.................... #define DHCP_ROUTER                     (3u)   // DHCP_ROUTER Type 
.................... #define DHCP_DNS                  (6u)   // DHCP_DNS Type 
.................... #define DHCP_HOST_NAME               (12u)   // DHCP_HOST_NAME Type 
.................... #define DHCP_IP_LEASE_TIME              (51u)   // DHCP_IP_LEASE_TIME Type 
.................... #define DHCP_END_OPTION                 (255u)   // DHCP_END_OPTION Type 
....................  
.................... // DHCP or BOOTP Header structure 
.................... #if defined(__CCS__) 
.................... typedef struct __attribute__((packed)) 
.................... #else 
.................... typedef struct __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................    BYTE      MessageType;   // Message type for this message 
....................    BYTE      HardwareType;   // Hardware type for this message 
....................    BYTE      HardwareLen;   // Length of hardware type 
....................    BYTE      Hops;         // Number of hops 
....................    DWORD      TransactionID;   // DHCP Transaction ID 
....................    WORD      SecondsElapsed;   // Number of elapsed seconds 
....................    WORD      BootpFlags;      // BOOTP Flags 
....................    IP_ADDR      ClientIP;      // Client IP 
....................    IP_ADDR      YourIP;         // Your IP 
....................    IP_ADDR      NextServerIP;   // Next Server IP 
....................    IP_ADDR      RelayAgentIP;   // Relay Agent IP 
....................    MAC_ADDR   ClientMAC;      // Client MAC Address 
.................... } BOOTP_HEADER; 
....................  
.................... // DHCP State Machine 
.................... typedef enum 
.................... { 
....................    SM_DHCP_DISABLED = 0,      // DHCP is not currently enabled 
....................    SM_DHCP_GET_SOCKET,         // DHCP is trying to obtain a socket 
....................    SM_DHCP_SEND_DISCOVERY,      // DHCP is sending a DHCP Discover message 
....................    SM_DHCP_GET_OFFER,         // DHCP is waiting for a DHCP Offer 
....................    SM_DHCP_SEND_REQUEST,      // DHCP is sending a DHCP Send Reequest message 
....................    SM_DHCP_GET_REQUEST_ACK,   // DCHP is waiting for a Request ACK message 
....................    SM_DHCP_BOUND,            // DHCP is bound 
....................    SM_DHCP_SEND_RENEW,         // DHCP is sending a DHCP renew message (first try) 
....................    SM_DHCP_GET_RENEW_ACK,      // DHCP is waiting for a renew ACK 
....................    SM_DHCP_SEND_RENEW2,      // DHCP is sending a DHCP renew message (second try) 
....................    SM_DHCP_GET_RENEW_ACK2,      // DHCP is waiting for a renew ACK 
....................    SM_DHCP_SEND_RENEW3,      // DHCP is sending a DHCP renew message (third try) 
....................    SM_DHCP_GET_RENEW_ACK3      // DHCP is waiting for a renew ACK 
.................... } SM_DHCP; 
....................  
....................  
.................... void DHCPInit(BYTE vInterface); 
.................... void DHCPTask(void); 
.................... void DHCPServerTask(void); 
.................... void DHCPDisable(BYTE vInterface); 
.................... void DHCPEnable(BYTE vInterface); 
.................... BOOL DHCPIsEnabled(BYTE vInterface); 
.................... BOOL DHCPIsBound(BYTE vInterface); 
.................... BOOL DHCPStateChanged(BYTE vInterface); 
.................... BOOL DHCPIsServerDetected(BYTE vInterface); 
....................  
.................... #if defined(STACK_USE_DHCP_SERVER) 
.................... extern BOOL bDHCPServerEnabled; 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #ifndef __ICMP_H 
.................... #define __ICMP_H 
....................  
.................... void ICMPProcess(NODE_INFO *remote, WORD len); 
....................  
.................... BOOL ICMPBeginUsage(void); 
.................... void ICMPSendPing(DWORD dwRemoteIP); 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost); 
.................... LONG ICMPGetReply(void); 
.................... void ICMPEndUsage(void); 
....................  
.................... #if defined(__18CXX) 
.................... 	void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost); 
.................... #else 
.................... 	#define ICMPSendPingToHostROM(a) 	ICMPSendPingToHost((BYTE*)(a)) 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(MRF24WG) 
....................  #define WF_DisplayModuleAssertInfo() 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SCAN_TASK) 
....................    #include "ccs_wifiscan.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "ccs_HTTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "ccs_HTTP2.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                                                                     /// 
.................... ///                              HTTP2.H                                /// 
.................... ///                                                                     /// 
.................... /// Simple webserver for the Microchip TCP/IP stack using web pages     ///  
.................... /// on an MultiMediaCard.                                                /// 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.H THAN WHAT MICROCHIP PROVIDES       /// 
.................... ///                                                                     /// 
.................... /// See HTTP.C for documenation                                         /// 
.................... ///                                                                     /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef HTTP_USE_CHUNKS 
.................... #define HTTP_USE_CHUNKS   0 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_DOUBLE_ESCAPE 
.................... #define HTTP_USE_DOUBLE_ESCAPE   0 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_TRIPLE_ESCAPE 
.................... #define HTTP_USE_TRIPLE_ESCAPE   0 
.................... #endif 
....................  
.................... #ifndef HTTP_PORT 
.................... #define HTTP_PORT             80 
.................... #endif 
....................  
.................... #ifndef HTTP_NUM_SOCKETS 
.................... #define HTTP_NUM_SOCKETS      1 
.................... #endif 
....................  
.................... #ifndef HTTP_GET_PARAM_MAX_SIZE 
.................... #define HTTP_GET_PARAM_MAX_SIZE  254 
.................... #endif 
....................  
.................... #ifndef HTTP_USE_AUTHENTICATION 
.................... #define  HTTP_USE_AUTHENTICATION FALSE 
.................... #endif 
....................  
.................... #ifndef HTTP_LAST_MODIFIED_CHECK 
.................... #define HTTP_LAST_MODIFIED_CHECK FALSE 
.................... #endif 
....................  
.................... void HTTPInit(void); 
.................... void HTTPServer(void); 
....................  
.................... //**** CALLBACKS START ******/// 
....................  
.................... /// the following two functions are callbacks and 
.................... /// must be written in your main application!!!  see the documentation 
.................... /// in http2.c for more help. 
....................  
.................... #if HTTP_USE_TRIPLE_ESCAPE 
.................... unsigned int8 http_format_char(char* file, unsigned int16 id, char *str, unsigned int8 max_ret); 
.................... #else 
.................... unsigned int8 http_format_char(char* file, char id, char *str, unsigned int8 max_ret); 
.................... #endif 
....................  
.................... void http_exec_cgi(char* file, char *key, char *val); 
....................  
.................... #if HTTP_USE_AUTHENTICATION 
....................  int1 http_check_authentication(char *fileName, char *user, char *pwd); 
.................... #endif 
....................  
.................... //**** CALLBACKS END ******/// 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TWITTER) 
....................    #include "ccs_twitter.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "ccs_SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "ccs_TFTPs.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "ccs_SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "ccs_gratarp.h" 
.................... #endif 
....................  
.................... #define TickGetDiff(a, b)  (a-b) 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................        #if !defined(STACK_USE_DNS) 
....................            #define STACK_USE_DNS 
....................        #endif 
....................        #if !defined(STACK_USE_UDP) 
....................            #define STACK_USE_UDP 
....................        #endif        
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #ifndef STACK_USE_MPFS 
....................       #define STACK_USE_MPFS 
....................     #endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #if !defined(STACK_CLIENT_MODE) 
....................        #define STACK_CLIENT_MODE 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_WIFI 
....................    // if defined, MyWFIsConnected() won't return TRUE in AdHoc mode until after 
....................    // it receives some IP traffic.  It will then stay connected until after 5 
....................    // minutes of no activity. 
....................    #define WIFI_ADHOC_CONNECTION_TIMER ((TICK)TICKS_PER_SECOND * 300) 
....................     
....................    extern unsigned int8 g_connectionProfileID; 
....................     
....................    #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    extern int1 g_WifiAdhocIsConn; 
....................    extern TICK g_WifiAdhocTickConn; 
....................    #endif 
....................     
....................    // this is optional 
....................    extern tWFDeviceInfo g_tWFDeviceInfo; 
....................    #define WIFI_GET_VERSION_INFO g_tWFDeviceInfo 
....................     
....................    extern unsigned int8 WIFI_channelList[16]; 
....................    extern unsigned int8 WIFI_numChannelsInList; 
....................    extern unsigned int8 WIFI_region; 
....................    extern int1 g_WifiConnectFail; 
....................     
....................    // this is similar to MACIsLinked() and WFisConnected().  this one has some 
....................    // filters and extra UI logic to better represent link status to the user. 
....................    // use this for UI displays. 
....................    // REMOVED - Use IsLinked() instead 
....................    //int1 MyWFisConnected(void); 
....................     
....................    // This routine does a few things: 
....................    //  * Reset WIFI unit if no it goes a long time without a connection, 
....................    //       because old modules would hang on WPA connect failure. 
....................    //  * Ad-Hoc connection timer support (WIFI_ADHOC_CONNECTION_TIMER) 
....................    //  * LED Traffic flickering and LED connection status 
....................    void WIFIConnectTask(void); 
....................    void WIFIConnectInitStates(void); 
....................     
....................    #if defined(WF_FORCE_NO_PS_POLL) 
....................       void WF_CCS_PsPollDisable(void); 
....................    #endif 
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void); 
....................  
.................... // A higher level version of MACIsLinked(). 
.................... //  - returns FALSE if MACIsLinked() is TRUE -but- DHCP is enabled and not 
.................... //       bound. 
.................... //  - returns FALSE in WIFI if using AdHoc mode and it has been a while 
.................... //       since no traffic 
.................... //  - else, returns MACIsLinked() 
.................... int1 IsLinked(void); 
....................  
.................... //this macro called by stack when new tcp/ip traffic tx/rx. 
.................... #if STACK_USE_WIFI 
....................    #define STACK_USE_CCS_TX_EVENT()  LinkTraffic(TRUE) 
....................    #define STACK_USE_CCS_RX_EVENT()  LinkTraffic(FALSE) 
....................    void LinkTraffic(int1 isTx); 
....................     
....................    #define WF_SECURITY_NUM_CHOICES  (WF_SECURITY_WEP_AUTO+1) 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "TCPIP Stack/mpfs.h" 
.................... /********************************************************************* 
....................  * 
....................  *               Microchip File System 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MPFS.h 
....................  * Dependencies:    StackTsk.H 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01     Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      5/31/06      Changed EEPROM addressing to 32 bits 
....................  * DSR/CCS              5/18/11     To be compatible with #import of mpfs 
....................  *                                   into program memory, MPFS_INVALID changed 
....................  *                                   to FFFFFFFF for all modes. 
.................... ********************************************************************/ 
.................... #ifndef __MPFS_H 
.................... #define __MPFS_H 
....................  
.................... #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH) 
....................     typedef DWORD MPFS;                           // For default 32 bit addressing (use /ll option with MPFS.exe) 
....................     #define MPFS_INVALID            (0xffffffffu)   // For default 32 bit addressing (use /ll option with MPFS.exe) 
.................... //    typedef WORD MPFS;                        // For old short 16 bit addressing (use /b option with MPFS.exe) 
.................... //    #define MPFS_INVALID            (0xffff)      // For old short 16 bit addressing (use /b option with MPFS.exe) 
.................... #else 
....................    /* ccs bug, this creates confusion for compiler.  maybe ptr to ptr confusion? 
....................    #if defined(__C30__) 
....................       typedef DWORD MPFS; 
....................        #define MPFS_INVALID                (MPFS)(0xffffffffu) 
....................    #else 
....................       typedef ROM BYTE* MPFS; 
....................        #define MPFS_INVALID                (MPFS)(0xffffffu) 
....................    #endif 
....................    */ 
....................   #if defined(__PCD__) || defined(__PCH__)   //__CCS__ 
....................    #define MPFS_INVALID                (MPFS)(0xffffffffu) 
....................   #else 
....................    #define MPFS_INVALID                (MPFS)(0xffffffu) 
....................   #endif 
....................    #define MPFS   __ADDRESS__ 
.................... #endif 
....................  
.................... #define MPFS_NOT_AVAILABLE              (0x0u) 
....................  
.................... #if defined(MPFS_USE_EEPROM) 
....................    #if defined(USE_EEPROM_25LC1024) 
....................       #define MPFS_WRITE_PAGE_SIZE      (256u) 
....................    #else 
....................       #define MPFS_WRITE_PAGE_SIZE      (64u) 
....................    #endif 
.................... #endif 
....................  
....................  
....................  
.................... BOOL MPFSInit(void); 
.................... MPFS MPFSOpen(BYTE* name); 
.................... MPFS MPFSOpenROM(ROM BYTE* name); 
.................... BYTE MPFSGet(void); 
.................... void MPFSClose(void); 
.................... MPFS MPFSFormat(void); 
.................... BOOL MPFSPut(BYTE b); 
.................... MPFS MPFSPutEnd(void); 
.................... MPFS MPFSSeek(MPFS offset); 
.................... BOOL MPFSGetLong(DWORD *ul); 
....................  
.................... #if !defined(__MPFS_C) 
....................    extern BYTE mpfsOpenCount; 
....................     extern MPFS _currentHandle; 
....................     //extern BYTE _currentCount; //ccs bug removing for now because it doesn't match definition in mpfs.c 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSGetBegin(MPFS handle) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  * 
....................  * Input:           handle      - handle of file that is to be read 
....................  * 
....................  * Output:          TRUE if successful 
....................  *                  !TRUE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS storage media for subsequent reads. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
....................     BOOL MPFSGetBegin(MPFS handle); 
.................... #else 
....................     #define MPFSGetBegin(handle)    (_currentHandle = handle) 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSGetEnd(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  *                  MPFSGetBegin() = TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current mpfs handle. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Ends on-going read cycle. 
....................  *                  MPFS handle that is returned must be used 
....................  *                  for subsequent begin gets.. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
....................     MPFS MPFSGetEnd(void); 
.................... #else 
....................     #define MPFSGetEnd()        _currentHandle 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BOOL MPFSIsEOF(void) 
....................  * 
....................  * PreCondition:    MPFSGetBegin() must be called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if current file read has reached end of file. 
....................  *                  FALSE if otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define MPFSIsEOF()     (_currentHandle == MPFS_INVALID) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSPutBegin(MPFS handle) 
....................  * 
....................  * PreCondition:    MPFSInit() and MPFSFormat() are already called. 
....................  * 
....................  * Input:           handle  - handle to where put to begin 
....................  * 
....................  * Output:          TRUE if successful 
....................  *                  !TRUE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS image to get re-written 
....................  * 
....................  * Note:            MPFS will be unaccessible until MPFSClose is 
....................  *                  called. 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
....................     BOOL MPFSPutBegin(MPFS handle); 
.................... #else 
....................     #define MPFSPutBegin(handle)        (_currentHandle = handle) 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSTell(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          current MPFS file pointer 
....................  * 
....................  * Side Effects:    None. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None. 
....................  ********************************************************************/ 
.................... #define MPFSTell()      (_currentHandle) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           BYTE MPFSInUse(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          No. of file currently open. 
....................  *                  If == 0, MPFS is not in use. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define MPFSIsInUse()       (mpfsOpenCount) 
....................  
.................... #endif 
....................  
....................     
....................    extern MPFS _MpfsEofLoc; 
....................     
....................    //returns number of bytes read before EOF. 
....................    //if it returns n then no EOF. 
....................    unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n); 
.................... #endif 
....................  
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void); 
.................... #endif 
....................  
.................... BYTE GenerateRandomByteFromTimers(void); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/TCPIP Stack/TCPIPConfig.h" 
.................... #ifndef __TCPIPCONFIG_H 
.................... #define __TCPIPCONFIG_H 
....................  
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
....................  
.................... #define STACK_USE_ICMP_SERVER    1 
.................... #define STACK_USE_TCP            1 
.................... #define STACK_USE_DHCP_CLIENT    1 
....................  
.................... #define STACK_CCS_SMTP_TX_SIZE    0 
.................... #define STACK_CCS_SMTP_RX_SIZE    0 
....................  
.................... #define STACK_USE_CCS_HTTP2_SERVER 
.................... #define STACK_CCS_HTTP2_SERVER_TX_SIZE    1500 
.................... #define STACK_CCS_HTTP2_SERVER_RX_SIZE    500 
.................... #define HTTP_NUM_SOCKETS                  1 
.................... #define HTTP_PORT                         (80u) 
.................... #define HTTP_USE_DOUBLE_ESCAPE            1 
.................... #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start) 
....................  
.................... #define STACK_MY_TELNET_SERVER_TX_SIZE    0 
.................... #define STACK_MY_TELNET_SERVER_RX_SIZE    0 
....................  
.................... #define MY_DEFAULT_HOST_NAME      "CCS_EXAMPLES" 
....................  
.................... #define MY_DEFAULT_MAC_BYTE1      (0x0) 
.................... #define MY_DEFAULT_MAC_BYTE2      (0x20) 
.................... #define MY_DEFAULT_MAC_BYTE3      (0x30) 
.................... #define MY_DEFAULT_MAC_BYTE4      (0x40) 
.................... #define MY_DEFAULT_MAC_BYTE5      (0x50) 
.................... #define MY_DEFAULT_MAC_BYTE6      (0x60) 
....................  
.................... #define TCP_CONFIGURATION      1 
....................  
.................... #define TCP_ETH_RAM_SIZE (STACK_CCS_SMTP_TX_SIZE + \ 
....................                           STACK_CCS_SMTP_RX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_TX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_RX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_TX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_RX_SIZE + \ 
....................                           100*TCP_CONFIGURATION) 
....................  
.................... // Define names of socket types 
.................... #define TCP_PURPOSE_GENERIC_TCP_CLIENT 0 
.................... #define TCP_PURPOSE_GENERIC_TCP_SERVER 1 
.................... #define TCP_PURPOSE_TELNET             2 
.................... #define TCP_PURPOSE_FTP_COMMAND        3 
.................... #define TCP_PURPOSE_FTP_DATA           4 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_TX 5 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_RX 6 
.................... #define TCP_PURPOSE_UART_2_TCP_BRIDGE  7 
.................... #define TCP_PURPOSE_HTTP_SERVER        8 
.................... #define TCP_PURPOSE_DEFAULT            9 
.................... #define TCP_PURPOSE_BERKELEY_SERVER    10 
.................... #define TCP_PURPOSE_BERKELEY_CLIENT    11 
.................... #define TCP_PURPOSE_CCS_SMTP           0x40 
....................  
.................... typedef struct 
.................... { 
....................    BYTE vSocketPurpose; 
....................    BYTE vMemoryMedium; 
....................    WORD wTXBufferSize; 
....................    WORD wRXBufferSize; 
.................... } TCPSocketInitializer_t; 
....................  
.................... #if TCP_CONFIGURATION > 0 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................          {TCP_PURPOSE_HTTP_SERVER, TCP_ETH_RAM, STACK_CCS_HTTP2_SERVER_TX_SIZE, STACK_CCS_HTTP2_SERVER_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_SMTP_CLIENT) 
....................          {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, STACK_CCS_SMTP_TX_SIZE, STACK_CCS_SMTP_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_MY_TELNET_SERVER) 
....................          {TCP_PURPOSE_TELNET, TCP_ETH_RAM, STACK_MY_TELNET_SERVER_TX_SIZE, STACK_MY_TELNET_SERVER_RX_SIZE}, 
....................       #endif 
....................    }; 
.................... #else 
....................    #undef TCP_CONFIGURATION 
....................    #define TCP_CONFIGURATION 1 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, 250, 250} 
....................    }; 
.................... #endif 
....................  
.................... #ifndef MAX_HTTP_CONNECTIONS 
....................    #define  MAX_HTTP_CONNECTIONS 1 
.................... #endif 
.................... #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS 7 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/TCPIP Stack/HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk2.c" 
.................... // 'glue' file for using Microchip's TCP/IP stack inside CCS C Compiler without 
.................... // a linker.   
.................... // Also includes some macros/defines for porting older V3 stack to this current 
.................... // stack. 
.................... // Also provides extra routines written by CCS to improve the stack. 
.................... // 
.................... // __DISABLE_WIFI_INTERRUPT__ was supported in an older 5.3x version of the 
.................... // stack, but it is currently not supported anymore. 
....................  
.................... #ifndef __CCS_STACKTSK2_C__ 
.................... #define __CCS_STACKTSK2_C__ 
....................  
.................... #if defined(__DISABLE_WIFI_INTERRUPT__) 
....................    #error This has been removed. 
.................... #endif 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if defined(__PCH__) 
.................... #int_timer0 NOCLEAR 
.................... void ISRTimer0(void) 
.................... { 
....................    TickUpdate(); 
*
00D2:  BRA    00B4
.................... } 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && !defined(__DISABLE_WIFI_INTERRUPT__) 
.................... #int_EXT HIGH NOCLEAR 
....................    void ISREXT0(void) 
....................    { 
....................          WFEintISR(); 
....................        
....................    } 
.................... #endif 
....................  
.................... #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    int1 g_WifiAdhocIsConn = FALSE; 
....................    TICK g_WifiAdhocTickConn; 
....................    #define WIFIAdhocConnectionPing()   g_WifiAdhocIsConn=TRUE; g_WifiAdhocTickConn=TickGet() 
....................    #define WIFIAdhocConnectionReset()  g_WifiAdhocIsConn = FALSE 
.................... #endif 
....................  
.................... #if !defined(wf_debug_printf) 
....................    #define wf_debug_printf(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o) 
....................    #define wf_debug_putc(c) 
.................... #endif 
....................  
.................... #include "StackTsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *   TCP/IP Stack Manager 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Handles internal RX packet pre-processing prior to dispatching  
....................  *    to upper application layers. 
....................  *    -Reference: AN833 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    ARP, IP, Network layer interface (ENC28J60.c,  
....................  *               ETH97J60.c, ENCX24J600.c, or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  * 
....................  * Darren Rook/CCS       4/13/11    Added some CCS modules (see STACK_USE_CCS_*) 
....................  *                                  Added STACK_USE_CCS_RX_EVENT() macro on TCP/IP traffic.  
.................... ********************************************************************/ 
.................... #define __STACKTSK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
00D4:  GOTO   0054
.................... #if defined( WF_CS_TRIS ) 
....................     #if defined( WF_CONFIG_CONSOLE ) 
....................         #include "TCPIP Stack/WFConsole.h" 
....................     #endif 
....................     #if defined( STACK_USE_EZ_CONFIG ) || defined( EZ_CONFIG_SCAN ) 
....................         #include "TCPIP Stack/WFEasyConfig.h" 
....................     #endif 
....................    #include "TCPIP Stack/WFApi.h" 
.................... #endif 
....................  
.................... // Stack FSM states. 
.................... typedef enum 
.................... { 
....................     SM_STACK_IDLE, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
.................... BOOL g_DhcpRenew = FALSE; 
.................... extern void SetDhcpProgressState(void); 
.................... UINT32 g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................    static BOOL once = FALSE; 
....................     smStack                     = SM_STACK_IDLE; 
*
14AE:  MOVLB  1
14B0:  CLRF   x00
....................  
.................... #if defined(STACK_USE_IP_GLEANING) || defined(STACK_USE_DHCP_CLIENT) 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
14B2:  BSF    4E.7
....................  
.................... #endif 
....................  
.................... #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT) 
....................    g_DhcpRenew = FALSE; 
....................    g_DhcpRetryTimer = 0; 
.................... #endif 
....................  
....................    if (!once) { 
14B4:  BTFSC  x0B.0
14B6:  BRA    14E6
....................       // Seed the LFSRRand() function 
....................       LFSRSeedRand(GenerateRandomDWORD()); 
14B8:  MOVLB  0
14BA:  GOTO   03AA
14BE:  MOVFF  03,37E
14C2:  MOVFF  02,37D
14C6:  MOVFF  01,37C
14CA:  MOVFF  00,37B
14CE:  MOVFF  03,394
14D2:  MOVFF  02,393
14D6:  MOVFF  01,392
14DA:  MOVFF  00,391
14DE:  CALL   0348
....................       once = TRUE; 
14E2:  MOVLB  1
14E4:  BSF    x0B.0
....................    } 
....................  
....................     MACInit(); 
14E6:  MOVLB  0
14E8:  GOTO   0728
....................  
.................... #if defined (WF_AGGRESSIVE_PS) && defined (WF_CS_TRIS) 
....................    WFEnableAggressivePowerSave(); 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_EZ_CONFIG) && !defined(__18CXX) 
....................     WFEasyConfigInit(); 
.................... #endif     
....................  
....................     ARPInit(); 
....................  
.................... #if defined(STACK_USE_UDP) 
....................     UDPInit(); 
14EC:  GOTO   09D0
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................     TCPInit(); 
14F0:  BRA    11B6
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
....................    BerkeleySocketInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
....................     HTTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
....................    RSAInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
....................     SSLInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................     FTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    DHCPInit(0); 
14F2:  MOVLB  3
14F4:  CLRF   x9B
14F6:  MOVLB  0
14F8:  RCALL  1352
....................     if(!AppConfig.Flags.bIsDHCPEnabled) 
14FA:  BTFSC  4E.6
14FC:  BRA    1506
....................     { 
....................         DHCPDisable(0); 
14FE:  MOVLB  3
1500:  CLRF   x7B
1502:  MOVLB  0
1504:  BRA    1390
....................     } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     AutoIPInit(0); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
....................    RandomInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpInit(); 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPInit(); 
1506:  BRA    1426
.................... #endif 
....................  
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
1508:  GOTO   7BF8 (RETURN)
....................    TFTPSInit(); 
....................    #endif 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
....................     WORD dataCount; 
....................     IP_ADDR tempLocalIP; 
....................    BYTE cFrameType; 
....................    BYTE cIPFrameType; 
....................  
....................     
....................     #if defined( WF_CS_TRIS ) 
....................         // This task performs low-level MAC processing specific to the MRF24W 
....................         MACProcess(); 
....................         #if defined( STACK_USE_EZ_CONFIG ) && !defined(__18CXX) 
....................             WFEasyConfigMgr(); 
....................         #endif 
....................          
....................        #if defined(STACK_USE_DHCP_CLIENT) 
....................            // Normally, an application would not include  DHCP module 
....................            // if it is not enabled. But in case some one wants to disable 
....................            // DHCP module at run-time, remember to not clear our IP 
....................            // address if link is removed. 
....................            if(AppConfig.Flags.bIsDHCPEnabled) 
....................            { 
....................               if(g_DhcpRenew == TRUE) 
....................               { 
....................                  g_DhcpRenew = FALSE; 
....................                   AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
....................                  AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
....................                  AppConfig.Flags.bInConfigMode = TRUE; 
....................                  DHCPInit(0); 
....................                g_DhcpRetryTimer = (UINT32)TickGet(); 
....................               } else { 
....................                  if (g_DhcpRetryTimer && TickGet() - g_DhcpRetryTimer >= TICKS_PER_SECOND * 8) { 
....................                   DHCPInit(0); 
....................                   g_DhcpRetryTimer = (UINT32)TickGet(); 
....................                  } 
....................               } 
....................             
....................               // DHCP must be called all the time even after IP configuration is 
....................               // discovered. 
....................               // DHCP has to account lease expiration time and renew the configuration 
....................               // time. 
....................               DHCPTask(); 
....................                
....................               if(DHCPIsBound(0)) { 
....................                  AppConfig.Flags.bInConfigMode = FALSE; 
....................                g_DhcpRetryTimer = 0; 
....................               } 
....................            } 
....................        #endif // STACK_USE_DHCP_CLIENT 
....................          
....................     #endif // WF_CS_TRIS 
....................  
....................  
....................    #if defined(STACK_USE_DHCP_CLIENT) && !defined(WF_CS_TRIS) 
....................    // Normally, an application would not include  DHCP module 
....................    // if it is not enabled. But in case some one wants to disable 
....................    // DHCP module at run-time, remember to not clear our IP 
....................    // address if link is removed. 
....................    if(AppConfig.Flags.bIsDHCPEnabled) 
*
6D1C:  BTFSS  4E.6
6D1E:  BRA    6D94
....................    { 
....................       static BOOL bLastLinkState = FALSE; 
....................       BOOL bCurrentLinkState; 
....................        
....................       bCurrentLinkState = MACIsLinked(); 
6D20:  CALL   187A
6D24:  MOVLB  3
6D26:  BCF    x9A.0
6D28:  BTFSC  01.0
6D2A:  BSF    x9A.0
....................       if(bCurrentLinkState != bLastLinkState) 
6D2C:  CLRF   00
6D2E:  MOVLB  1
6D30:  BTFSC  x0B.1
6D32:  BSF    00.0
6D34:  MOVLB  3
6D36:  MOVF   x9A,W
6D38:  XORWF  00,W
6D3A:  ANDLW  01
6D3C:  BZ    6D7E
....................       { 
....................          bLastLinkState = bCurrentLinkState; 
6D3E:  MOVLB  1
6D40:  BCF    x0B.1
6D42:  MOVLB  3
6D44:  BTFSS  x9A.0
6D46:  BRA    6D4E
6D48:  MOVLB  1
6D4A:  BSF    x0B.1
6D4C:  MOVLB  3
....................          if(!bCurrentLinkState) 
6D4E:  BTFSC  x9A.0
6D50:  BRA    6D7E
....................          { 
....................             AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val; 
6D52:  MOVFF  39,25
6D56:  MOVFF  38,24
6D5A:  MOVFF  37,23
6D5E:  MOVFF  36,22
....................             AppConfig.MyMask.Val = AppConfig.DefaultMask.Val; 
6D62:  MOVFF  3D,29
6D66:  MOVFF  3C,28
6D6A:  MOVFF  3B,27
6D6E:  MOVFF  3A,26
....................             AppConfig.Flags.bInConfigMode = TRUE; 
6D72:  BSF    4E.7
....................             DHCPInit(0); 
6D74:  CLRF   x9B
6D76:  MOVLB  0
6D78:  CALL   1352
6D7C:  MOVLB  3
....................          } 
....................       } 
....................     
....................       // DHCP must be called all the time even after IP configuration is 
....................       // discovered. 
....................       // DHCP has to account lease expiration time and renew the configuration 
....................       // time. 
....................       DHCPTask(); 
6D7E:  MOVLB  0
6D80:  GOTO   2CEE
....................        
....................       if(DHCPIsBound(0)) 
6D84:  MOVLB  3
6D86:  CLRF   x9B
6D88:  MOVLB  0
6D8A:  GOTO   321C
6D8E:  MOVF   01,F
6D90:  BZ    6D94
....................          AppConfig.Flags.bInConfigMode = FALSE; 
6D92:  BCF    4E.7
....................    } 
....................    #endif 
....................     
....................  
....................     #if defined (STACK_USE_AUTO_IP) 
....................     AutoIPTasks(); 
....................     #endif 
....................  
....................    #if defined(STACK_USE_TCP) 
....................    // Perform all TCP time related tasks (retransmit, send acknowledge, close connection, etc) 
....................    TCPTick(); 
6D94:  GOTO   3FB0
....................    #endif 
....................  
....................  
....................    #if defined(STACK_USE_UDP) 
....................    UDPTask(); 
6D98:  GOTO   47F0
....................    #endif 
....................  
....................   #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    GratArpTask(); 
....................   #endif 
....................  
....................    // Process as many incomming packets as we can 
....................    while(1) 
....................    { 
....................       //if using the random module, generate entropy 
....................       #if defined(STACK_USE_RANDOM) 
....................          RandomAdd(remoteNode.MACAddr.v[5]); 
....................       #endif 
....................  
....................       // We are about to fetch a new packet, make sure that the  
....................       // UDP module knows that any old RX data it has laying  
....................       // around will now be gone. 
....................       #if defined(STACK_USE_UDP) 
....................          UDPDiscard(); 
6D9C:  CALL   28DA
....................       #endif 
....................  
....................       // Fetch a packet (throws old one away, if not thrown away  
....................       // yet) 
....................       if(!MACGetHeader(&remoteNode.MACAddr, &cFrameType)) 
6DA0:  MOVLW  01
6DA2:  MOVLB  3
6DA4:  MOVWF  x9C
6DA6:  MOVLW  05
6DA8:  MOVWF  x9B
6DAA:  MOVLW  03
6DAC:  MOVWF  x9E
6DAE:  MOVLW  98
6DB0:  MOVWF  x9D
6DB2:  MOVLB  0
6DB4:  GOTO   487A
6DB8:  MOVF   01,F
6DBA:  BNZ   6DBE
....................          break; 
6DBC:  BRA    6EFC
....................  
....................       // When using a WiFi module, filter out all incoming packets that have  
....................       // the same source MAC address as our own MAC address.  This is to  
....................       // prevent receiving and passing our own broadcast packets up to other  
....................       // layers and avoid, for example, having our own gratuitous ARPs get  
....................       // answered by ourself. 
....................       #if defined(WF_CS_TRIS) 
....................          if(memcmp((void*)&remoteNode.MACAddr, (void*)&AppConfig.MyMACAddr, 6) == 0u) 
....................             continue; 
....................       #endif 
....................        
....................       #if defined(STACK_USE_CCS_RX_EVENT) 
....................       STACK_USE_CCS_RX_EVENT();  //__CCS__ 
....................       #endif 
....................        
....................       // Dispatch the packet to the appropriate handler 
....................       switch(cFrameType) 
6DBE:  MOVLB  3
6DC0:  MOVF   x98,W
6DC2:  XORLW  06
6DC4:  MOVLB  0
6DC6:  BZ    6DCE
6DC8:  XORLW  06
6DCA:  BZ    6DD4
6DCC:  BRA    6EFA
....................       { 
....................          case MAC_ARP: 
....................             ARPProcess(); 
6DCE:  GOTO   4BB0
....................             break; 
6DD2:  BRA    6EFA
....................     
....................          case MAC_IP: 
....................             if(!IPGetHeader(&tempLocalIP, &remoteNode, &cIPFrameType, &dataCount)) 
6DD4:  MOVLW  03
6DD6:  MOVLB  3
6DD8:  MOVWF  x9C
6DDA:  MOVLW  94
6DDC:  MOVWF  x9B
6DDE:  MOVLW  01
6DE0:  MOVWF  x9E
6DE2:  MOVWF  x9D
6DE4:  MOVLW  03
6DE6:  MOVWF  xA0
6DE8:  MOVLW  99
6DEA:  MOVWF  x9F
6DEC:  MOVLW  03
6DEE:  MOVWF  xA2
6DF0:  MOVLW  92
6DF2:  MOVWF  xA1
6DF4:  MOVLB  0
6DF6:  GOTO   4D80
6DFA:  MOVF   01,F
6DFC:  BNZ   6E00
....................                break; 
6DFE:  BRA    6EFA
....................  
....................             #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................             if(cIPFrameType == IP_PROT_ICMP) 
6E00:  MOVLB  3
6E02:  DECFSZ x99,W
6E04:  BRA    6EAC
....................             { 
....................                #if defined(STACK_USE_IP_GLEANING) 
....................                if(AppConfig.Flags.bInConfigMode && AppConfig.Flags.bIsDHCPEnabled) 
....................                { 
....................                   // According to "IP Gleaning" procedure, 
....................                   // when we receive an ICMP packet with a valid 
....................                   // IP address while we are still in configuration 
....................                   // mode, accept that address as ours and conclude 
....................                   // configuration mode. 
....................                   if(tempLocalIP.Val != 0xffffffff) 
....................                   { 
....................                      AppConfig.Flags.bInConfigMode = FALSE; 
....................                      AppConfig.MyIPAddr = tempLocalIP; 
....................                   } 
....................                } 
....................                #endif 
....................  
....................                // Process this ICMP packet if it the destination IP address matches our address or one of the broadcast IP addressees 
....................                if( (tempLocalIP.Val == AppConfig.MyIPAddr.Val) || 
....................                   (tempLocalIP.Val == 0xFFFFFFFF) || 
.................... #if defined(STACK_USE_ZEROCONF_LINK_LOCAL) || defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................                                                 (tempLocalIP.Val == 0xFB0000E0) || 
.................... #endif 
....................                   (tempLocalIP.Val == ((AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) | ~AppConfig.MyMask.Val))) 
6E06:  MOVF   22,W
6E08:  SUBWF  x94,W
6E0A:  BNZ   6E1E
6E0C:  MOVF   23,W
6E0E:  SUBWF  x95,W
6E10:  BNZ   6E1E
6E12:  MOVF   24,W
6E14:  SUBWF  x96,W
6E16:  BNZ   6E1E
6E18:  MOVF   25,W
6E1A:  SUBWF  x97,W
6E1C:  BZ    6E90
6E1E:  INCFSZ x94,W
6E20:  BRA    6E30
6E22:  INCFSZ x95,W
6E24:  BRA    6E30
6E26:  INCFSZ x96,W
6E28:  BRA    6E30
6E2A:  INCFSZ x97,W
6E2C:  BRA    6E30
6E2E:  BRA    6E90
6E30:  MOVF   22,W
6E32:  ANDWF  26,W
6E34:  MOVWF  x9B
6E36:  MOVF   23,W
6E38:  ANDWF  27,W
6E3A:  MOVWF  x9C
6E3C:  MOVF   24,W
6E3E:  ANDWF  28,W
6E40:  MOVWF  x9D
6E42:  MOVF   25,W
6E44:  ANDWF  29,W
6E46:  MOVWF  x9E
6E48:  MOVFF  26,00
6E4C:  COMF   00,F
6E4E:  MOVFF  27,01
6E52:  COMF   01,F
6E54:  MOVFF  28,02
6E58:  COMF   02,F
6E5A:  MOVFF  29,03
6E5E:  COMF   03,F
6E60:  MOVF   00,W
6E62:  IORWF  x9B,W
6E64:  MOVWF  00
6E66:  MOVF   01,W
6E68:  IORWF  x9C,W
6E6A:  MOVWF  01
6E6C:  MOVF   02,W
6E6E:  IORWF  x9D,W
6E70:  MOVWF  02
6E72:  MOVF   03,W
6E74:  IORWF  x9E,W
6E76:  MOVWF  03
6E78:  MOVF   00,W
6E7A:  SUBWF  x94,W
6E7C:  BNZ   6EA6
6E7E:  MOVF   01,W
6E80:  SUBWF  x95,W
6E82:  BNZ   6EA6
6E84:  MOVF   02,W
6E86:  SUBWF  x96,W
6E88:  BNZ   6EA6
6E8A:  MOVF   03,W
6E8C:  SUBWF  x97,W
6E8E:  BNZ   6EA6
....................                { 
....................                   ICMPProcess(&remoteNode, dataCount); 
6E90:  MOVLW  01
6E92:  MOVWF  x9C
6E94:  MOVWF  x9B
6E96:  MOVFF  393,39E
6E9A:  MOVFF  392,39D
6E9E:  MOVLB  0
6EA0:  GOTO   4E86
6EA4:  MOVLB  3
....................                } 
....................  
....................                break; 
6EA6:  MOVLB  0
6EA8:  BRA    6EFA
6EAA:  MOVLB  3
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_TCP) 
....................             if(cIPFrameType == IP_PROT_TCP) 
6EAC:  MOVF   x99,W
6EAE:  SUBLW  06
6EB0:  BNZ   6ED0
....................             { 
....................                TCPProcess(&remoteNode, &tempLocalIP, dataCount); 
6EB2:  MOVLW  01
6EB4:  MOVWF  x9C
6EB6:  MOVWF  x9B
6EB8:  MOVLW  03
6EBA:  MOVWF  x9E
6EBC:  MOVLW  94
6EBE:  MOVWF  x9D
6EC0:  MOVFF  393,3A0
6EC4:  MOVFF  392,39F
6EC8:  MOVLB  0
6ECA:  BRA    6890
....................                break; 
6ECC:  BRA    6EFA
6ECE:  MOVLB  3
....................             } 
....................             #endif 
....................              
....................             #if defined(STACK_USE_UDP) 
....................             if(cIPFrameType == IP_PROT_UDP) 
6ED0:  MOVF   x99,W
6ED2:  SUBLW  11
6ED4:  BNZ   6EF8
....................             { 
....................                // Stop processing packets if we came upon a UDP frame with application data in it 
....................                if(UDPProcess(&remoteNode, &tempLocalIP, dataCount)) 
6ED6:  MOVLW  01
6ED8:  MOVWF  x9C
6EDA:  MOVWF  x9B
6EDC:  MOVLW  03
6EDE:  MOVWF  x9E
6EE0:  MOVLW  94
6EE2:  MOVWF  x9D
6EE4:  MOVFF  393,3A0
6EE8:  MOVFF  392,39F
6EEC:  MOVLB  0
6EEE:  BRA    6B92
6EF0:  MOVF   01,F
6EF2:  BZ    6EF6
....................                   return; 
6EF4:  BRA    6EFC
6EF6:  MOVLB  3
....................             } 
....................             #endif 
....................  
....................             break; 
6EF8:  MOVLB  0
....................       } 
6EFA:  BRA    6D9C
....................    } 
6EFC:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackApplications(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Calls all loaded application modules. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackApplications(void) 
.................... { 
....................    #if defined(STACK_USE_HTTP2_SERVER) 
....................    HTTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2) 
....................    FTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNMP_SERVER) 
....................    SNMPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_ANNOUNCE) 
....................    DiscoveryTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_NBNS) 
....................    NBNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DHCP_SERVER) 
....................    DHCPServerTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_DNS_SERVER) 
....................    DNSServerTask(); 
....................    #endif 
....................     
....................    #if defined (STACK_USE_DYNAMICDNS_CLIENT) 
....................    DDNSTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TELNET_SERVER) 
....................    TelnetTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_REBOOT_SERVER) 
....................    RebootTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SNTP_CLIENT) 
....................    SNTPClient(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
....................    UDPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
....................    TCPPerformanceTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SMTP_CLIENT) 
....................    SMTPTask(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_UART2TCP_BRIDGE) 
....................    UART2TCPBridgeTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_SMTP) 
....................    SMTPTask(); 
....................    #endif    
....................  
....................    #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    NTPTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_CCS_HTTP1_SERVER) || defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    HTTPServer(); 
....................    #endif 
....................     
....................    #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    TFTPSTask(); 
....................    #endif 
....................  
....................    #if defined(STACK_USE_TWITTER)   //should be renamed STACK_USE_CCS_TWITTER 
....................    TwitterTask();         // processes TCP tasks including the Tweet tasks 
....................    #endif    
.................... } 
....................  
.................... #if defined(WF_CS_TRIS) && defined(STACK_USE_DHCP_CLIENT) 
.................... void RenewDhcp(void) 
.................... { 
....................     g_DhcpRenew = TRUE; 
....................     SetDhcpProgressState(); 
.................... }     
....................      
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "Helpers.c" 
.................... /********************************************************************* 
....................   
....................  Helper Functions for Microchip TCPIP Stack 
....................   
....................  FileName:      Helpers.c 
....................  Dependencies:  See INCLUDES section 
....................  Processor:     PIC18, PIC24, dsPIC, PIC32 
....................  Compiler:      Microchip C18, C30, C32 
....................  Company:       Microchip Technology, Inc. 
....................  
....................  Software License Agreement 
....................  
....................  Copyright (C) 2002-2011 Microchip Technology Inc.  All rights 
....................  reserved. 
....................  
....................  Microchip licenses to you the right to use, modify, copy, and 
....................  distribute: 
....................  (i)  the Software when embedded on a Microchip microcontroller or 
....................       digital signal controller product ("Device") which is 
....................       integrated into Licensee's product; or 
....................  (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................       ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................       used in conjunction with a Microchip ethernet controller for 
....................       the sole purpose of interfacing with the ethernet controller. 
....................  
....................  You should refer to the license agreement accompanying this 
....................  Software for additional information regarding your rights and 
....................  obligations. 
....................  
....................  THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  
....................  ******************************************************************** 
....................  File Description: 
....................   
....................  Change History: 
....................   
....................   Rev         Description 
....................   ----------  ------------------------------------------------------- 
....................   1.0 - 5.31  Initial release; Rewritten CalcIPChecksum() to avoid 
....................               multi-byte shift operation; Added hexatob(), 
....................               btohexa_high(), and btohexa_low(); Optimized swapl(); 
....................               Added leftRotateDWORD() 
....................   5.36        Updated compile time check for ultoa(); 
....................  
....................    DARREN ROOK/CCS   Remove leftRotateDWORD() 
....................  
....................  ********************************************************************/ 
.................... #define __HELPERS_C 
....................  
.................... #include <stdarg.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDARG 
....................  
.................... #define _STDARG 
....................  
.................... typedef char * va_list; 
....................  
.................... #define va_start(a,b)  a=_VA_LIST 
.................... #define va_arg(a,b)    *(b *)_va_arg(a) 
.................... #define va_end 
.................... #define nargs          _nargs(&_va_list) 
....................  
.................... int8 _nargs(int8 * ptr) { 
....................   int8 n; 
....................  
....................   n=0; 
....................   while(*ptr) { 
....................     n++; 
....................     ptr+=*ptr; 
....................   } 
....................   return(n); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
....................  
.................... // Default Random Number Generator seed. 0x41FE9F9E corresponds to calling LFSRSeedRand(1) 
.................... static DWORD dwLFSRRandSeed = 0x41FE9F9E; 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD LFSRSeedRand(DWORD dwSeed) 
....................  
....................   Summary: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Description: 
....................    Seeds the LFSR random number generator invoked by the LFSRRand() function.   
....................    The prior seed is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    wSeed - The new 32-bit seed value to assign to the LFSR. 
....................  
....................   Returns: 
....................      The last seed in use.  This can be saved and restored by a subsequent call  
....................    to LFSRSeedRand() if you wish to use LFSRRand() in multiple contexts  
....................    without disrupting the random number sequence from the alternative  
....................    context.  For example, if App 1 needs a given sequence of random numbers  
....................    to perform a test, if you save and restore the seed in App 2, it is  
....................    possible for App 2 to not disrupt the random number sequence provided to  
....................    App 1, even if the number of times App 2 calls LFSRRand() varies. 
....................       
....................   Side Effects: 
....................    None 
....................     
....................   Remarks: 
....................    Upon initial power up, the internal seed is initialized to 0x1.  Using a  
....................    dwSeed value of 0x0 will return the same sequence of random numbers as  
....................    using the seed of 0x1. 
....................   ***************************************************************************/ 
.................... DWORD LFSRSeedRand(DWORD dwSeed) 
.................... { 
....................    DWORD dwOldSeed; 
....................    BYTE i; 
....................  
....................    // Save original seed to be returned later 
....................    dwOldSeed = dwLFSRRandSeed; 
*
0348:  MOVFF  10F,398
034C:  MOVFF  10E,397
0350:  MOVFF  10D,396
0354:  MOVFF  10C,395
....................  
....................    // Ensure zero isn't selected as a seed value, this would result in all  
....................    // 0x0000 output values from the LFSR 
....................    if(dwSeed == 0u) 
0358:  MOVLB  3
035A:  MOVF   x91,F
035C:  BNZ   0374
035E:  MOVF   x92,F
0360:  BNZ   0374
0362:  MOVF   x93,F
0364:  BNZ   0374
0366:  MOVF   x94,F
0368:  BNZ   0374
....................       dwSeed = 1; 
036A:  CLRF   x94
036C:  CLRF   x93
036E:  CLRF   x92
0370:  MOVLW  01
0372:  MOVWF  x91
....................        
....................    // Set the new seed 
....................    dwLFSRRandSeed = dwSeed; 
0374:  MOVFF  394,10F
0378:  MOVFF  393,10E
037C:  MOVFF  392,10D
0380:  MOVFF  391,10C
....................     
....................    // Run the LFSR a few times to get rid of obvious start up artifacts for  
....................    // seed values that don't have many set bits. 
....................    for(i = 0; i < 16; i++) 
0384:  CLRF   x99
0386:  MOVF   x99,W
0388:  SUBLW  0F
038A:  BNC   0396
....................       LFSRRand(); 
038C:  MOVLB  0
038E:  RCALL  02A8
0390:  MOVLB  3
0392:  INCF   x99,F
0394:  BRA    0386
....................     
....................    // Return saved old seed 
....................    return dwOldSeed; 
0396:  MOVFF  395,00
039A:  MOVFF  396,01
039E:  MOVFF  397,02
03A2:  MOVFF  398,03
03A6:  MOVLB  0
03A8:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD LFSRRand(void) 
....................  
....................   Summary: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF). 
....................  
....................   Description: 
....................    Returns a pseudo-random 16-bit unsigned integer in the range from 0  
....................    to 65535 (0x0000 to 0xFFFF).  The random number is generated using a  
....................    Linear Feedback Shift Register (LFSR) type pseudo-random number generator  
....................    algorithm.  The LFSR can be seeded by calling the LFSRSeedRand() function 
....................    to generate the same sequence of random numbers as a prior string of calls. 
....................     
....................    The internal LFSR will repeat after 2^32-1 iterations. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 16-bit unsigned integer. 
....................       
....................   Side Effects: 
....................    The internal LFSR seed is updated so that the next call to LFSRRand()  
....................    will return a different random number. 
....................     
....................   Remarks: 
....................    None 
....................   ***************************************************************************/ 
.................... WORD LFSRRand(void) 
.................... { 
....................    BYTE i; 
....................     
....................    // Taps: 32 31 29 1 
....................    // Characteristic polynomial: x^32 + x^31 + x^29 + x + 1 
....................    // Repeat 15 times to make the shift pattern less obvious 
....................    for(i = 0; i < 15; i++) 
*
02A8:  MOVLB  3
02AA:  CLRF   xEA
02AC:  MOVF   xEA,W
02AE:  SUBLW  0E
02B0:  BNC   033A
....................       dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul); 
02B2:  BCF    FD8.0
02B4:  MOVLB  1
02B6:  RRCF   x0F,W
02B8:  MOVLB  3
02BA:  MOVWF  xEF
02BC:  MOVLB  1
02BE:  RRCF   x0E,W
02C0:  MOVLB  3
02C2:  MOVWF  xEE
02C4:  MOVLB  1
02C6:  RRCF   x0D,W
02C8:  MOVLB  3
02CA:  MOVWF  xED
02CC:  MOVLB  1
02CE:  RRCF   x0C,W
02D0:  MOVLB  3
02D2:  MOVWF  xEC
02D4:  MOVLB  1
02D6:  MOVF   x0C,W
02D8:  ANDLW  01
02DA:  MOVWF  00
02DC:  CLRF   01
02DE:  CLRF   02
02E0:  CLRF   03
02E2:  MOVLW  00
02E4:  BSF    FD8.0
02E6:  SUBFWB 00,W
02E8:  MOVLB  3
02EA:  MOVWF  xF0
02EC:  MOVLW  00
02EE:  SUBFWB 01,W
02F0:  MOVWF  xF1
02F2:  MOVLW  00
02F4:  SUBFWB 02,W
02F6:  MOVWF  xF2
02F8:  MOVLW  00
02FA:  SUBFWB 03,W
02FC:  MOVWF  xF3
02FE:  MOVF   xF0,W
0300:  ANDLW  01
0302:  MOVWF  00
0304:  CLRF   01
0306:  CLRF   02
0308:  MOVF   xF3,W
030A:  ANDLW  D0
030C:  MOVWF  03
030E:  MOVF   00,W
0310:  XORWF  xEC,W
0312:  MOVLB  1
0314:  MOVWF  x0C
0316:  MOVF   01,W
0318:  MOVLB  3
031A:  XORWF  xED,W
031C:  MOVLB  1
031E:  MOVWF  x0D
0320:  MOVF   02,W
0322:  MOVLB  3
0324:  XORWF  xEE,W
0326:  MOVLB  1
0328:  MOVWF  x0E
032A:  MOVF   03,W
032C:  MOVLB  3
032E:  XORWF  xEF,W
0330:  MOVLB  1
0332:  MOVWF  x0F
0334:  MOVLB  3
0336:  INCF   xEA,F
0338:  BRA    02AC
....................  
....................    // Return 16-bits as pseudo-random number 
....................    return (WORD)dwLFSRRandSeed; 
033A:  MOVLB  1
033C:  MOVFF  10C,01
0340:  MOVFF  10D,02
0344:  MOVLB  0
0346:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD GenerateRandomDWORD(void) 
....................  
....................   Summary: 
....................    Generates a random DWORD. 
....................  
....................   Description: 
....................    This function generates a random 32-bit integer.  It collects 
....................    randomness by comparing the A/D converter's internal R/C oscillator 
....................    clock with our main system clock.  By passing collected entropy to the 
....................    LFSRSeedRand()/LFSRRand() functions, the output is normalized (deskewed)  
....................    in the hopes of meeting statistical randomness tests. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      Random 32-bit number. 
....................       
....................   Side Effects: 
....................    This function uses the A/D converter (and so you must disable  
....................    interrupts if you use the A/D converted in your ISR).  The LFSRRand()  
....................    function will be reseeded, and Timer0 (PIC18) and Timer1 (PIC24,  
....................    dsPIC, and PIC32) will be used.  TMR#H:TMR#L will have a new value. 
....................    Note that this is the same timer used by the Tick module. 
....................     
....................   Remarks: 
....................    This function times out after 1 second of attempting to generate the  
....................    random DWORD.  In such a case, the output may not be truly random.   
....................    Typically, this function executes in around 500,000 instruction cycles. 
....................     
....................    The intent of this function is to produce statistically random and 
....................    cryptographically secure random number.  Whether or not this is true on 
....................    all (or any) devices/voltages/temperatures is not tested. 
....................   ***************************************************************************/ 
.................... DWORD GenerateRandomDWORD(void) 
.................... { 
....................    BYTE vBitCount; 
....................    WORD w, wTime, wLastValue; 
....................    DWORD dwTotalTime; 
....................    union 
....................    { 
....................       DWORD   dw; 
....................       WORD   w[2]; 
....................    } randomResult; 
....................  
.................... #if defined __18CXX    
.................... { 
....................    BYTE ADCON0Save, ADCON2Save; 
....................    BYTE T0CONSave, TMR0HSave, TMR0LSave; 
....................  
....................    // Save hardware SFRs 
....................    ADCON0Save = ADCON0; 
*
03AA:  MOVFF  FC2,38A
....................    ADCON2Save = ADCON2; 
03AE:  MOVFF  FC0,38B
....................    T0CONSave = T0CON; 
03B2:  MOVFF  FD5,38C
....................    TMR0LSave = TMR0L; 
03B6:  MOVFF  FD6,38E
....................    TMR0HSave = TMR0H; 
03BA:  MOVFF  FD7,38D
....................  
....................    // Set up Timer and A/D converter module 
....................    ADCON0 = 0x01;   // Turn on the A/D module 
03BE:  MOVLW  01
03C0:  MOVWF  FC2
....................    ADCON2 = 0x3F;   // 20 Tad acquisition, Frc A/D clock used for conversion 
03C2:  MOVLW  3F
03C4:  MOVWF  FC0
....................    T0CON = 0x88;   // TMR0ON = 1, no prescalar 
03C6:  MOVLW  88
03C8:  MOVWF  FD5
....................    vBitCount = 0; 
03CA:  MOVLB  3
03CC:  CLRF   x7B
....................    dwTotalTime = 0; 
03CE:  CLRF   x85
03D0:  CLRF   x84
03D2:  CLRF   x83
03D4:  CLRF   x82
....................    wLastValue = 0; 
03D6:  CLRF   x81
03D8:  CLRF   x80
....................    randomResult.dw = LFSRRand(); 
03DA:  MOVLB  0
03DC:  RCALL  02A8
03DE:  MOVLB  3
03E0:  CLRF   x89
03E2:  CLRF   x88
03E4:  MOVFF  02,387
03E8:  MOVFF  01,386
....................    while(1) 
....................    { 
....................       // Time the duration of an A/D acquisition and conversion 
....................       TMR0H = 0x00; 
03EC:  CLRF   FD7
....................       TMR0L = 0x00; 
03EE:  CLRF   FD6
....................       ADCON0bits.GO = 1; 
03F0:  BSF    FC2.1
....................       ClrWdt(); 
03F2:  CLRWDT
....................       while(ADCON0bits.GO); 
03F4:  BTFSC  FC2.1
03F6:  BRA    03F4
....................       ((BYTE*)&wTime)[0] = TMR0L; 
03F8:  MOVFF  FD6,37E
....................       ((BYTE*)&wTime)[1] = TMR0H; 
03FC:  MOVFF  FD7,37F
....................       w = LFSRRand(); 
0400:  MOVLB  0
0402:  RCALL  02A8
0404:  MOVFF  02,37D
0408:  MOVFF  01,37C
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
040C:  MOVLB  3
040E:  MOVF   x7E,W
0410:  ADDWF  x82,F
0412:  MOVF   x7F,W
0414:  ADDWFC x83,F
0416:  MOVLW  00
0418:  ADDWFC x84,F
041A:  ADDWFC x85,F
....................       if(dwTotalTime >= GetInstructionClock()) 
041C:  MOVF   x85,F
041E:  BNZ   043A
0420:  MOVF   x84,W
0422:  SUBLW  1D
0424:  BC    0458
0426:  XORLW  FF
0428:  BNZ   043A
042A:  MOVF   x83,W
042C:  SUBLW  83
042E:  BC    0458
0430:  XORLW  FF
0432:  BNZ   043A
0434:  MOVF   x82,W
0436:  SUBLW  7F
0438:  BC    0458
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
043A:  MOVLB  0
043C:  RCALL  02A8
043E:  MOVF   01,W
0440:  MOVLB  3
0442:  XORWF  x86,F
0444:  MOVF   02,W
0446:  XORWF  x87,F
....................          randomResult.w[1] ^= LFSRRand(); 
0448:  MOVLB  0
044A:  RCALL  02A8
044C:  MOVF   01,W
044E:  MOVLB  3
0450:  XORWF  x88,F
0452:  MOVF   02,W
0454:  XORWF  x89,F
....................          break; 
0456:  BRA    04C6
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
0458:  MOVF   x7E,W
045A:  SUBWF  x80,W
045C:  BNZ   0466
045E:  MOVF   x7F,W
0460:  SUBWF  x81,W
0462:  BNZ   0466
....................          continue; 
0464:  BRA    03EC
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
0466:  MOVF   x7E,W
0468:  SUBWF  x80,W
046A:  MOVWF  00
046C:  MOVF   x7F,W
046E:  SUBWFB x81,W
0470:  MOVWF  03
0472:  MOVF   00,W
0474:  ADDWF  x7C,W
0476:  MOVWF  x8F
0478:  MOVF   03,W
047A:  ADDWFC x7D,W
047C:  MOVWF  x90
047E:  CLRF   x94
0480:  CLRF   x93
0482:  MOVWF  x92
0484:  MOVFF  38F,391
0488:  MOVLB  0
048A:  RCALL  0348
....................       wLastValue = wTime; 
048C:  MOVFF  37F,381
0490:  MOVFF  37E,380
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
0494:  BCF    FD8.0
0496:  MOVLB  3
0498:  RLCF   x86,F
049A:  RLCF   x87,F
049C:  RLCF   x88,F
049E:  RLCF   x89,F
....................       if(LFSRRand() & 0x0080) 
04A0:  MOVLB  0
04A2:  RCALL  02A8
04A4:  MOVFF  02,390
04A8:  MOVFF  01,38F
04AC:  MOVLB  3
04AE:  MOVF   01,W
04B0:  ANDLW  80
04B2:  MOVWF  00
04B4:  CLRF   03
04B6:  MOVF   00,W
04B8:  IORWF  03,W
04BA:  BZ    04BE
....................          randomResult.w[0] |= 0x1; 
04BC:  BSF    x86.0
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
04BE:  INCF   x7B,F
04C0:  BNZ   04C4
....................          break; 
04C2:  BRA    04C6
04C4:  BRA    03EC
....................    } 
....................  
....................    // Restore hardware SFRs 
....................    ADCON0 = ADCON0Save; 
04C6:  MOVFF  38A,FC2
....................    ADCON2 = ADCON2Save; 
04CA:  MOVFF  38B,FC0
....................    TMR0H = TMR0HSave; 
04CE:  MOVFF  38D,FD7
....................    TMR0L = TMR0LSave; 
04D2:  MOVFF  38E,FD6
....................    T0CON = T0CONSave; 
04D6:  MOVFF  38C,FD5
.................... } 
.................... #else 
.................... { 
....................    WORD AD1CON1Save, AD1CON2Save, AD1CON3Save; 
....................    WORD T1CONSave, PR1Save; 
....................  
....................    // Save hardware SFRs 
....................    AD1CON1Save = AD1CON1; 
....................    AD1CON2Save = AD1CON2; 
....................    AD1CON3Save = AD1CON3; 
....................    T1CONSave = T1CON; 
....................    PR1Save = PR1; 
....................  
....................    // Set up Timer and A/D converter module 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = 0x9F00;      // Frc A/D clock, 31 Tad acquisition 
....................    AD1CON2 = 0x003F;      // Interrupt after every 16th sample/convert 
....................    AD1CON1 = 0x80E4;      // Turn on the A/D module, auto-convert 
....................    T1CON = 0x8000;         // TON = 1, no prescalar 
....................    PR1 = 0xFFFF;         // Don't clear timer early 
....................    vBitCount = 0; 
....................    dwTotalTime = 0; 
....................    wLastValue = 0; 
....................    randomResult.dw = LFSRRand(); 
....................    while(1) 
....................    { 
....................       ClrWdt(); 
....................       #if defined(__C30__) 
....................          while(!IFS0bits.AD1IF); 
....................       #else 
....................          while(!IFS1bits.AD1IF); 
....................       #endif 
....................       wTime = TMR1; 
....................       TMR1 = 0x0000; 
....................  
....................       #if defined(__C30__) 
....................          IFS0bits.AD1IF = 0; 
....................       #else 
....................          IFS1CLR = _IFS1_AD1IF_MASK; 
....................       #endif 
....................       w = LFSRRand(); 
....................     
....................       // Wait no longer than 1 second obtaining entropy 
....................       dwTotalTime += wTime; 
....................       if(dwTotalTime >= GetInstructionClock()) 
....................       { 
....................          randomResult.w[0] ^= LFSRRand(); 
....................          randomResult.w[1] ^= LFSRRand(); 
....................          break; 
....................       } 
....................     
....................       // Keep sampling if minimal entropy was likely obtained this round 
....................       if(wLastValue == wTime) 
....................          continue; 
....................     
....................       // Add this entropy into the pseudo random number generator by reseeding 
....................       LFSRSeedRand(w + (wLastValue - wTime)); 
....................       wLastValue = wTime; 
....................     
....................       // Accumulate at least 32 bits of randomness over time 
....................       randomResult.dw <<= 1; 
....................       if(LFSRRand() & 0x0080) 
....................          randomResult.w[0] |= 0x1; 
....................     
....................       // See if we've collected a fair amount of entropy and can quit early 
....................       if(++vBitCount == 0u) 
....................          break; 
....................    } 
....................  
....................  
....................    // Restore hardware SFRs 
....................    AD1CON1 = 0x0000;      // Turn off the ADC so we can write to it 
....................    AD1CON3 = AD1CON3Save; 
....................    AD1CON2 = AD1CON2Save; 
....................    AD1CON1 = AD1CON1Save; 
....................    T1CON = T1CONSave; 
....................    PR1 = PR1Save; 
.................... } 
.................... #endif 
....................  
....................    return randomResult.dw; 
04DA:  MOVFF  386,00
04DE:  MOVFF  387,01
04E2:  MOVFF  388,02
04E6:  MOVFF  389,03
04EA:  MOVLB  0
04EC:  GOTO   14BE (RETURN)
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_HTTP_SERVER) 
.................... /***************************************************************************** 
....................   Function: 
....................    void UnencodeURL(BYTE* URL) 
....................  
....................   Summary: 
....................    Decodes a URL-encoded string. 
....................  
....................   Description: 
....................    This function is deprecated except for use with HTTP Classic.  It 
....................    attempts to decode a URL encoded string, converting all hex escape 
....................    sequences into a literal byte.  However, it is inefficient over long 
....................    strings and does not handle URL-encoded data strings ('&' and '='). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    URL - the null-terminated string to decode 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UnencodeURL(BYTE* URL) 
.................... { 
....................    BYTE *Right, *Copy; 
....................    WORD_VAL Number; 
....................  
....................    while((Right = (BYTE*)strchr((char*)URL, '%'))) 
....................    { 
....................       // Make sure the string is long enough 
....................       if(Right[1] == '\0') 
....................          break; 
....................       if(Right[2] == '\0') 
....................          break; 
....................  
....................       // Update the string in place 
....................       Number.v[0] = Right[2]; 
....................       Number.v[1] = Right[1]; 
....................       *Right++ = hexatob(Number); 
....................       URL = Right; 
....................  
....................       // Remove two blank spots by shifting all remaining characters right two 
....................       Copy = Right + 2; 
....................       while((*Right++ = *Copy++)); 
....................    } 
.................... }           
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................   ***************************************************************************/ 
.................... BOOL StringToIPAddress(BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
....................    currentOctet = 0; 
....................    dwVal.Val = 0; 
....................    while((i = *str++)) 
....................    { 
....................       if(currentOctet > 3u) 
....................          break; 
....................  
....................       i -= '0'; 
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
....................       { 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................       else if(charLen == 3u) 
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
....................             return FALSE; 
....................  
....................          if(dwVal.Val > 0x00020505ul) 
....................             return FALSE; 
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................          charLen = 0; 
....................          dwVal.Val = 0; 
....................          continue; 
....................       } 
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
....................                return FALSE; 
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................             charLen = 0; 
....................             dwVal.Val = 0; 
....................             continue; 
....................          } 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................  
....................       charLen++; 
....................       dwVal.Val <<= 8; 
....................       dwVal.v[0] = i; 
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t' && i != ':') 
....................       return FALSE; 
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
....................       return FALSE; 
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................  
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
....................  
....................   Summary: 
....................    Converts a string to an IP address 
....................  
....................   Description: 
....................    This function parses a dotted-quad decimal IP address string into an  
....................    IP_ADDR struct.  The output result is big-endian. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    str - Pointer to a dotted-quad IP address string 
....................    IPAddress - Pointer to IP_ADDR in which to store the result 
....................  
....................   Return Values: 
....................      TRUE - an IP address was successfully decoded 
....................      FALSE - no IP address could be found, or the format was incorrect 
....................    
....................   Remarks: 
....................    This function is aliased to StringToIPAddress on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... BOOL ROMStringToIPAddress(ROM BYTE* str, IP_ADDR* IPAddress) 
.................... { 
....................    DWORD_VAL dwVal; 
....................    BYTE i, charLen, currentOctet; 
....................  
....................    charLen = 0; 
....................    currentOctet = 0; 
....................    dwVal.Val = 0; 
....................    while(i = *str++) 
....................    { 
....................       if(currentOctet > 3u) 
....................          break; 
....................  
....................       i -= '0'; 
....................        
....................  
....................       // Validate the character is a numerical digit or dot, depending on location 
....................       if(charLen == 0u) 
....................       { 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................       else if(charLen == 3u) 
....................       { 
....................          if(i != (BYTE)('.' - '0')) 
....................             return FALSE; 
....................  
....................          if(dwVal.Val > 0x00020505ul) 
....................             return FALSE; 
....................  
....................          IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................          charLen = 0; 
....................          dwVal.Val = 0; 
....................          continue; 
....................       } 
....................       else 
....................       { 
....................          if(i == (BYTE)('.' - '0')) 
....................          { 
....................             if(dwVal.Val > 0x00020505ul) 
....................                return FALSE; 
....................  
....................             IPAddress->v[currentOctet++] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................             charLen = 0; 
....................             dwVal.Val = 0; 
....................             continue; 
....................          } 
....................          if(i > 9u) 
....................             return FALSE; 
....................       } 
....................  
....................       charLen++; 
....................       dwVal.Val <<= 8; 
....................       dwVal.v[0] = i; 
....................    } 
....................  
....................    // Make sure the very last character is a valid termination character  
....................    // (i.e., not more hostname, which could be legal and not an IP  
....................    // address as in "10.5.13.233.picsaregood.com" 
....................    if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t') 
....................       return FALSE; 
....................  
....................    // Verify and convert the last octet and return the result 
....................    if(dwVal.Val > 0x00020505ul) 
....................       return FALSE; 
....................  
....................    IPAddress->v[3] = dwVal.v[2]*((BYTE)100) + dwVal.v[1]*((BYTE)10) + dwVal.v[0]; 
....................  
....................    return TRUE; 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen,  
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Decodes a Base-64 array to its literal representation. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of Base-64 encoded data 
....................    wSourceLen   - Length of the Base-64 source data 
....................    cDestData   - Pointer to write the decoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of decoded bytes written to cDestData. 
....................    
....................   Remarks: 
....................    This function is binary safe and will ignore invalid characters (CR, LF,  
....................    etc).  If cSourceData is equal to cDestData, the data will be converted 
....................    in-place.  If cSourceData is not equal to cDestData, but the regions  
....................    overlap, the behavior is undefined. 
....................     
....................    Decoded data is always at least 1/4 smaller than the source data. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_DECODE) 
.................... WORD Base64Decode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i; 
....................    BYTE vByteNumber; 
....................    WORD wBytesOutput; 
....................  
....................    vByteNumber = 0; 
....................    wBytesOutput = 0; 
....................  
....................    // Loop over all provided bytes 
....................    while(wSourceLen--) 
....................    { 
....................       // Fetch a Base64 byte and decode it to the original 6 bits 
....................       i = *cSourceData++; 
....................       if(i >= 'A' && i <= 'Z')   // Regular data 
....................          i -= 'A' - 0; 
....................       else if(i >= 'a' && i <= 'z') 
....................          i -= 'a' - 26; 
....................       else if(i >= '0' && i <= '9') 
....................          i -= '0' - 52; 
....................       else if(i == '+' || i == '-') 
....................          i = 62; 
....................       else if(i == '/' || i == '_') 
....................          i = 63; 
....................       else                   // Skip all padding (=) and non-Base64 characters 
....................          continue; 
....................  
....................  
....................       // Write the 6 bits to the correct destination location(s) 
....................       if(vByteNumber == 0u) 
....................       { 
....................          vByteNumber++; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 2; 
....................       } 
....................       else if(vByteNumber == 1u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 4; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 4; 
....................       } 
....................       else if(vByteNumber == 2u) 
....................       { 
....................          vByteNumber++; 
....................          *cDestData++ |= i >> 2; 
....................          if(wBytesOutput >= wDestLen) 
....................             break; 
....................          wBytesOutput++; 
....................          *cDestData = i << 6; 
....................       } 
....................       else 
....................       { 
....................          vByteNumber = 0; 
....................          *cDestData++ |= i; 
....................       } 
....................    } 
....................  
....................    return wBytesOutput; 
.................... } 
.................... #endif   // #if defined(STACK_USE_BASE64_DECODE) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, 
....................                   BYTE* cDestData, WORD wDestLen) 
....................  
....................   Description: 
....................    Encodes a binary array to Base-64. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    cSourceData - Pointer to a string of binary data 
....................    wSourceLen   - Length of the binary source data 
....................    cDestData   - Pointer to write the Base-64 encoded data 
....................    wSourceLen   - Maximum length that can be written to cDestData 
....................  
....................   Returns: 
....................      Number of encoded bytes written to cDestData.  This will always be 
....................      a multiple of 4. 
....................    
....................   Remarks: 
....................    Encoding cannot be performed in-place.  If cSourceData overlaps with  
....................    cDestData, the behavior is undefined. 
....................     
....................    Encoded data is always at least 1/3 larger than the source data.  It may 
....................    be 1 or 2 bytes larger than that. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP_CLIENT) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... WORD Base64Encode(BYTE* cSourceData, WORD wSourceLen, BYTE* cDestData, WORD wDestLen) 
.................... { 
....................    BYTE i, j; 
....................    BYTE vOutput[4]; 
....................    WORD wOutputLen; 
....................  
....................    wOutputLen = 0; 
....................    while(wDestLen >= 4u) 
....................    { 
....................       // Start out treating the output as all padding 
....................       vOutput[0] = 0xFF; 
....................       vOutput[1] = 0xFF; 
....................       vOutput[2] = 0xFF; 
....................       vOutput[3] = 0xFF; 
....................  
....................       // Get 3 input octets and split them into 4 output hextets (6-bits each)  
....................       if(wSourceLen == 0u) 
....................          break; 
....................       i = *cSourceData++; 
....................       wSourceLen--; 
....................       vOutput[0] = (i & 0xFC)>>2; 
....................       vOutput[1] = (i & 0x03)<<4; 
....................       if(wSourceLen) 
....................       { 
....................          i = *cSourceData++; 
....................          wSourceLen--; 
....................          vOutput[1] |= (i & 0xF0)>>4; 
....................          vOutput[2] = (i & 0x0F)<<2; 
....................          if(wSourceLen) 
....................          { 
....................             i = *cSourceData++; 
....................             wSourceLen--; 
....................             vOutput[2] |= (i & 0xC0)>>6; 
....................             vOutput[3] = i & 0x3F; 
....................          } 
....................       } 
....................     
....................       // Convert hextets into Base 64 alphabet and store result 
....................       for(i = 0; i < 4u; i++) 
....................       { 
....................          j = vOutput[i]; 
....................  
....................          if(j <= 25u) 
....................             j += 'A' - 0; 
....................          else if(j <= 51u) 
....................             j += 'a' - 26; 
....................          else if(j <= 61u) 
....................             j += '0' - 52; 
....................          else if(j == 62u) 
....................             j = '+'; 
....................          else if(j == 63u) 
....................             j = '/'; 
....................          else            // Padding 
....................             j = '='; 
....................  
....................          *cDestData++ = j; 
....................       } 
....................  
....................       // Update counters 
....................       wDestLen -= 4; 
....................       wOutputLen += 4; 
....................    } 
....................  
....................    return wOutputLen; 
.................... } 
.................... #endif // #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP) || defined(STACK_USE_DYNAMICDNS_CLIENT) 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void uitoa(WORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 16-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void uitoa(WORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    WORD Digit; 
....................    WORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 10000; i < 5u; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... }              
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ultoa(DWORD Value, BYTE* Buffer) 
....................  
....................   Summary: 
....................    Converts an unsigned integer to a decimal string. 
....................     
....................   Description: 
....................    Converts a 32-bit unsigned integer to a null-terminated decimal string. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Value   - The number to be converted 
....................    Buffer   - Pointer in which to store the converted string 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... // HI-TECH PICC-18 PRO 9.63, C30 v3.25, and C32 v1.12 already have a ultoa() library function 
.................... // C18 already has a ultoa() function that more-or-less matches this one 
.................... // C32 < 1.12 and C30 < v3.25 need this function 
.................... #if (defined(__PIC32MX__) && (__C32_VERSION__ < 112)) || (defined (__C30__) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__) 
.................... void ultoa(DWORD Value, BYTE* Buffer) 
.................... { 
....................    BYTE i; 
....................    DWORD Digit; 
....................    DWORD Divisor; 
....................    BOOL Printed = FALSE; 
....................  
....................    if(Value) 
....................    { 
....................       for(i = 0, Divisor = 1000000000; i < 10; i++) 
....................       { 
....................          Digit = Value/Divisor; 
....................          if(Digit || Printed) 
....................          { 
....................             *Buffer++ = '0' + Digit; 
....................             Value -= Digit*Divisor; 
....................             Printed = TRUE; 
....................          } 
....................          Divisor /= 10; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       *Buffer++ = '0'; 
....................    } 
....................  
....................    *Buffer = '\0'; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE hexatob(WORD_VAL AsciiChars) 
....................  
....................   Summary: 
....................    Converts a hex string to a single byte. 
....................     
....................   Description: 
....................    Converts a two-character ASCII hex string to a single packed byte. 
....................     
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    AsciiChars - WORD_VAL where .v[0] is the ASCII value for the lower nibble 
....................                and .v[1] is the ASCII value for the upper nibble.  Each 
....................                must range from '0'-'9', 'A'-'F', or 'a'-'f'. 
....................  
....................   Returns: 
....................      Resulting packed byte 0x00 - 0xFF. 
....................   ***************************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
....................    // Convert lowercase to uppercase 
....................    if(AsciiChars.v[1] > 'F') 
....................       AsciiChars.v[1] -= 'a'-'A'; 
....................    if(AsciiChars.v[0] > 'F') 
....................       AsciiChars.v[0] -= 'a'-'A'; 
....................  
....................    // Convert 0-9, A-F to 0x0-0xF 
....................    if(AsciiChars.v[1] > '9') 
....................       AsciiChars.v[1] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[1] -= '0'; 
....................  
....................    if(AsciiChars.v[0] > '9') 
....................       AsciiChars.v[0] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[0] -= '0'; 
....................  
....................    // Concatenate 
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the upper nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'A'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The upper hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
....................    b >>= 4; 
....................    return (b>0x9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE btohexa_high(BYTE b) 
....................  
....................   Summary: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................  
....................   Description: 
....................    Converts the lower nibble of a binary value to a hexadecimal ASCII byte. 
....................    For example, btohexa_high(0xAE) will return 'E'. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    b - the byte to convert 
....................  
....................   Returns: 
....................      The lower hexadecimal ASCII byte '0'-'9' or 'A'-'F'. 
....................   ***************************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
....................    b &= 0x0F; 
....................    return (b>9u) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
....................  
....................   Summary: 
....................    Case-insensitive comparison of a string in RAM to a string in ROM. 
....................  
....................   Description: 
....................    Performs a case-insensitive comparison of a string in RAM to a string 
....................    in ROM.  This function performs identically to strcmppgm2ram, except that 
....................    the comparison is not case-sensitive. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    a - Pinter to tring in RAM 
....................    b - Pointer to string in ROM 
....................  
....................   Return Values: 
....................      \-1 - a < b 
....................      0   - a = b 
....................      1   - a > b 
....................   ***************************************************************************/ 
.................... signed char stricmppgm2ram(BYTE* a, ROM BYTE* b) 
.................... { 
....................    BYTE cA, cB; 
....................     
....................    // Load first two characters 
....................    cA = *a; 
....................    cB = *b; 
....................     
....................    // Loop until one string terminates 
....................    while(cA != '\0' && cB != '\0') 
....................    { 
....................       // Shift case if necessary 
....................       if(cA >= 'a' && cA <= 'z') 
....................          cA -= 'a' - 'A'; 
....................       if(cB >= 'a' && cB <= 'z') 
....................          cB -= 'a' - 'A'; 
....................           
....................       // Compare 
....................       if(cA > cB) 
....................          return 1; 
....................       if(cA < cB) 
....................          return -1; 
....................        
....................       // Characters matched, so continue 
....................       a++; 
....................       b++; 
....................       cA = *a; 
....................       cB = *b; 
....................    } 
....................     
....................    // See if one string terminated first 
....................    if(cA > cB) 
....................       return 1; 
....................    if(cA < cB) 
....................       return -1; 
....................        
....................    // Strings match 
....................    return 0; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD swaps(WORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a WORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the WORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... WORD swaps(WORD v) 
.................... { 
....................    WORD_VAL t; 
....................    BYTE b; 
....................  
....................    t.Val   = v; 
*
1C92:  MOVFF  430,432
1C96:  MOVFF  42F,431
....................    b       = t.v[1]; 
1C9A:  MOVFF  432,433
....................    t.v[1]  = t.v[0]; 
1C9E:  MOVFF  431,432
....................    t.v[0]  = b; 
1CA2:  MOVFF  433,431
....................  
....................    return t.Val; 
1CA6:  MOVLB  4
1CA8:  MOVFF  431,01
1CAC:  MOVFF  432,02
1CB0:  MOVLB  0
1CB2:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD swapl(DWORD v) 
....................  
....................   Description: 
....................    Swaps the endian-ness of a DWORD. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    v - the DWORD to swap 
....................  
....................   Returns: 
....................    The swapped version of v. 
....................   ***************************************************************************/ 
.................... #if defined(__C32__) 
.................... DWORD   __attribute__((nomips16)) swapl(DWORD v) 
.................... #else 
.................... DWORD swapl(DWORD v) 
.................... #endif 
.................... { 
....................    // Swap bytes 0 and 3 
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
*
338C:  MOVLW  04
338E:  MOVLB  4
3390:  MOVWF  x1D
3392:  MOVLW  18
3394:  MOVWF  01
3396:  MOVFF  41D,FEA
339A:  MOVWF  FE9
339C:  MOVFF  FEF,420
33A0:  MOVLW  04
33A2:  MOVWF  x22
33A4:  MOVLW  18
33A6:  MOVWF  x21
33A8:  MOVLW  03
33AA:  ADDWF  x21,W
33AC:  MOVWF  FE9
33AE:  MOVLW  00
33B0:  ADDWFC x22,W
33B2:  MOVWF  FEA
33B4:  MOVF   FEF,W
33B6:  XORWF  x20,W
33B8:  MOVFF  41D,FEA
33BC:  MOVFF  01,FE9
33C0:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[3] ^= ((DWORD_VAL*)&v)->v[0]; 
33C2:  MOVLW  04
33C4:  MOVWF  x1D
33C6:  MOVLW  18
33C8:  MOVWF  x1C
33CA:  MOVLW  03
33CC:  ADDWF  x1C,W
33CE:  MOVWF  01
33D0:  MOVLW  00
33D2:  ADDWFC x1D,W
33D4:  MOVWF  03
33D6:  MOVWF  FEA
33D8:  MOVFF  01,FE9
33DC:  MOVFF  FEF,420
33E0:  MOVLW  04
33E2:  MOVWF  x22
33E4:  MOVLW  18
33E6:  MOVWF  FE9
33E8:  MOVFF  422,FEA
33EC:  MOVF   FEF,W
33EE:  XORWF  x20,W
33F0:  MOVFF  03,FEA
33F4:  MOVFF  01,FE9
33F8:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[0] ^= ((DWORD_VAL*)&v)->v[3]; 
33FA:  MOVLW  04
33FC:  MOVWF  x1D
33FE:  MOVLW  18
3400:  MOVWF  01
3402:  MOVFF  41D,FEA
3406:  MOVWF  FE9
3408:  MOVFF  FEF,420
340C:  MOVLW  04
340E:  MOVWF  x22
3410:  MOVLW  18
3412:  MOVWF  x21
3414:  MOVLW  03
3416:  ADDWF  x21,W
3418:  MOVWF  FE9
341A:  MOVLW  00
341C:  ADDWFC x22,W
341E:  MOVWF  FEA
3420:  MOVF   FEF,W
3422:  XORWF  x20,W
3424:  MOVFF  41D,FEA
3428:  MOVFF  01,FE9
342C:  MOVWF  FEF
....................  
....................    // Swap bytes 1 and 2 
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
342E:  MOVLW  04
3430:  MOVWF  x1D
3432:  MOVLW  18
3434:  MOVWF  x1C
3436:  MOVLW  01
3438:  ADDWF  x1C,W
343A:  MOVWF  01
343C:  MOVLW  00
343E:  ADDWFC x1D,W
3440:  MOVWF  03
3442:  MOVWF  FEA
3444:  MOVFF  01,FE9
3448:  MOVFF  FEF,420
344C:  MOVLW  04
344E:  MOVWF  x22
3450:  MOVLW  18
3452:  MOVWF  x21
3454:  MOVLW  02
3456:  ADDWF  x21,W
3458:  MOVWF  FE9
345A:  MOVLW  00
345C:  ADDWFC x22,W
345E:  MOVWF  FEA
3460:  MOVF   FEF,W
3462:  XORWF  x20,W
3464:  MOVFF  03,FEA
3468:  MOVFF  01,FE9
346C:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[2] ^= ((DWORD_VAL*)&v)->v[1]; 
346E:  MOVLW  04
3470:  MOVWF  x1D
3472:  MOVLW  18
3474:  MOVWF  x1C
3476:  MOVLW  02
3478:  ADDWF  x1C,W
347A:  MOVWF  01
347C:  MOVLW  00
347E:  ADDWFC x1D,W
3480:  MOVWF  03
3482:  MOVWF  FEA
3484:  MOVFF  01,FE9
3488:  MOVFF  FEF,420
348C:  MOVLW  04
348E:  MOVWF  x22
3490:  MOVLW  18
3492:  MOVWF  x21
3494:  MOVLW  01
3496:  ADDWF  x21,W
3498:  MOVWF  FE9
349A:  MOVLW  00
349C:  ADDWFC x22,W
349E:  MOVWF  FEA
34A0:  MOVF   FEF,W
34A2:  XORWF  x20,W
34A4:  MOVFF  03,FEA
34A8:  MOVFF  01,FE9
34AC:  MOVWF  FEF
....................    ((DWORD_VAL*)&v)->v[1] ^= ((DWORD_VAL*)&v)->v[2]; 
34AE:  MOVLW  04
34B0:  MOVWF  x1D
34B2:  MOVLW  18
34B4:  MOVWF  x1C
34B6:  MOVLW  01
34B8:  ADDWF  x1C,W
34BA:  MOVWF  01
34BC:  MOVLW  00
34BE:  ADDWFC x1D,W
34C0:  MOVWF  03
34C2:  MOVWF  FEA
34C4:  MOVFF  01,FE9
34C8:  MOVFF  FEF,420
34CC:  MOVLW  04
34CE:  MOVWF  x22
34D0:  MOVLW  18
34D2:  MOVWF  x21
34D4:  MOVLW  02
34D6:  ADDWF  x21,W
34D8:  MOVWF  FE9
34DA:  MOVLW  00
34DC:  ADDWFC x22,W
34DE:  MOVWF  FEA
34E0:  MOVF   FEF,W
34E2:  XORWF  x20,W
34E4:  MOVFF  03,FEA
34E8:  MOVFF  01,FE9
34EC:  MOVWF  FEF
....................  
....................    return v; 
34EE:  MOVFF  418,00
34F2:  MOVFF  419,01
34F6:  MOVFF  41A,02
34FA:  MOVFF  41B,03
34FE:  MOVLB  0
3500:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD CalcIPChecksum(BYTE* buffer, WORD count) 
....................  
....................   Summary: 
....................    Calculates an IP checksum value. 
....................  
....................   Description: 
....................    This function calculates an IP checksum over an array of input data.  The 
....................    checksum is the 16-bit one's complement of one's complement sum of all  
....................    words in the data (with zero-padding if an odd number of bytes are  
....................    summed).  This checksum is defined in RFC 793. 
....................  
....................   Precondition: 
....................    buffer is WORD aligned (even memory address) on 16- and 32-bit PICs. 
....................  
....................   Parameters: 
....................    buffer - pointer to the data to be checksummed 
....................    count  - number of bytes to be checksummed 
....................  
....................   Returns: 
....................    The calculated checksum. 
....................     
....................   Internal: 
....................    This function could be improved to do 32-bit sums on PIC32 platforms. 
....................   ***************************************************************************/ 
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
....................    WORD i; 
....................    WORD *val; 
....................    union 
....................    { 
....................       WORD w[2]; 
....................       DWORD dw; 
....................    } sum; 
....................  
....................    i = count >> 1; 
*
1D8E:  BCF    FD8.0
1D90:  MOVLB  4
1D92:  RRCF   x2E,W
1D94:  MOVWF  x30
1D96:  RRCF   x2D,W
1D98:  MOVWF  x2F
....................    val = (WORD*)buffer; 
1D9A:  MOVFF  42C,432
1D9E:  MOVFF  42B,431
....................  
....................    // Calculate the sum of all words 
....................    sum.dw = 0x00000000ul; 
1DA2:  CLRF   x36
1DA4:  CLRF   x35
1DA6:  CLRF   x34
1DA8:  CLRF   x33
....................    while(i--) 
1DAA:  MOVFF  430,03
1DAE:  MOVF   x2F,W
1DB0:  BTFSC  FD8.2
1DB2:  DECF   x30,F
1DB4:  DECF   x2F,F
1DB6:  IORWF  03,W
1DB8:  BZ    1DF6
....................       sum.dw += (DWORD)*val++; 
1DBA:  MOVFF  432,03
1DBE:  MOVFF  431,00
1DC2:  MOVLW  02
1DC4:  ADDWF  x31,F
1DC6:  BTFSC  FD8.0
1DC8:  INCF   x32,F
1DCA:  MOVFF  00,FE9
1DCE:  MOVFF  03,FEA
1DD2:  MOVFF  FEC,03
1DD6:  MOVF   FED,F
1DD8:  MOVFF  FEF,00
1DDC:  MOVFF  03,01
1DE0:  CLRF   02
1DE2:  CLRF   03
1DE4:  MOVF   00,W
1DE6:  ADDWF  x33,F
1DE8:  MOVF   01,W
1DEA:  ADDWFC x34,F
1DEC:  MOVF   02,W
1DEE:  ADDWFC x35,F
1DF0:  MOVF   03,W
1DF2:  ADDWFC x36,F
1DF4:  BRA    1DAA
....................  
....................    // Add in the sum of the remaining byte, if present 
....................    if(count & 0x1) 
1DF6:  MOVF   x2D,W
1DF8:  ANDLW  01
1DFA:  MOVWF  00
1DFC:  CLRF   03
1DFE:  MOVF   00,W
1E00:  IORWF  03,W
1E02:  BZ    1E2A
....................       sum.dw += (DWORD)*(BYTE*)val; 
1E04:  MOVFF  432,03
1E08:  MOVFF  431,FE9
1E0C:  MOVFF  432,FEA
1E10:  MOVFF  FEF,00
1E14:  CLRF   01
1E16:  CLRF   02
1E18:  CLRF   03
1E1A:  MOVF   00,W
1E1C:  ADDWF  x33,F
1E1E:  MOVF   01,W
1E20:  ADDWFC x34,F
1E22:  MOVF   02,W
1E24:  ADDWFC x35,F
1E26:  MOVF   03,W
1E28:  ADDWFC x36,F
....................  
....................    // Do an end-around carry (one's complement arrithmatic) 
....................    sum.dw = (DWORD)sum.w[0] + (DWORD)sum.w[1]; 
1E2A:  CLRF   x3A
1E2C:  CLRF   x39
1E2E:  MOVFF  434,438
1E32:  MOVFF  433,437
1E36:  MOVFF  435,00
1E3A:  MOVFF  436,01
1E3E:  CLRF   02
1E40:  CLRF   03
1E42:  MOVF   x35,W
1E44:  ADDWF  x33,W
1E46:  MOVWF  x33
1E48:  MOVF   x36,W
1E4A:  ADDWFC x34,W
1E4C:  MOVWF  x34
1E4E:  MOVF   02,W
1E50:  ADDWFC x39,W
1E52:  MOVWF  x35
1E54:  MOVF   03,W
1E56:  ADDWFC x3A,W
1E58:  MOVWF  x36
....................  
....................    // Do another end-around carry in case if the prior add  
....................    // caused a carry out 
....................    sum.w[0] += sum.w[1]; 
1E5A:  MOVF   x35,W
1E5C:  ADDWF  x33,F
1E5E:  MOVF   x36,W
1E60:  ADDWFC x34,F
....................  
....................    // Return the resulting checksum 
....................    return ~sum.w[0]; 
1E62:  MOVFF  434,03
1E66:  COMF   03,F
1E68:  MOVF   x33,W
1E6A:  XORLW  FF
1E6C:  MOVWF  01
1E6E:  MOVFF  03,02
1E72:  MOVLB  0
1E74:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strupr(char* s) 
....................  
....................   Summary: 
....................    Converts a string to uppercase. 
....................  
....................   Description: 
....................    This function converts strings to uppercase on platforms that do not 
....................    already have this function defined.  All lower-case characters are 
....................    converted, an characters not included in 'a'-'z' are left as-is. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    s - the null-terminated string to be converted. 
....................  
....................   Returns: 
....................    Pointer to the initial string. 
....................   ***************************************************************************/ 
.................... #if (!defined(__PCD__) && !defined(__18CXX)) || defined(HI_TECH_C) 
.................... char* strupr(char* s) 
.................... { 
....................    char c; 
....................    char *t; 
....................  
....................    t = s; 
....................    while( (c = *t) ) 
....................    { 
....................       if(c >= 'a' && c <= 'z') 
....................       { 
....................          *t -= ('a' - 'A'); 
....................       } 
....................       t++; 
....................    } 
....................    return s; 
.................... } 
.................... #endif 
....................  
.................... #if defined(__18CXX) //&& !defined(__PCH__) 
.................... // Make this variable global for the following function. 
.................... // Hi-Tech PICC18 cannot access local function variables from inline asm. 
.................... DWORD_VAL toRotate;  
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    DWORD leftRotateDWORD(DWORD val, BYTE bits) 
....................  
....................   Summary: 
....................    Left-rotates a DWORD. 
....................  
....................   Description: 
....................    This function rotates the bits in a 32-bit DWORD left by a specific  
....................    number of bits. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    val      - the DWORD to be rotated 
....................    bits   - the number of bits by which to shift 
....................  
....................   Returns: 
....................    Rotated DWORD value. 
....................     
....................   Remarks: 
....................    This function is only implemented on 8-bit platforms for now.  The  
....................    8-bit compilers generate excessive code for this function, while C30 
....................    and C32 already generate compact code.  Those compilers are served 
....................    by a macro defined in Helpers.h. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) && !defined(__PCH__) 
.................... DWORD leftRotateDWORD(DWORD val, BYTE bits) 
.................... { 
....................    BYTE i, t; 
....................    //DWORD_VAL toRotate; 
....................    toRotate.Val = val; 
....................     
....................    for(i = bits; i >= 8u; i -= 8) 
....................    { 
....................       t = toRotate.v[3]; 
....................       toRotate.v[3] = toRotate.v[2]; 
....................       toRotate.v[2] = toRotate.v[1]; 
....................       toRotate.v[1] = toRotate.v[0]; 
....................       toRotate.v[0] = t; 
....................    } 
....................     
....................     
....................    #if defined(HI_TECH_C) 
....................    for(; i != 0; i--) 
....................    { 
....................       asm("movlb (_toRotate)>>8"); 
....................       //asm("bcf _STATUS,0,C"); 
....................       asm("bcf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("btfsc (_toRotate)&0ffh+3,7,B"); 
....................       //asm("bsf _STATUS,0,C"); 
....................       asm("bsf 0xFD8,0,C");      // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS 
....................       asm("rlcf (_toRotate)&0ffh+0,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+1,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+2,F,B"); 
....................       asm("rlcf (_toRotate)&0ffh+3,F,B"); 
....................    } 
....................    #else 
....................    for(; i != 0u; i--) 
....................    { 
....................       _asm 
....................       movlb toRotate 
....................       bcf STATUS,0,0 
....................       btfsc toRotate+3,7,1 
....................       bsf STATUS,0,0 
....................       rlcf toRotate+0,1,1 
....................       rlcf toRotate+1,1,1 
....................       rlcf toRotate+2,1,1 
....................       rlcf toRotate+3,1,1 
....................       _endasm 
....................    } 
....................    #endif 
....................     
....................    return toRotate.Val; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void FormatNetBIOSName(BYTE Name[]) 
....................  
....................   Summary: 
....................    Formats a string to a valid NetBIOS name. 
....................  
....................   Description: 
....................    This function formats a string to a valid NetBIOS name.  Names will be 
....................    exactly 16 characters, as defined by the NetBIOS spec.  The 16th  
....................    character will be a 0x00 byte, while the other 15 will be the  
....................    provided string, padded with spaces as necessary. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    Name - the string to format as a NetBIOS name.  This parameter must have 
....................      at least 16 bytes allocated. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void FormatNetBIOSName(BYTE Name[]) 
.................... { 
....................    BYTE i; 
....................  
....................    Name[15] = '\0'; 
....................    strupr((char*)Name); 
....................    i = 0; 
....................    while(i < 15u) 
....................    { 
....................       if(Name[i] == '\0') 
....................       { 
....................          while(i < 15u) 
....................          { 
....................             Name[i++] = ' '; 
....................          } 
....................          break; 
....................       } 
....................       i++; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char * strnchr(const char *searchString, size_t count, char c) 
....................  
....................   Summary: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character. 
....................  
....................   Description: 
....................    Searches a string up to a specified number of characters for a specific  
....................    character.  The string is searched forward and the first occurance  
....................    location is returned.  If the search character is not present in the  
....................    string, or if the maximum character count is reached first, then a NULL  
....................    pointer is returned. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    searchString - Pointer to a null terminated string to search.  If count is  
....................       less than the string size, then the string need not be null terminated. 
....................    count - Maximum number of characters to search before aborting. 
....................    c - Character to search for 
....................     
....................   Returns: 
....................    Pointer to the first occurance of the character c in the string  
....................    searchString.  If the character is not found or the maximum count is  
....................    reached, a NULL pointer is returned. 
....................   ***************************************************************************/ 
.................... char * strnchr(const char *searchString, size_t count, char c) 
.................... { 
....................    char c2; 
....................     
....................    while(count--) 
....................    { 
....................       c2  = *searchString++; 
....................       if(c2 == 0u) 
....................          return NULL; 
....................       if(c2 == c) 
....................          return (char*)--searchString; 
....................    } 
....................    return NULL; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    char* strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
....................  
....................   Summary: 
....................    Copies multiple strings to a destination 
....................  
....................   Description: 
....................    Copies multiple strings to a destination 
....................     but doesn't copy more than destSize characters. 
....................     Useful where the destination is actually an array and an extra \0 
....................     won't be appended to overflow the buffer 
....................      
....................   Precondition: 
....................    - valid string pointers 
....................     - destSize should be > 0 
....................  
....................   Parameters: 
....................    destStr - Pointer to a string to be initialized with the multiple strings provided as arguments. 
....................  
....................     destSize    - the maximum size of the destStr field, that cannot be exceeded. 
....................                   An \0 won't be appended if the resulting size is > destSize 
....................  
....................     nStrings    - number of string parameters to be copied into destStr 
....................  
....................     ...         - variable number of arguments 
....................      
....................     
....................   Returns: 
....................    Length of the destination string, terminating \0 (if exists) not included 
....................   ***************************************************************************/ 
.................... size_t strncpy_m(char* destStr, size_t destSize, int nStrings, ...) 
.................... { 
....................     va_list     args; 
....................     const char* str; 
....................     char*       end; 
....................     size_t      len; 
....................  
....................     destStr[0] = '\0'; 
....................     end = destStr + destSize - 1; 
....................     *end = '\0'; 
....................     len = 0; 
....................      
....................     va_start( args, nStrings ); 
....................      
....................     while(nStrings--) 
....................     { 
....................         if(*end) 
....................         {   // if already full don't calculate strlen outside the string area 
....................             len = destSize; 
....................             break; 
....................         } 
....................          
....................         str = va_arg(args, const char*); 
....................         strncpy(destStr + len, str, destSize - len); 
....................         len += strlen(str); 
....................     } 
....................  
....................     va_end( args ); 
....................      
....................     return len; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE ExtractURLFields(BYTE *vURL,  
....................                     PROTOCOLS *protocol,  
....................                     BYTE *vUsername, WORD *wUsernameLen,  
....................                     BYTE *vPassword, WORD *wPasswordLen,  
....................                     BYTE *vHostname, WORD *wHostnameLen,  
....................                     WORD *wPort,  
....................                     BYTE *vFilePath, WORD *wFilePathLen) 
....................  
....................   Summary: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................  
....................   Description: 
....................    Extracts all parameters from an URL string (ex:  
....................    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into  
....................    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}. 
....................     
....................    The URL string can be null terminated, or alternatively could be terminated  
....................    by a carriage return or line feed. 
....................     
....................    If the protocol is unrecognized or the protocol is recognized but the URL  
....................    is malformed, than an error is safely returned.  For more information on  
....................    URL/URI interpretation see RFC 2396. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vURL -   Pointer to null terminated URL to decode and extract from.  This  
....................       parameter is required and needs to have the minimum RFC 1738 components  
....................       in it (protocol and hostname). 
....................        
....................    protocol - Optional pointer to a PROTOCOLS enum to retrieve the decoded  
....................       protocol type.  If this parameter is unneeded, specify a NULL pointer.   
....................       The protocol is a required part of the URL, so it must always be  
....................       present.  The protocol also determines what scheme all other parameters  
....................       are decoded using, so the function will fail if an unrecognized  
....................       protocol is provided.  The PROTOCOLS enum members show all of the  
....................       currently supported protocols for this function. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       PROTOCOL_HTTP would be returned for this field. 
....................        
....................    vUsername - Optional pointer to a buffer to write the decoded username  
....................       portion of the URL.  If the URL does not contain a username or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "admin"  
....................       would be returned for this field. 
....................        
....................    wUsernameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vUsername buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wUsernameLen and vUsername are non-NULL, the  
....................       *wUsernameLen WORD is updated with the actual number of characters  
....................       written to the vUsername buffer, including the null terminator  
....................       character.  If vUsername is NULL but wUsernameLen is non-NULL, then no  
....................       characters are copied, but *wUsernameLen will return the number of  
....................       characters required to fit the full username string.  If wUsernameLen  
....................       is NULL, then the username field in the URL, if present, is ignored and  
....................       the vUsername pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a username field.  If one character was written, this indicates  
....................       that a username field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 6 (0x0006)  
....................       would be returned for this field. 
....................        
....................    vPassword - Optional pointer to a buffer to write the decoded password  
....................       portion of the URL.  If the URL does not contain a password or a NULL  
....................       pointer is supplied, then this field is ignored. 
....................  
....................       <p>For the example URL provided in the function description, "passwd"  
....................       would be returned for this field. 
....................        
....................    wPasswordLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vPassword buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wPasswordLen and vPassword are non-NULL, the  
....................       *wPasswordLen WORD is updated with the actual number of characters  
....................       written to the vPassword buffer, including the null terminator  
....................       character.  If vPassword is NULL but wPasswordLen is non-NULL, then no  
....................       characters are copied, but *wPasswordLen will return the number of  
....................       characters required to fit the full password string.  If wPasswordLen  
....................       is NULL, then the password field in the URL, if present, is ignored and  
....................       the vPassword pointer is not used. 
....................        
....................       <p>If zero characters were written, this indicates that the URL did not  
....................       contain a password field.  If one character was written, this indicates  
....................       that a password field was present, but was a zero character string  
....................       (ex\: ""). 
....................         
....................       <p>For the example URL provided in the function description, 7 (0x0007)  
....................       would be returned for this field. 
....................        
....................    vHostname - Optional pointer to a buffer to write the decoded hostname  
....................       portion of the URL.  All Internet URLs must contain a hostname or IP  
....................       address, however, if a NULL pointer is supplied, then this field is  
....................       ignored. 
....................  
....................       <p>For the example URL provided in the function description,  
....................       "www.microchip.com" would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as  
....................       "192.168.0.1".   The IP address would not be decoded to a DWORD (use the  
....................       StringToIPAddress() helper function to do this). 
....................        
....................    wHostnameLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vHostname buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wHostnameLen and vHostname are non-NULL, the  
....................       *wHostnameLen WORD is updated with the actual number of characters  
....................       written to the vHostname buffer, including the null terminator  
....................       character.  If vHostname is NULL but wHostnameLen is non-NULL, then no  
....................       characters are copied, but *wHostnameLen will return the number of  
....................       characters required to fit the full hostname string.  If wHostnameLen  
....................       is NULL, then the hostname field in the URL, is ignored and the  
....................       vHostname pointer is not used. 
....................        
....................       <p>For the example URL provided in the function description,  
....................       18 (0x0012) would be returned for this field.  If the URL was  
....................       "http://192.168.0.1", then this field would be returned as 12 (0x000C). 
....................        
....................    wPort - Optional pointer to a WORD specifying the TCP or UDP port that the  
....................       server is listening on.  If the port field is absent from the URL, then  
....................       this parameter will specify the default port for the protocol.  For  
....................       example, "http://www.microchip.com" would result in 80 being return as  
....................       the specified port. 
....................         
....................       <p>If the wPort pointer is NULL, then the port field in the URL  
....................       is ignored, if present. 
....................        
....................    vFilePath - Optional pointer to a buffer to write the decoded file path  
....................       portion of the URL.  If a NULL pointer is supplied, then this field is  
....................       ignored.  If a file path is not present in the URL, then "/" will be  
....................       returned in this field.   
....................  
....................       <p>For the example URL provided in the function description,  
....................       "/myfile.gif" would be returned for this field. 
....................        
....................    wFilePathLen - 
....................       On call\: Optional pointer to a WORD specifying the maximum length of  
....................       the vFilePath buffer, including the null terminator character. 
....................        
....................       <p>Upon return\: If wFilePathLen and vFilePath are non-NULL, the  
....................       *wFilePathLen WORD is updated with the actual number of characters  
....................       written to the vFilePath buffer, including the null terminator  
....................       character.  If vFilePath is NULL but wFilePathLen is non-NULL, then no  
....................       characters are copied, but *wFilePathLen will return the number of  
....................       characters required to fit the full file path string.  If wFilePathLen  
....................       is NULL, then the file path field in the URL, if present, is ignored and  
....................       the vFilePath pointer is not used. 
....................        
....................       <p>This function always returns "/" if no file path is present, so 
....................       *wFilePathLen will also be at least 2 characters ('/' and null  
....................       terminator) if the pointer is non-NULL. 
....................     
....................       <p>For the example URL provided in the function description, 12 (0x000C)  
....................       would be returned for this field. 
....................        
....................   Returns: 
....................    Zero on success.  Nonzero indicates an error code.  If a nonzero error code  
....................    is returned, none of the returned buffers or pointer values should be  
....................    treated as valid, but some of them may have been written to.  The following  
....................    are all possible return values. 
....................    <table> 
....................       0   No error 
....................       1   Protocol unknown (additional code needs to be added to  
....................           ExtractURLFields() and the PROTOCOLS enum needs to be updated if  
....................           you want to decode URLs of this protocol type. 
....................       2   URL malformed. Illegal or unknown URL format encountered. 
....................       3   Buffer too small.  One of the input buffer sizes is too small to  
....................           contain the URL parameter. 
....................    </table> 
....................   ***************************************************************************/ 
.................... #if 0    
.................... BYTE ExtractURLFields(BYTE *vURL, PROTOCOLS *protocol, BYTE *vUsername, WORD *wUsernameLen, BYTE *vPassword, WORD *wPasswordLen, BYTE *vHostname, WORD *wHostnameLen, WORD *wPort, BYTE *vFilePath, WORD *wFilePathLen) 
.................... { 
....................    // These two arrays must exactly match up each other and the PROTOCOLS enum  
....................    // elements.  The protocol name strings must also be specified in all  
....................    // lowercase. 
....................    static ROM char * ROM   vProtocolNames[] = {"http", "https", "mms", "rtsp"}; 
....................    static ROM WORD       wProtocolPorts[] = { 80,     443,     1755,  554}; 
....................    WORD w, w2; 
....................    BYTE i, j; 
....................    PROTOCOLS prot; 
....................    BYTE *temp, *temp2; 
....................    WORD wURLLen; 
....................    WORD wLocalPort; 
....................     
....................     
....................    // Calculate how long this URL is 
....................    wURLLen = strlen((char*)vURL); 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\r'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '\n'); 
....................    if(temp) 
....................       wURLLen = temp - vURL; 
....................     
....................  
....................    // Parse starting protocol field 
....................    // Find out how long the protocol name field is 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    if(temp == NULL) 
....................       return 2; 
....................     
....................    // Search protocol list to see if this is a recognized protocol 
....................    for(prot = 0; (BYTE)prot < sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0]); prot++) 
....................    { 
....................       w = strlenpgm(vProtocolNames[prot]); 
....................       if((WORD)(temp - vURL) == w) 
....................       { 
....................          w2 = 0; 
....................          temp2 = vURL; 
....................          while(w) 
....................          { 
....................             i = *temp2++; 
....................             if((i >= 'A') && (i <= 'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != (BYTE)vProtocolNames[prot][w2++]) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w == 0u) 
....................          { 
....................             if(protocol) 
....................                *protocol = prot; 
....................             break; 
....................          } 
....................       } 
....................    } 
....................  
....................    // If we've search the whole list and didn't find a match, then  
....................    // this protocol is unknown and this URL cannot be parsed. 
....................    if((BYTE)prot >= sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0])) 
....................       return 1; 
....................     
....................    w = temp - vURL + 1; 
....................    vURL += w; 
....................    wURLLen -= w; 
....................  
....................    // Protocols using the authority field all must have a double  
....................    // slash "//" prefix 
....................    if(wURLLen < 2u) 
....................       return 2; 
....................    for(j = 0; j < 2u; j++) 
....................    { 
....................       i = *vURL++; 
....................       if(i != '/') 
....................          return 2; 
....................    } 
....................    wURLLen -= 2; 
....................     
....................  
....................    // Parse username and password fields 
....................    // See if there is a @ sign, indicating that there is at  
....................    // least a username and possibly a password in this URL 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, '@'); 
....................    if(temp == NULL) 
....................    { 
....................       if(wUsernameLen) 
....................          *wUsernameLen = 0; 
....................       if(wPasswordLen) 
....................          *wPasswordLen = 0; 
....................    } 
....................    else 
....................    { 
....................       // If we get down here, there is a user name present, let's  
....................       // see if a password is also present by searching for a  
....................       // colon between the current string position and the @  
....................       // symbol. 
....................       temp2 = (BYTE*)strnchr((char*)vURL, temp - vURL, ':'); 
....................        
....................       // Calculate username length and password length, including  
....................       // null terminator (if the field exists) 
....................       if(temp2 == NULL) 
....................       { 
....................          w = temp - vURL + 1;   // Username 
....................          w2 = 0;               // Password 
....................       } 
....................       else 
....................       { 
....................          w = temp2 - vURL + 1;   // Username 
....................          w2 = temp - temp2;      // Password 
....................       } 
....................        
....................       if(wUsernameLen) 
....................       { 
....................          if(vUsername) 
....................          { 
....................             if(*wUsernameLen < w) 
....................                return 3; 
....................             memcpy((void*)vUsername, (void*)vURL, w - 1); 
....................             vUsername[w-1] = 0; 
....................          } 
....................          *wUsernameLen = w; 
....................       } 
....................     
....................       if(wPasswordLen) 
....................       { 
....................          if(vPassword) 
....................          { 
....................             if(*wPasswordLen < w2) 
....................                return 3; 
....................             if(w2) 
....................             { 
....................                memcpy((void*)vPassword, (void*)temp2+1, w2 - 1); 
....................                vPassword[w2-1] = 0; 
....................             } 
....................          } 
....................          *wPasswordLen = w2; 
....................       } 
....................     
....................       vURL += w; 
....................       wURLLen -= w; 
....................       if(w2) 
....................       { 
....................          vURL += w2; 
....................          wURLLen -= w2; 
....................       } 
....................    } 
....................  
....................  
....................    // Parse hostname field 
....................    // Find the length of the hostname, including NULL  
....................    // terminator 
....................    temp = (BYTE*)strnchr((char*)vURL, wURLLen, ':'); 
....................    temp2 = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................    if(temp && temp2) 
....................    { 
....................       if(temp > temp2) 
....................          temp = NULL; 
....................    } 
....................    if(temp == NULL) 
....................    { 
....................       temp = temp2; 
....................       if(temp2 == NULL) 
....................          temp = vURL + wURLLen; 
....................    } 
....................    w = temp - vURL + 1; 
....................    if(wHostnameLen) 
....................    { 
....................       if(vHostname) 
....................       { 
....................          if(*wHostnameLen < w) 
....................             return 3; 
....................          memcpy((void*)vHostname, (void*)vURL, w - 1); 
....................          vHostname[w-1] = 0; 
....................       } 
....................       *wHostnameLen = w; 
....................    } 
....................    vURL += w - 1; 
....................    wURLLen -= w - 1; 
....................  
....................  
....................    // Parse port field 
....................    if(*vURL == ':') 
....................    { 
....................       vURL++; 
....................       wURLLen--; 
....................       wLocalPort = 0; 
....................       w = wURLLen; 
....................       temp = (BYTE*)strnchr((char*)vURL, wURLLen, '/'); 
....................       if(temp != NULL) 
....................          w = temp - vURL; 
....................       w2 = w; 
....................       if(wPort) 
....................       { 
....................          while(w--) 
....................          { 
....................             wLocalPort *= 10; 
....................             wLocalPort += *vURL++ - '0'; 
....................          } 
....................          *wPort = wLocalPort; 
....................       } 
....................       else 
....................          vURL += w2; 
....................       wURLLen -= w2; 
....................    } 
....................    else if(wPort) 
....................       *wPort = wProtocolPorts[prot]; 
....................  
....................  
....................    // Parse file path field 
....................    if(wFilePathLen) 
....................    { 
....................       w = ++wURLLen; 
....................       if(wURLLen == 1u) 
....................          w = 2; 
....................       if(vFilePath) 
....................       { 
....................          if(*wFilePathLen < w) 
....................             return 3; 
....................          if(wURLLen == 1u) 
....................             vFilePath[0] = '/'; 
....................          else 
....................             memcpy((void*)vFilePath, (void*)vURL, wURLLen - 1); 
....................          vFilePath[w - 1] = 0; 
....................          *wFilePathLen = w; 
....................          return 0; 
....................       } 
....................       *wFilePathLen = w; 
....................    } 
....................    return 0; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement,  
....................               WORD wMaxLen, BOOL bSearchCaseInsensitive) 
....................  
....................   Summary: 
....................    Replaces all instances of a particular substring with a new string 
....................  
....................   Description: 
....................    Searches a string (vExpression) and replaces all instances of a particular  
....................    substring (vFind) with a new string (vReplacement).  The start offset to  
....................    being searching and a maximum number of replacements can be specified.  The  
....................    search can be performed in a case sensitive or case insensitive manner. 
....................  
....................   Precondition: 
....................    This function is commented out by default to save code space because  
....................    it is not used by any current stack features.  However, if you want to use  
....................    it, go ahead and uncomment it.  It has been tested, so it (should) work  
....................    correctly. 
....................  
....................   Parameters: 
....................    vExpression - Null terminated string to search and make replacements within. 
....................    vFind - Null terminated string to search for. 
....................    vReplacement - Null terminated string to replace all instances of vFind with. 
....................    wMaxLen - Maximum length of the output vExpression string if string  
....................       expansion is going to occur (replacement length is longer than find  
....................       length).  If the replacements will cause this maximum string length to  
....................       be exceeded, then no replacements will be made and a negative result  
....................       will be returned, indicating failure.  If the replacement length is  
....................       shorter or equal to the search length, then this parameter is ignored. 
....................    bSearchCaseInsensitive - Boolean indicating if the search should be  
....................       performed in a case insensitive manner.  Specify TRUE for case  
....................       insensitive searches (slower) or FALSE for case sensitive  
....................       searching (faster). 
....................  
....................   Remarks: 
....................    If the replacement string length is shorter than or equal to the search  
....................    string length and the search string occurs in multiple overlapping  
....................    locations (ex\: expression is "aaa", find is "aa", and replacement is "bb")  
....................    then the first find match occuring when searching from left to right will  
....................    be replaced.  (ex\: output expression will be "bba"). 
....................     
....................    However, if the replacement string length is longer than the search string  
....................    length, the search will occur starting from the end of the string and  
....................    proceed to the beginning (right to left searching).  In this case if the  
....................    expression was "aaa", find was "aa", and replacement was "bbb", then the  
....................    final output expression will be "abbb".   
....................  
....................   Returns: 
....................    If zero or greater, indicates the count of how many replacements were made.   
....................    If less than zero (negative result), indicates that wMaxLen was too small  
....................    to make the necessary replacements.  In this case, no replacements were  
....................    made. 
....................   ***************************************************************************/ 
.................... #if 0 
.................... SHORT Replace(BYTE *vExpression, ROM BYTE *vFind, ROM BYTE *vReplacement, WORD wMaxLen, BOOL bSearchCaseInsensitive) 
.................... { 
....................    WORD wExpressionLen, wFindLen, wFindLenMinusOne, wReplacementLen; 
....................    WORD wFindCount, wReplacementsLeft; 
....................    BYTE i, j; 
....................    BYTE vFirstFindChar; 
....................    WORD wBytesLeft; 
....................    BYTE *vDest; 
....................    BYTE *vExpressionCompare; 
....................    ROM BYTE *vFindCompare; 
....................    WORD w; 
....................  
....................    wFindLen = strlenpgm((ROM char*)vFind); 
....................    if(wFindLen == 0u) 
....................       return 0; 
....................     
....................    wExpressionLen = strlen((char*)vExpression); 
....................    wReplacementLen = strlenpgm((ROM char*)vReplacement); 
....................  
....................    wFindCount = 0; 
....................    wFindLenMinusOne = wFindLen - 1; 
....................    vFirstFindChar = *vFind++; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................  
....................    // If the replacement string is the same length as the search string, then  
....................    // we can immediately do the needed replacements inline and return. 
....................    if(wFindLen == wReplacementLen) 
....................    { 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vExpression-1, (ROM void*)vReplacement, wReplacementLen); 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       return wFindCount; 
....................    } 
....................     
....................     
....................    // If the replacement string is shorter than the search string, then we can  
....................    // search from left to right and move the string over as we find occurrences. 
....................    if(wFindLen > wReplacementLen) 
....................    { 
....................       vDest = vExpression; 
....................       for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................       { 
....................          i = *vExpression++; 
....................          *vDest++ = i; 
....................          if(bSearchCaseInsensitive) 
....................          { 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             vExpressionCompare = vExpression; 
....................             vFindCompare = vFind; 
....................             w = wFindLenMinusOne; 
....................             while(w) 
....................             { 
....................                i = *vExpressionCompare++; 
....................                j = *vFindCompare++; 
....................                if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                   i += 'a' - 'A'; 
....................                if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                   j += 'a' - 'A'; 
....................                if(i != j) 
....................                   break; 
....................                w--; 
....................             } 
....................             if(w) 
....................                continue; 
....................          } 
....................          else 
....................          { 
....................             if(i != vFirstFindChar) 
....................                continue; 
....................             if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................                continue; 
....................          } 
....................     
....................          memcpypgm2ram((void*)vDest-1, (ROM void*)vReplacement, wReplacementLen); 
....................          vDest += wReplacementLen-1; 
....................          wFindCount++; 
....................          vExpression += wFindLenMinusOne; 
....................          wBytesLeft -= wFindLenMinusOne; 
....................       } 
....................       *vDest = 0x00;   // Write new null terminator since the string may have shrunk 
....................       return wFindCount; 
....................    } 
....................     
....................    // If the replacement string is longer than the search string, then we will  
....................    // take a two pass approach.  On the first pass, we will merely count how  
....................    // many replacements to make.  With this we can calculate how long the  
....................    // final string is going to be.  On the second pass, we will search from  
....................    // right to left and expand the string as needed. 
....................  
....................    // Pass 1: count how many occurrences of vFind are in vExpression 
....................    for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--) 
....................    { 
....................       i = *vExpression++; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = vFind; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare++; 
....................             j = *vFindCompare++; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................  
....................       wFindCount++; 
....................       vExpression += wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................    } 
....................     
....................    // Return immediately if no replacements are needed 
....................    if(wFindCount == 0u) 
....................       return 0; 
....................  
....................    // Pass 2: make replacements and move string over 
....................    vDest = vExpression + wFindCount * (wReplacementLen - wFindLen); 
....................    if(vDest > vExpression - wExpressionLen + wMaxLen) 
....................       return -1; 
....................    *vDest-- = 0x00;   // Write new null terminator 
....................    vExpression -= 1; 
....................    vFind -= 1; 
....................    vFirstFindChar = vFind[wFindLenMinusOne]; 
....................    if(bSearchCaseInsensitive)   // Convert to all lowercase if needed 
....................       if((vFirstFindChar >= (BYTE)'A') && (vFirstFindChar <= (BYTE)'Z')) 
....................          vFirstFindChar += 'a' - 'A'; 
....................    wReplacementsLeft = wFindCount; 
....................    while(wReplacementsLeft) 
....................    { 
....................       i = *vExpression--; 
....................       *vDest-- = i; 
....................       if(bSearchCaseInsensitive) 
....................       { 
....................          if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................             i += 'a' - 'A'; 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          vExpressionCompare = vExpression; 
....................          vFindCompare = &vFind[wFindLenMinusOne-1]; 
....................          w = wFindLenMinusOne; 
....................          while(w) 
....................          { 
....................             i = *vExpressionCompare--; 
....................             j = *vFindCompare--; 
....................             if((i >= (BYTE)'A') && (i <= (BYTE)'Z')) 
....................                i += 'a' - 'A'; 
....................             if((j >= (BYTE)'A') && (j <= (BYTE)'Z')) 
....................                j += 'a' - 'A'; 
....................             if(i != j) 
....................                break; 
....................             w--; 
....................          } 
....................          if(w) 
....................             continue; 
....................       } 
....................       else 
....................       { 
....................          if(i != vFirstFindChar) 
....................             continue; 
....................          if(memcmppgm2ram((void*)vExpression-wFindLenMinusOne, (ROM void*)vFind, wFindLenMinusOne)) 
....................             continue; 
....................       } 
....................       memcpypgm2ram((void*)vDest-wReplacementLen+2, (ROM void*)vReplacement, wReplacementLen); 
....................       vDest -= wReplacementLen-1; 
....................  
....................       vExpression -= wFindLenMinusOne; 
....................       wBytesLeft -= wFindLenMinusOne; 
....................       wReplacementsLeft--; 
....................    } 
....................    return wFindCount; 
.................... } 
.................... #endif 
....................  
.................... //#include "Delay.c" //not needed, we overrode this in StackTsk2.h 
.................... #include "Tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for Timekeeping 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    Timer 0 (PIC18) or Timer 1 (PIC24F, PIC24H,  
....................  *					dsPIC30F, dsPIC33F, PIC32) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.10b or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2010 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		6/13/07		Changed to use timer without  
....................  *									writing for perfect accuracy. 
.................... ********************************************************************/ 
.................... #define __TICK_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // Internal counter to store Ticks.  This variable is incremented in an ISR and  
.................... // therefore must be marked volatile to prevent the compiler optimizer from  
.................... // reordering code to use this value in the main context while interrupts are  
.................... // disabled. 
.................... static volatile DWORD dwInternalTicks = 0; 
....................  
.................... // 6-byte value to store Ticks.  Allows for use over longer periods of time. 
.................... static BYTE vTickReading[6]; 
....................  
.................... static void GetTickCopy(void); 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickInit(void) 
....................  
....................   Summary: 
.................... 	Initializes the Tick manager module. 
....................  
....................   Description: 
.................... 	Configures the Tick module and any necessary hardware resources. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   	 
....................   Remarks: 
.................... 	This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TickInit(void) 
.................... { 
.................... #if defined(__18CXX) 
.................... 	// Use Timer0 for 8 bit processors 
....................     // Initialize the time 
....................     TMR0H = 0; 
*
0296:  CLRF   FD7
....................     TMR0L = 0; 
0298:  CLRF   FD6
....................  
.................... 	// Set up the timer interrupt 
.................... 	INTCON2bits.TMR0IP = 0;		// Low priority 
029A:  BCF    FF1.2
....................     INTCONbits.TMR0IF = 0; 
029C:  BCF    FF2.2
....................     INTCONbits.TMR0IE = 1;		// Enable interrupt 
029E:  BSF    FF2.5
....................  
....................     // Timer0 on, 16-bit, internal timer, 1:256 prescalar 
....................     T0CON = 0x87; 
02A0:  MOVLW  87
02A2:  MOVWF  FD5
....................  
.................... #else 
02A4:  GOTO   7BF0 (RETURN)
.................... 	// Use Timer 1 for 16-bit and 32-bit processors 
.................... 	// 1:256 prescale 
.................... 	T1CONbits.TCKPS = 3; 
.................... 	// Base 
.................... 	PR1 = 0xFFFF; 
.................... 	// Clear counter 
.................... 	TMR1 = 0; 
....................  
.................... 	// Enable timer interrupt 
.................... 	#if defined(__C30__) 
.................... 		IPC0bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0bits.T1IF = 0; 
.................... 		IEC0bits.T1IE = 1; 
.................... 	#else 
.................... 		IPC1bits.T1IP = 2;	// Interrupt priority 2 (low) 
.................... 		IFS0CLR = _IFS0_T1IF_MASK; 
.................... 		IEC0SET = _IEC0_T1IE_MASK; 
.................... 	#endif 
....................  
.................... 	// Start timer 
.................... 	T1CONbits.TON = 1; 
.................... #endif 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void GetTickCopy(void) 
....................  
....................   Summary: 
.................... 	Reads the tick value. 
....................  
....................   Description: 
.................... 	This function performs an interrupt-safe and synchronized read of the  
.................... 	48-bit Tick value. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... static void GetTickCopy(void) 
.................... { 
.................... 	// Perform an Interrupt safe and synchronized read of the 48-bit  
.................... 	// tick value 
.................... #if defined(__18CXX) 
.................... 	do 
.................... 	{ 
.................... 		INTCONbits.TMR0IE = 1;		// Enable interrupt 
*
2658:  BSF    FF2.5
.................... 		Nop(); 
265A:  NOP   
.................... 		INTCONbits.TMR0IE = 0;		// Disable interrupt 
265C:  BCF    FF2.5
.................... 		vTickReading[0] = TMR0L; 
265E:  MOVFF  FD6,118
.................... 		vTickReading[1] = TMR0H; 
2662:  MOVFF  FD7,119
.................... 		*((DWORD*)&vTickReading[2]) = dwInternalTicks; 
2666:  MOVLW  01
2668:  MOVLB  4
266A:  MOVWF  x11
266C:  MOVLW  1A
266E:  MOVWF  FE9
2670:  MOVFF  411,FEA
2674:  MOVFF  114,FEF
2678:  MOVFF  115,FEC
267C:  MOVFF  116,FEC
2680:  MOVFF  117,FEC
.................... 	} while(INTCONbits.TMR0IF); 
2684:  BTFSS  FF2.2
2686:  BRA    268C
2688:  MOVLB  0
268A:  BRA    2658
.................... 	INTCONbits.TMR0IE = 1;			// Enable interrupt 
268C:  BSF    FF2.5
.................... #elif defined(__C30__) 
268E:  MOVLB  0
2690:  RETURN 0
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0bits.T1IE = 1;			// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0bits.T1IE = 0;			// Disable interrupt 
....................  
.................... 		// Get low 2 bytes 
.................... 		((WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
.................... 		if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 			dwTempTicks--; 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0bits.T1IE = 1;				// Enable interrupt 
.................... #else	// PIC32 
.................... 	do 
.................... 	{ 
.................... 		DWORD dwTempTicks; 
.................... 		 
.................... 		IEC0SET = _IEC0_T1IE_MASK;	// Enable interrupt 
.................... 		Nop(); 
.................... 		IEC0CLR = _IEC0_T1IE_MASK;	// Disable interrupt 
.................... 		 
.................... 		// Get low 2 bytes 
.................... 		((volatile WORD*)vTickReading)[0] = TMR1; 
.................... 		 
.................... 		// Correct corner case where interrupt increments byte[4+] but  
.................... 		// TMR1 hasn't rolled over to 0x0000 yet 
.................... 		dwTempTicks = dwInternalTicks; 
....................  
.................... 		// PIC32MX3XX/4XX devices trigger the timer interrupt when TMR1 == PR1  
.................... 		// (TMR1 prescalar is 0x00), requiring us to undo the ISR's increment  
.................... 		// of the upper 32 bits of our 48 bit timer in the special case when  
.................... 		// TMR1 == PR1 == 0xFFFF.  For other PIC32 families, the ISR is  
.................... 		// triggered when TMR1 increments from PR1 to 0x0000, making no special  
.................... 		// corner case. 
.................... 		#if __PIC32_FEATURE_SET__ <= 460 
.................... 			if(((WORD*)vTickReading)[0] == 0xFFFFu) 
.................... 				dwTempTicks--; 
.................... 		#elif !defined(__PIC32_FEATURE_SET__) 
.................... 			#error __PIC32_FEATURE_SET__ macro must be defined.  You need to download a newer C32 compiler version. 
.................... 		#endif 
.................... 		 
.................... 		// Get high 4 bytes 
.................... 		vTickReading[2] = ((BYTE*)&dwTempTicks)[0]; 
.................... 		vTickReading[3] = ((BYTE*)&dwTempTicks)[1]; 
.................... 		vTickReading[4] = ((BYTE*)&dwTempTicks)[2]; 
.................... 		vTickReading[5] = ((BYTE*)&dwTempTicks)[3]; 
.................... 	} while(IFS0bits.T1IF); 
.................... 	IEC0SET = _IEC0_T1IE_MASK;		// Enable interrupt 
.................... #endif 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGet(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the least significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	microseconds to a few hours.  Use TickGetDiv256 or TickGetDiv64K for 
.................... 	longer periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Lower 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGet(void) 
.................... { 
.................... 	GetTickCopy(); 
2692:  RCALL  2658
.................... 	return *((DWORD*)&vTickReading[0]); 
2694:  MOVLW  01
2696:  MOVLB  4
2698:  MOVWF  x11
269A:  MOVLW  18
269C:  MOVFF  411,03
26A0:  MOVWF  FE9
26A2:  MOVFF  411,FEA
26A6:  MOVFF  FEF,00
26AA:  MOVFF  FEC,01
26AE:  MOVFF  FEC,02
26B2:  MOVFF  FEC,03
26B6:  MOVLB  0
26B8:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv256(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 256. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the middle 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	minutes to a few weeks.  Use TickGet for shorter periods or TickGetDiv64K 
.................... 	for longer ones. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Middle 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv256(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
*
322C:  CALL   2658
.................... 	((BYTE*)&dw)[0] = vTickReading[1];	// Note: This copy must be done one  
3230:  MOVFF  119,3E6
.................... 	((BYTE*)&dw)[1] = vTickReading[2];	// byte at a time to prevent misaligned  
3234:  MOVFF  11A,3E7
.................... 	((BYTE*)&dw)[2] = vTickReading[3];	// memory reads, which will reset the PIC. 
3238:  MOVFF  11B,3E8
.................... 	((BYTE*)&dw)[3] = vTickReading[4]; 
323C:  MOVFF  11C,3E9
.................... 	 
.................... 	return dw; 
3240:  MOVFF  3E6,00
3244:  MOVFF  3E7,01
3248:  MOVFF  3E8,02
324C:  MOVFF  3E9,03
3250:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickGetDiv64K(void) 
....................  
....................   Summary: 
.................... 	Obtains the current Tick value divided by 64K. 
....................  
....................   Description: 
.................... 	This function retrieves the current Tick value, allowing timing and 
.................... 	measurement code to be written in a non-blocking fashion.  This function 
.................... 	retrieves the most significant 32 bits of the internal tick counter,  
.................... 	and is useful for measuring time increments ranging from a few  
.................... 	days to a few years, or for absolute time measurements.  Use TickGet or 
.................... 	TickGetDiv256 for shorter periods of time. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	Upper 32 bits of the current Tick value. 
....................   ***************************************************************************/ 
.................... DWORD TickGetDiv64K(void) 
.................... { 
.................... 	DWORD dw; 
....................  
.................... 	GetTickCopy(); 
.................... 	((BYTE*)&dw)[0] = vTickReading[2];	// Note: This copy must be done one  
.................... 	((BYTE*)&dw)[1] = vTickReading[3];	// byte at a time to prevent misaligned  
.................... 	((BYTE*)&dw)[2] = vTickReading[4];	// memory reads, which will reset the PIC. 
.................... 	((BYTE*)&dw)[3] = vTickReading[5]; 
.................... 	 
.................... 	return dw; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
....................  
....................   Summary: 
.................... 	Converts a Tick value or difference to milliseconds. 
....................  
....................   Description: 
.................... 	This function converts a Tick value or difference to milliseconds.  For 
.................... 	example, TickConvertToMilliseconds(32768) returns 1000 when a 32.768kHz  
.................... 	clock with no prescaler drives the Tick module interrupt. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	dwTickValue	- Value to convert to milliseconds 
....................  
....................   Returns: 
....................   	Input value expressed in milliseconds. 
....................  
....................   Remarks: 
.................... 	This function performs division on DWORDs, which is slow.  Avoid using 
.................... 	it unless you absolutely must (such as displaying data to a user).  For 
.................... 	timeout comparisons, compare the current value to a multiple or fraction  
.................... 	of TICK_SECOND, which will be calculated only once at compile time. 
....................   ***************************************************************************/ 
.................... DWORD TickConvertToMilliseconds(DWORD dwTickValue) 
.................... { 
.................... 	return (dwTickValue+(TICKS_PER_SECOND/2000ul))/((DWORD)(TICKS_PER_SECOND/1000ul)); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void TickUpdate(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... void TickUpdate(void) 
.................... { 
....................     if(INTCONbits.TMR0IF) 
*
00B4:  BTFSS  FF2.2
00B6:  BRA    00CC
....................     { 
.................... 		// Increment internal high tick counter 
.................... 		dwInternalTicks++; 
00B8:  MOVLW  01
00BA:  MOVLB  1
00BC:  ADDWF  x14,F
00BE:  BTFSC  FD8.0
00C0:  INCF   x15,F
00C2:  BTFSC  FD8.2
00C4:  INCF   x16,F
00C6:  BTFSC  FD8.2
00C8:  INCF   x17,F
....................  
.................... 		// Reset interrupt flag 
....................         INTCONbits.TMR0IF = 0; 
00CA:  BCF    FF2.2
00CC:  MOVLB  0
....................     } 
00CE:  GOTO   00D4 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void _ISR _T1Interrupt(void) 
....................  
....................   Description: 
.................... 	Updates the tick value when an interrupt occurs. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
....................   	None 
....................   ***************************************************************************/ 
.................... #elif defined(__PIC32MX__) 
.................... void __attribute((interrupt(ipl2), vector(_TIMER_1_VECTOR), nomips16)) _T1Interrupt(void) 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0CLR = _IFS0_T1IF_MASK; 
.................... } 
.................... #else 
.................... #if defined(__PCD__)  //__CCS__ __PCH__ __PCD__ ccs added 
.................... #int_timer1 NOCLEAR 
.................... void _T1Interrupt(void) 
.................... #elif __C30_VERSION__ >= 300 
.................... void _ISR __attribute__((__no_auto_psv__)) _T1Interrupt(void) 
.................... #else 
.................... void _ISR _T1Interrupt(void) 
.................... #endif 
.................... { 
.................... 	// Increment internal high tick counter 
.................... 	dwInternalTicks++; 
....................  
.................... 	// Reset interrupt flag 
.................... 	IFS0bits.T1IF = 0; 
.................... } 
.................... #endif 
....................  
.................... #if !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS) && !defined(ENC100_INTERFACE_MODE) && \ 
....................     (defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) || \ 
....................      defined(_18F97J60) ||  defined(_18F96J65) ||  defined(_18F96J60) ||  defined(_18F87J60) ||  defined(_18F86J65) ||  defined(_18F86J60) ||  defined(_18F67J60) ||  defined(_18F66J65) ||  defined(_18F66J60)) 
....................    #include "ETH97J60.c" 
.................... #elif defined(WF_CS_TRIS) 
....................       #include "WF_Config.c" 
....................       #if defined(WF_USE_SCAN_FUNCTIONS) 
....................          #include "WFScan.c" 
....................       #endif 
....................       #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................          #include "WFPowerSave.c" 
....................       #else 
....................          BOOL GetAppPowerSaveMode(void) {return(TRUE);} 
....................       #endif 
....................       #if defined(WF_USE_TX_POWER_CONTROL_FUNCTIONS) 
....................          #include "WFTxPower.c" 
....................       #endif 
....................       #include "WF_Spi.c" 
....................       #include "WF_Eint.c" 
....................       #include "WFConnectionProfile.c" 
....................       #include "WFConnectionAlgorithm.c" 
....................       #include "WFConnectionManager.c" 
....................       #include "WFEventHandler.c" 
....................       #include "WFInit.c" 
....................      #if defined(STACK_USE_CCS_SCAN_TASK) 
....................       #include "ccs_wifiscan.c" 
....................      #endif       
....................      #if defined(MRF24WG) 
....................       #include "WFDriverCom_24G.c" 
....................       #include "WFDriverRaw_24G.c" 
....................       #include "WFMac_24G.c" 
....................       #include "WFMgmtMsg_24G.c" 
....................       #include "WFParamMsg_24G.c"      
....................      #else 
....................       #include "WFDriverCom.c" 
....................       #include "WFDriverRaw.c" 
....................       #include "WFMac.c" 
....................       #include "WFMgmtMsg.c" 
....................       #include "WFParamMsg.c" 
....................      #endif 
.................... #elif defined(ENC_CS_TRIS) 
....................    #include "tcpip\ENC28J60.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Medium Access Control (MAC) Layer for Microchip ENC28J60 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides access to ENC28J60 Ethernet controller 
....................  *   -Reference: ENC28J60 Data sheet, IEEE 802.3 Standard 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                  MAC.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  Delay.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder     6/28/04 Original 
....................  * Howard Schlunder     10/8/04 Cleanup 
....................  * Howard Schlunder     10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder     11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder     12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder     1/09/06 Added comments and minor mods 
....................  * Howard Schlunder     1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder     6/16/06 Synchronized with PIC18F97J60 code 
....................  * Howard Schlunder     7/17/06 Updated TestMemory() for C30 
....................  * Howard Schlunder     8/07/06 Added SetRXHashTableEntry() function 
.................... ********************************************************************/ 
.................... #define __ENC28J60_C 
....................  
.................... #include "HardwareProfile.h" 
.................... #ifndef __HARDWAREPROFILE_H__ 
.................... #define __HARDWAREPROFILE_H__ 
....................  
.................... #define ENC_CS_IO        LATCbits.LATC1 
.................... #define ENC_CS_TRIS      TRISCbits.TRISC1 
.................... #define ENC_SCK_TRIS     TRISCbits.TRISC3 
.................... #define ENC_SDI_TRIS     TRISCbits.TRISC4 
.................... #define ENC_SDO_TRIS     TRISCbits.TRISC5 
.................... #define ENC_RST_IO       LATCbits.LATC0 
.................... #define ENC_RST_TRIS     TRISCbits.TRISC0 
.................... #define ENC_SSPBUF       SSPBUF 
.................... #define ENC_SPISTAT      SSPSTAT 
.................... #define ENC_SPISTATbits  SSPSTATbits 
.................... #define ENC_SPICON1      SSPCON1 
.................... #define ENC_SPICON1bits  SSPCON1bits 
.................... #define ENC_SPICON2      SSPCON2 
.................... #define ENC_SPICON2bits  SSPCON2bits 
.................... #define ENC_SPI_IF       PIR1bits.SSPIF 
....................  
....................  
.................... #endif 
....................  
....................  
.................... // Make sure that this hardware profile has an ENC28J60 in it 
.................... #if defined(ENC_CS_TRIS) 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (ENC_SPI_IF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the ENC_SPI_IF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                  ((a) & 0xFF) 
.................... #define HIGH(a)                 (((a)>>8) & 0xFF) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define WCR (0x2<<5)            // Write Control Register command 
.................... #define BFS (0x4<<5)            // Bit Field Set command 
.................... #define BFC (0x5<<5)            // Bit Field Clear command 
.................... #define RCR (0x0<<5)            // Read Control Register command 
.................... #define RBM ((0x1<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define WBM ((0x3<<5) | 0x1A)   // Write Buffer Memory command 
.................... #define SR  ((0x7<<5) | 0x1F)   // System Reset command does not use an address. 
....................                                 //   It requires 0x1F, however. 
....................  
.................... // Maximum SPI frequency specified in data sheet 
.................... #define ENC_MAX_SPI_FREQ    (20000000ul)    // Hz 
....................  
.................... #define ETHER_IP    (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... #if defined(__CCS__) 
.................... typedef struct  __attribute__((packed)) 
.................... #else 
.................... typedef struct  __attribute__((aligned(2), packed)) 
.................... #endif 
.................... { 
....................     WORD            NextPacketPointer; 
....................     RXSTATUS        StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
....................  
.................... #if defined (__18CXX) 
....................     #define ClearSPIDoneFlag()  {ENC_SPI_IF = 0;} 
....................     #define WaitForDataByte()   {while(!ENC_SPI_IF); ENC_SPI_IF = 0;} 
....................     #define SPI_ON_BIT          (ENC_SPICON1bits.SSPEN) 
.................... #elif defined(__C30__) 
....................     #define ClearSPIDoneFlag() 
....................     static inline __attribute__((__always_inline__)) void WaitForDataByte( void ) 
....................     { 
....................         while ((ENC_SPISTATbits.SPITBF == 1) || (ENC_SPISTATbits.SPIRBF == 0)); 
....................     } 
....................  
....................     #define SPI_ON_BIT          (ENC_SPISTATbits.SPIEN) 
.................... #elif defined( __PIC32MX__ ) 
....................     #define ClearSPIDoneFlag() 
....................     static inline __attribute__((__always_inline__)) void WaitForDataByte( void ) 
....................     { 
....................         while (!ENC_SPISTATbits.SPITBE || !ENC_SPISTATbits.SPIRBF); 
....................     } 
....................  
....................     #define SPI_ON_BIT          (ENC_SPICON1bits.ON) 
.................... #else 
....................     #error Determine SPI flag mechanism 
.................... #endif 
....................  
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... //void Get8KBRAM(void); 
....................  
.................... // Internal MAC level variables and flags. 
.................... static WORD_VAL NextPacketLocation; 
.................... static WORD_VAL CurrentPacketLocation; 
.................... static BOOL WasDiscarded; 
.................... static BYTE ENCRevID; 
....................  
....................  
.................... //NOTE: All code in this module expects Bank 0 to be currently selected.  If code ever changes the bank, it must restore it to Bank 0 before returning. 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *                  registers in the ENC28J60 so that normal operation can 
....................  *                  begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................     BYTE i; 
....................  
....................     // Set up the SPI module on the PIC for communications with the ENC28J60 
....................     ENC_CS_IO = 1; 
*
0728:  BSF    F8B.1
....................     ENC_CS_TRIS = 0;        // Make the Chip Select pin an output 
072A:  BCF    F94.1
....................  
.................... #if defined(__18CXX) 
....................     ENC_SCK_TRIS = 0; 
072C:  BCF    F94.3
....................     ENC_SDO_TRIS = 0; 
072E:  BCF    F94.5
....................     ENC_SDI_TRIS = 1; 
0730:  BSF    F94.4
.................... #endif 
....................  
....................     // If the RESET pin is connected, take the chip out of reset 
.................... #if defined(ENC_RST_IO) 
....................     ENC_RST_IO      = 1; 
0732:  BSF    F8B.0
....................     ENC_RST_TRIS    = 0; 
0734:  BCF    F94.0
.................... #endif 
....................  
....................     // Set up SPI 
....................     ClearSPIDoneFlag(); 
0736:  BCF    F9E.3
.................... #if defined(__18CXX) 
....................     ENC_SPICON1 = 0x20;     // SSPEN bit is set, SPI in master mode, FOSC/4, 
0738:  MOVLW  20
073A:  MOVWF  FC6
....................                             //   IDLE state is low level 
....................     ENC_SPISTATbits.CKE = 1;// Transmit data on rising edge of clock 
073C:  BSF    FC7.6
....................     ENC_SPISTATbits.SMP = 0;// Input sampled at middle of data output time 
073E:  BCF    FC7.7
.................... #elif defined(__C30__) 
....................     ENC_SPISTAT = 0;        // clear SPI 
....................     #if defined(__PIC24H__) || defined(__dsPIC33F__) || defined(__dsPIC33E__)|| defined(__PIC24E__) 
....................         ENC_SPICON1 = 0x0F;     // 1:1 primary prescale, 5:1 secondary prescale (8MHz  @ 40MIPS) 
....................     //    ENC_SPICON1 = 0x1E;   // 4:1 primary prescale, 1:1 secondary prescale (10MHz @ 40MIPS, Doesn't work.  CLKRDY is incorrectly reported as being clear.  Problem caused by dsPIC33/PIC24H ES silicon bug.) 
....................     #elif defined(__PIC24F__) || defined(__PIC24FK__) 
....................         ENC_SPICON1 = 0x1B;     // 1:1 primary prescale, 2:1 secondary prescale (8MHz  @ 16MIPS) 
....................     #else   // dsPIC30F 
....................         ENC_SPICON1 = 0x17;     // 1:1 primary prescale, 3:1 secondary prescale (10MHz @ 30MIPS) 
....................     #endif 
....................     ENC_SPICON2 = 0; 
....................     ENC_SPICON1bits.CKE = 1; 
....................     ENC_SPICON1bits.MSTEN = 1; 
....................     ENC_SPISTATbits.SPIEN = 1; 
.................... #elif defined(__C32__) 
....................     ENC_SPIBRG = (GetPeripheralClock()-1ul)/2ul/ENC_MAX_SPI_FREQ; 
....................    ENC_SPICON1bits.SMP = 1;   // Delay SDI input sampling (PIC perspective) by 1/2 SPI clock 
....................     ENC_SPICON1bits.CKE = 1; 
....................     ENC_SPICON1bits.MSTEN = 1; 
....................     ENC_SPICON1bits.ON = 1; 
.................... #endif 
....................  
....................     // RESET the entire ENC28J60, clearing all registers 
....................     // Also wait for CLKRDY to become set. 
....................     // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................     // means the part is in RESET or there is something wrong with the SPI 
....................     // connection.  This loop makes sure that we can communicate with the 
....................     // ENC28J60 before proceeding. 
....................     do 
....................     { 
....................         SendSystemReset(); 
0740:  BRA    0542
....................         i = ReadETHReg(ESTAT).Val; 
0742:  MOVLW  1D
0744:  MOVLB  4
0746:  MOVWF  x30
0748:  MOVLB  0
074A:  RCALL  057A
074C:  MOVFF  01,37B
....................     } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
0750:  MOVLB  3
0752:  BTFSS  x7B.3
0754:  BRA    075A
0756:  MOVLB  0
0758:  BRA    0740
075A:  MOVF   x7B,W
075C:  XORLW  FF
075E:  ANDLW  01
0760:  BTFSC  FD8.2
0762:  BRA    0768
0764:  MOVLB  0
0766:  BRA    0740
....................  
....................     // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................     // and the buffer write protect pointer (receive buffer read pointer) 
....................     WasDiscarded = TRUE; 
0768:  MOVLB  1
076A:  BSF    x0B.2
....................     NextPacketLocation.Val = RXSTART; 
076C:  CLRF   x1F
076E:  CLRF   x1E
....................  
....................     WriteReg(ERXSTL, LOW(RXSTART)); 
0770:  MOVLW  08
0772:  MOVLB  4
0774:  MOVWF  x35
0776:  CLRF   x36
0778:  MOVLB  0
077A:  RCALL  05A4
....................     WriteReg(ERXSTH, HIGH(RXSTART)); 
077C:  MOVLW  09
077E:  MOVLB  4
0780:  MOVWF  x35
0782:  CLRF   x36
0784:  MOVLB  0
0786:  RCALL  05A4
....................     WriteReg(ERXRDPTL, LOW(RXSTOP));    // Write low byte first 
0788:  MOVLW  0C
078A:  MOVLB  4
078C:  MOVWF  x35
078E:  MOVLW  D5
0790:  MOVWF  x36
0792:  MOVLB  0
0794:  RCALL  05A4
....................     WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
0796:  MOVLW  0D
0798:  MOVLB  4
079A:  MOVWF  x35
079C:  MOVLW  11
079E:  MOVWF  x36
07A0:  MOVLB  0
07A2:  RCALL  05A4
....................     WriteReg(ERXNDL, LOW(RXSTOP)); 
07A4:  MOVLW  0A
07A6:  MOVLB  4
07A8:  MOVWF  x35
07AA:  MOVLW  D5
07AC:  MOVWF  x36
07AE:  MOVLB  0
07B0:  RCALL  05A4
....................     WriteReg(ERXNDH, HIGH(RXSTOP)); 
07B2:  MOVLW  0B
07B4:  MOVLB  4
07B6:  MOVWF  x35
07B8:  MOVLW  11
07BA:  MOVWF  x36
07BC:  MOVLB  0
07BE:  RCALL  05A4
....................     WriteReg(ETXSTL, LOW(TXSTART)); 
07C0:  MOVLW  04
07C2:  MOVLB  4
07C4:  MOVWF  x35
07C6:  MOVLW  D6
07C8:  MOVWF  x36
07CA:  MOVLB  0
07CC:  RCALL  05A4
....................     WriteReg(ETXSTH, HIGH(TXSTART)); 
07CE:  MOVLW  05
07D0:  MOVLB  4
07D2:  MOVWF  x35
07D4:  MOVLW  11
07D6:  MOVWF  x36
07D8:  MOVLB  0
07DA:  RCALL  05A4
....................  
....................     // Write a permanant per packet control byte of 0x00 
....................     WriteReg(EWRPTL, LOW(TXSTART)); 
07DC:  MOVLW  02
07DE:  MOVLB  4
07E0:  MOVWF  x35
07E2:  MOVLW  D6
07E4:  MOVWF  x36
07E6:  MOVLB  0
07E8:  RCALL  05A4
....................     WriteReg(EWRPTH, HIGH(TXSTART)); 
07EA:  MOVLW  03
07EC:  MOVLB  4
07EE:  MOVWF  x35
07F0:  MOVLW  11
07F2:  MOVWF  x36
07F4:  MOVLB  0
07F6:  RCALL  05A4
....................     MACPut(0x00); 
07F8:  MOVLB  4
07FA:  CLRF   x33
07FC:  MOVLB  0
07FE:  RCALL  05CE
....................  
....................  
....................     // Enter Bank 1 and configure Receive Filters 
....................     // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................     // acceptable) 
....................     // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................  
....................     // Promiscious mode example: 
....................     //BankSel(ERXFCON); 
....................     //WriteReg((BYTE)ERXFCON, ERXFCON_CRCEN); 
....................  
....................     // Enter Bank 2 and configure the MAC 
....................     BankSel(MACON1); 
0800:  MOVLW  02
0802:  MOVLB  4
0804:  MOVWF  x15
0806:  CLRF   x14
0808:  MOVLB  0
080A:  RCALL  061C
....................  
....................     // Enable the receive portion of the MAC 
....................     WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
080C:  MOVLB  4
080E:  CLRF   x35
0810:  MOVLW  0D
0812:  MOVWF  x36
0814:  MOVLB  0
0816:  RCALL  05A4
....................  
....................     // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
.................... #if defined(FULL_DUPLEX) 
....................     WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN | MACON3_FULDPX); 
....................     WriteReg((BYTE)MABBIPG, 0x15); 
.................... #else 
....................     WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
0818:  MOVLW  02
081A:  MOVLB  4
081C:  MOVWF  x35
081E:  MOVLW  32
0820:  MOVWF  x36
0822:  MOVLB  0
0824:  RCALL  05A4
....................     WriteReg((BYTE)MABBIPG, 0x12); 
0826:  MOVLW  04
0828:  MOVLB  4
082A:  MOVWF  x35
082C:  MOVLW  12
082E:  MOVWF  x36
0830:  MOVLB  0
0832:  RCALL  05A4
.................... #endif 
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
0834:  MOVLW  03
0836:  MOVLB  4
0838:  MOVWF  x35
083A:  MOVLW  40
083C:  MOVWF  x36
083E:  MOVLB  0
0840:  RCALL  05A4
....................  
....................     // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................     // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................     // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
0842:  MOVLW  09
0844:  MOVLB  4
0846:  MOVWF  x35
0848:  MOVLW  3F
084A:  MOVWF  x36
084C:  MOVLB  0
084E:  RCALL  05A4
....................  
....................     // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................     // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................     // later. 
....................     WriteReg((BYTE)MAIPGL, 0x12); 
0850:  MOVLW  06
0852:  MOVLB  4
0854:  MOVWF  x35
0856:  MOVLW  12
0858:  MOVWF  x36
085A:  MOVLB  0
085C:  RCALL  05A4
....................     WriteReg((BYTE)MAIPGH, 0x0C); 
085E:  MOVLW  07
0860:  MOVLB  4
0862:  MOVWF  x35
0864:  MOVLW  0C
0866:  MOVWF  x36
0868:  MOVLB  0
086A:  RCALL  05A4
....................  
....................     // Set the maximum packet size which the controller will accept 
....................     WriteReg((BYTE)MAMXFLL, LOW(6+6+2+1500+4));  // 1518 is the IEEE 802.3 specified limit 
086C:  MOVLW  0A
086E:  MOVLB  4
0870:  MOVWF  x35
0872:  MOVLW  EE
0874:  MOVWF  x36
0876:  MOVLB  0
0878:  RCALL  05A4
....................     WriteReg((BYTE)MAMXFLH, HIGH(6+6+2+1500+4)); // 1518 is the IEEE 802.3 specified limit 
087A:  MOVLW  0B
087C:  MOVLB  4
087E:  MOVWF  x35
0880:  MOVLW  05
0882:  MOVWF  x36
0884:  MOVLB  0
0886:  RCALL  05A4
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................     BankSel(MAADR1); 
0888:  MOVLW  03
088A:  MOVLB  4
088C:  MOVWF  x15
088E:  MOVLW  04
0890:  MOVWF  x14
0892:  MOVLB  0
0894:  RCALL  061C
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
0896:  MOVLW  04
0898:  MOVLB  4
089A:  MOVWF  x35
089C:  MOVFF  4F,436
08A0:  MOVLB  0
08A2:  RCALL  05A4
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
08A4:  MOVLW  05
08A6:  MOVLB  4
08A8:  MOVWF  x35
08AA:  MOVFF  50,436
08AE:  MOVLB  0
08B0:  RCALL  05A4
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
08B2:  MOVLW  02
08B4:  MOVLB  4
08B6:  MOVWF  x35
08B8:  MOVFF  51,436
08BC:  MOVLB  0
08BE:  RCALL  05A4
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
08C0:  MOVLW  03
08C2:  MOVLB  4
08C4:  MOVWF  x35
08C6:  MOVFF  52,436
08CA:  MOVLB  0
08CC:  RCALL  05A4
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
08CE:  MOVLB  4
08D0:  CLRF   x35
08D2:  MOVFF  53,436
08D6:  MOVLB  0
08D8:  RCALL  05A4
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
08DA:  MOVLW  01
08DC:  MOVLB  4
08DE:  MOVWF  x35
08E0:  MOVFF  54,436
08E4:  MOVLB  0
08E6:  RCALL  05A4
....................  
....................     // Disable the CLKOUT output to reduce EMI generation 
....................     WriteReg((BYTE)ECOCON, 0x00);   // Output off (0V) 
08E8:  MOVLW  15
08EA:  MOVLB  4
08EC:  MOVWF  x35
08EE:  CLRF   x36
08F0:  MOVLB  0
08F2:  RCALL  05A4
....................     //WriteReg((BYTE)ECOCON, 0x01); // 25.000MHz 
....................     //WriteReg((BYTE)ECOCON, 0x03); // 8.3333MHz (*4 with PLL is 33.3333MHz) 
....................  
....................     // Get the Rev ID so that we can implement the correct errata workarounds 
....................     ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
08F4:  MOVLW  12
08F6:  MOVLB  4
08F8:  MOVWF  x30
08FA:  MOVLB  0
08FC:  RCALL  057A
08FE:  MOVFF  01,122
....................  
....................     // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................     // side effect. 
....................     WritePHYReg(PHCON2, PHCON2_HDLDIS); 
0902:  MOVLW  10
0904:  MOVLB  3
0906:  MOVWF  x7C
0908:  MOVLW  01
090A:  MOVWF  x7E
090C:  CLRF   x7D
090E:  MOVLB  0
0910:  RCALL  0688
....................  
....................     // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................     SetLEDConfig(0x3472); 
0912:  MOVLW  14
0914:  MOVLB  3
0916:  MOVWF  x7C
0918:  MOVLW  34
091A:  MOVWF  x7E
091C:  MOVLW  72
091E:  MOVWF  x7D
0920:  MOVLB  0
0922:  RCALL  0688
....................  
....................     // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................     WritePHYReg(PHCON1, PHCON1_PDPXMD); 
.................... #elif defined(HALF_DUPLEX) 
....................     WritePHYReg(PHCON1, 0x0000); 
0924:  MOVLB  3
0926:  CLRF   x7C
0928:  CLRF   x7E
092A:  CLRF   x7D
092C:  MOVLB  0
092E:  RCALL  0688
.................... #else 
....................     // Use the external LEDB polarity to determine weather full or half duplex 
....................     // communication mode should be set. 
....................     { 
....................         REG Register; 
....................         PHYREG PhyReg; 
....................  
....................         // Read the PHY duplex mode 
....................         PhyReg = ReadPHYReg(PHCON1); 
....................         DuplexState = PhyReg.PHCON1bits.PDPXMD; 
....................  
....................         // Set the MAC to the proper duplex mode 
....................         BankSel(MACON3); 
....................         Register = ReadMACReg((BYTE)MACON3); 
....................         Register.MACON3bits.FULDPX = PhyReg.PHCON1bits.PDPXMD; 
....................         WriteReg((BYTE)MACON3, Register.Val); 
....................  
....................         // Set the back-to-back inter-packet gap time to IEEE specified 
....................         // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................         // state, so it must be updated in this function. 
....................         // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................         WriteReg((BYTE)MABBIPG, PhyReg.PHCON1bits.PDPXMD ? 0x15 : 0x12); 
....................     } 
.................... #endif 
....................  
....................     BankSel(ERDPTL);        // Return to default Bank 0 
0930:  MOVLB  4
0932:  CLRF   x15
0934:  CLRF   x14
0936:  MOVLB  0
0938:  RCALL  061C
....................  
....................     // Enable packet reception 
....................     BFSReg(ECON1, ECON1_RXEN); 
093A:  MOVLW  1F
093C:  MOVLB  4
093E:  MOVWF  x2A
0940:  MOVLW  04
0942:  MOVWF  x2B
0944:  MOVLB  0
0946:  RCALL  05F2
0948:  GOTO   14EC (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                        and the link has been up continuously since the last 
....................  *                        call to MACIsLinked() 
....................  *                  FALSE: If the PHY reports no link partner, or the link went 
....................  *                         down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................     // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................     // goes down and comes back up before a higher level stack program calls 
....................     // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................     // call to MACIsLinked() will return TRUE (unless the link goes down 
....................     // again). 
....................     return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
*
187A:  MOVLW  01
187C:  MOVLB  3
187E:  MOVWF  x9C
1880:  MOVLB  0
1882:  BRA    17BE
1884:  MOVFF  01,39C
1888:  MOVLW  00
188A:  MOVLB  3
188C:  BTFSC  01.2
188E:  MOVLW  01
1890:  MOVWF  01
1892:  MOVLB  0
1894:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *                  FALSE: If a previous transmission was started, and it has 
....................  *                         not completed yet.  While FALSE, the data in the 
....................  *                         transmit buffer and the TXST/TXND pointers must not 
....................  *                         be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(void) 
.................... { 
....................     return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
19F2:  MOVLW  1F
19F4:  MOVLB  4
19F6:  MOVWF  x30
19F8:  MOVLB  0
19FA:  CALL   057A
19FE:  MOVFF  01,410
1A02:  MOVLW  00
1A04:  MOVLB  4
1A06:  BTFSC  01.3
1A08:  MOVLW  01
1A0A:  XORLW  00
1A0C:  BZ    1A12
1A0E:  MOVLW  00
1A10:  BRA    1A14
1A12:  MOVLW  01
1A14:  MOVWF  01
1A16:  MOVLB  0
1A18:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *                  MACGetHeader())as being processed and frees the buffer 
....................  *                  memory associated with it 
....................  * 
....................  * Note:            Is is safe to call this function multiple times between 
....................  *                  MACGetHeader() calls.  Extra packets won't be thrown away 
....................  *                  until MACGetHeader() makes it available. 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................     WORD_VAL NewRXRDLocation; 
....................  
....................     // Make sure the current packet was not already discarded 
....................     if(WasDiscarded) 
*
2870:  MOVLB  1
2872:  BTFSS  x0B.2
2874:  BRA    2878
....................         return; 
2876:  BRA    28D6
....................     WasDiscarded = TRUE; 
2878:  BSF    x0B.2
....................  
....................     // Decrement the next packet pointer before writing it into 
....................     // the ERXRDPT registers.  This is a silicon errata workaround. 
....................     // RX buffer wrapping must be taken into account if the 
....................     // NextPacketLocation is precisely RXSTART. 
....................     NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
287A:  MOVLW  01
287C:  SUBWF  x1E,W
287E:  MOVLB  3
2880:  MOVWF  xC6
2882:  MOVLW  00
2884:  MOVLB  1
2886:  SUBWFB x1F,W
2888:  MOVLB  3
288A:  MOVWF  xC7
....................     if(NewRXRDLocation.Val > RXSTOP) 
288C:  MOVF   xC7,W
288E:  SUBLW  10
2890:  BC    28A4
2892:  XORLW  FF
2894:  BNZ   289C
2896:  MOVF   xC6,W
2898:  SUBLW  D5
289A:  BC    28A4
....................     { 
....................         NewRXRDLocation.Val = RXSTOP; 
289C:  MOVLW  11
289E:  MOVWF  xC7
28A0:  MOVLW  D5
28A2:  MOVWF  xC6
....................     } 
....................  
....................     // Decrement the RX packet counter register, EPKTCNT 
....................     BFSReg(ECON2, ECON2_PKTDEC); 
28A4:  MOVLW  1E
28A6:  MOVLB  4
28A8:  MOVWF  x2A
28AA:  MOVLW  40
28AC:  MOVWF  x2B
28AE:  MOVLB  0
28B0:  CALL   05F2
....................  
....................     // Move the receive read pointer to unwrite-protect the memory used by the 
....................     // last packet.  The writing order is important: set the low byte first, 
....................     // high byte last. 
....................     WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
28B4:  MOVLW  0C
28B6:  MOVLB  4
28B8:  MOVWF  x35
28BA:  MOVFF  3C6,436
28BE:  MOVLB  0
28C0:  CALL   05A4
....................     WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
28C4:  MOVLW  0D
28C6:  MOVLB  4
28C8:  MOVWF  x35
28CA:  MOVFF  3C7,436
28CE:  MOVLB  0
28D0:  CALL   05A4
28D4:  MOVLB  1
28D6:  MOVLB  0
28D8:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *                  the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................     WORD_VAL ReadPT, WritePT; 
....................  
....................     // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................     // received at any time, it can change between reading the low and high 
....................     // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................     // is read. 
....................     BankSel(EPKTCNT); 
*
3274:  MOVLW  01
3276:  MOVLB  4
3278:  MOVWF  x15
327A:  MOVLW  19
327C:  MOVWF  x14
327E:  MOVLB  0
3280:  CALL   061C
....................     do { 
....................         // Save EPKTCNT in a temporary location 
....................         ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
3284:  MOVLW  19
3286:  MOVLB  4
3288:  MOVWF  x30
328A:  MOVLB  0
328C:  CALL   057A
3290:  MOVFF  01,410
....................  
....................         BankSel(ERXWRPTL); 
3294:  MOVLB  4
3296:  CLRF   x15
3298:  MOVLW  0E
329A:  MOVWF  x14
329C:  MOVLB  0
329E:  CALL   061C
....................         WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
32A2:  MOVLW  0E
32A4:  MOVLB  4
32A6:  MOVWF  x30
32A8:  MOVLB  0
32AA:  CALL   057A
32AE:  MOVFF  01,412
....................         WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
32B2:  MOVLW  0F
32B4:  MOVLB  4
32B6:  MOVWF  x30
32B8:  MOVLB  0
32BA:  CALL   057A
32BE:  MOVFF  01,413
....................  
....................         BankSel(EPKTCNT); 
32C2:  MOVLW  01
32C4:  MOVLB  4
32C6:  MOVWF  x15
32C8:  MOVLW  19
32CA:  MOVWF  x14
32CC:  MOVLB  0
32CE:  CALL   061C
....................     } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
32D2:  MOVLW  19
32D4:  MOVLB  4
32D6:  MOVWF  x30
32D8:  MOVLB  0
32DA:  CALL   057A
32DE:  MOVFF  01,414
32E2:  MOVLB  4
32E4:  MOVF   x10,W
32E6:  SUBWF  01,W
32E8:  BTFSC  FD8.2
32EA:  BRA    32F0
32EC:  MOVLB  0
32EE:  BRA    3284
....................  
....................     // Determine where the write protection pointer is 
....................     BankSel(ERXRDPTL); 
32F0:  CLRF   x15
32F2:  MOVLW  0C
32F4:  MOVWF  x14
32F6:  MOVLB  0
32F8:  CALL   061C
....................     ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
32FC:  MOVLW  0C
32FE:  MOVLB  4
3300:  MOVWF  x30
3302:  MOVLB  0
3304:  CALL   057A
3308:  MOVFF  01,410
....................     ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
330C:  MOVLW  0D
330E:  MOVLB  4
3310:  MOVWF  x30
3312:  MOVLB  0
3314:  CALL   057A
3318:  MOVFF  01,411
....................  
....................     // Calculate the difference between the pointers, taking care to account 
....................     // for buffer wrapping conditions 
....................     if(WritePT.Val > ReadPT.Val) 
331C:  MOVLB  4
331E:  MOVF   x11,W
3320:  SUBWF  x13,W
3322:  BNC   3350
3324:  BNZ   332C
3326:  MOVF   x12,W
3328:  SUBWF  x10,W
332A:  BC    3350
....................     { 
....................         return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
332C:  MOVF   x10,W
332E:  SUBWF  x12,W
3330:  MOVWF  00
3332:  MOVF   x11,W
3334:  SUBWFB x13,W
3336:  MOVWF  03
3338:  MOVF   00,W
333A:  XORLW  FF
333C:  ADDLW  D6
333E:  MOVWF  00
3340:  MOVLW  11
3342:  SUBFWB 03,F
3344:  MOVFF  00,01
3348:  MOVFF  03,02
334C:  BRA    3386
....................     } 
334E:  BRA    3386
....................     else if(WritePT.Val == ReadPT.Val) 
3350:  MOVF   x10,W
3352:  SUBWF  x12,W
3354:  BNZ   3368
3356:  MOVF   x11,W
3358:  SUBWF  x13,W
335A:  BNZ   3368
....................     { 
....................         return RXSIZE - 1; 
335C:  MOVLW  D5
335E:  MOVWF  01
3360:  MOVLW  11
3362:  MOVWF  02
3364:  BRA    3386
....................     } 
3366:  BRA    3386
....................     else 
....................     { 
....................         return ReadPT.Val - WritePT.Val - 1; 
3368:  MOVF   x12,W
336A:  SUBWF  x10,W
336C:  MOVWF  x14
336E:  MOVF   x13,W
3370:  SUBWFB x11,W
3372:  MOVWF  x15
3374:  MOVLW  01
3376:  SUBWF  x14,W
3378:  MOVWF  00
337A:  MOVLW  00
337C:  SUBWFB x15,W
337E:  MOVWF  03
3380:  MOVFF  00,01
3384:  MOVWF  02
....................     } 
3386:  MOVLB  0
3388:  GOTO   3D00 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                           received frame. 
....................  *                  *type: Location of a BYTE to store the constant 
....................  *                         MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                         the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                        remote, and type values are updated. 
....................  *                  FALSE: If a packet was not pending.  remote and type are 
....................  *                         not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *                  been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................     ENC_PREAMBLE header; 
....................     BYTE PacketCount; 
....................  
....................     // Test if at least one packet has been received and is waiting 
....................     BankSel(EPKTCNT); 
*
487A:  MOVLW  01
487C:  MOVLB  4
487E:  MOVWF  x15
4880:  MOVLW  19
4882:  MOVWF  x14
4884:  MOVLB  0
4886:  CALL   061C
....................     PacketCount = ReadETHReg((BYTE)EPKTCNT).Val; 
488A:  MOVLW  19
488C:  MOVLB  4
488E:  MOVWF  x30
4890:  MOVLB  0
4892:  CALL   057A
4896:  MOVFF  01,3B3
....................     BankSel(ERDPTL); 
489A:  MOVLB  4
489C:  CLRF   x15
489E:  CLRF   x14
48A0:  MOVLB  0
48A2:  CALL   061C
....................     if(PacketCount == 0u) 
48A6:  MOVLB  3
48A8:  MOVF   xB3,F
48AA:  BNZ   48B2
....................         return FALSE; 
48AC:  MOVLW  00
48AE:  MOVWF  01
48B0:  BRA    49CA
....................  
....................     // Make absolutely certain that any previous packet was discarded 
....................     if(WasDiscarded == FALSE) 
48B2:  MOVLB  1
48B4:  BTFSC  x0B.2
48B6:  BRA    48C8
....................     { 
....................         MACDiscardRx(); 
48B8:  MOVLB  0
48BA:  CALL   2870
....................         return FALSE; 
48BE:  MOVLW  00
48C0:  MOVWF  01
48C2:  MOVLB  3
48C4:  BRA    49CA
48C6:  MOVLB  1
....................     } 
....................  
....................     // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................     CurrentPacketLocation.Val = NextPacketLocation.Val; 
48C8:  MOVFF  11F,121
48CC:  MOVFF  11E,120
....................     WriteReg(ERDPTL, CurrentPacketLocation.v[0]); 
48D0:  MOVLB  4
48D2:  CLRF   x35
48D4:  MOVFF  120,436
48D8:  MOVLB  0
48DA:  CALL   05A4
....................     WriteReg(ERDPTH, CurrentPacketLocation.v[1]); 
48DE:  MOVLW  01
48E0:  MOVLB  4
48E2:  MOVWF  x35
48E4:  MOVFF  121,436
48E8:  MOVLB  0
48EA:  CALL   05A4
....................  
....................     // Obtain the MAC header from the Ethernet buffer 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
48EE:  MOVLW  03
48F0:  MOVLB  3
48F2:  MOVWF  xB5
48F4:  MOVLW  9F
48F6:  MOVWF  xB4
48F8:  MOVFF  3B5,433
48FC:  MOVFF  FE8,432
4900:  MOVLB  4
4902:  CLRF   x35
4904:  MOVLW  14
4906:  MOVWF  x34
4908:  MOVLB  0
490A:  CALL   0BD0
....................  
....................     // The EtherType field, like most items transmitted on the Ethernet medium 
....................     // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
490E:  MOVFF  3B2,430
4912:  MOVFF  3B1,42F
4916:  CALL   1C92
491A:  MOVFF  02,3B2
491E:  MOVFF  01,3B1
....................  
....................     // Validate the data returned from the ENC28J60.  Random data corruption, 
....................     // such as if a single SPI bit error occurs while communicating or a 
....................     // momentary power glitch could cause this to occur in rare circumstances. 
....................     if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................        header.StatusVector.bits.Zero || 
....................        header.StatusVector.bits.CRCError || 
....................        header.StatusVector.bits.ByteCount > 1518u || 
....................        !header.StatusVector.bits.ReceiveOk) 
4922:  MOVLB  3
4924:  MOVF   xA0,W
4926:  SUBLW  10
4928:  BC    4934
492A:  XORLW  FF
492C:  BNZ   4960
492E:  MOVF   x9F,W
4930:  SUBLW  D5
4932:  BNC   4960
4934:  MOVLW  03
4936:  MOVWF  xB5
4938:  MOVLW  9F
493A:  MOVWF  FE9
493C:  MOVFF  3B5,FEA
4940:  BTFSC  FEF.0
4942:  BRA    4960
4944:  BTFSC  xA4.7
4946:  BRA    4960
4948:  BTFSC  xA3.4
494A:  BRA    4960
494C:  MOVF   xA2,W
494E:  SUBLW  04
4950:  BC    495C
4952:  XORLW  FF
4954:  BNZ   4960
4956:  MOVF   xA1,W
4958:  SUBLW  EE
495A:  BNC   4960
495C:  BTFSC  xA3.7
495E:  BRA    4962
....................     { 
....................         Reset(); 
4960:  RESET
....................     } 
....................  
....................     // Save the location where the hardware will write the next packet to 
....................     NextPacketLocation.Val = header.NextPacketPointer; 
4962:  MOVFF  3A0,11F
4966:  MOVFF  39F,11E
....................  
....................     // Return the Ethernet frame's Source MAC address field to the caller 
....................     // This parameter is useful for replying to requests without requiring an 
....................     // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
496A:  MOVFF  39C,03
496E:  MOVFF  39B,3B4
4972:  MOVFF  39C,3B5
4976:  MOVLW  03
4978:  MOVWF  xB7
497A:  MOVLW  AB
497C:  MOVFF  39C,FEA
4980:  MOVFF  39B,FE9
4984:  MOVFF  3B7,FE2
4988:  MOVWF  FE1
498A:  MOVLW  06
498C:  MOVWF  01
498E:  MOVFF  FE6,FEE
4992:  DECFSZ 01,F
4994:  BRA    498E
....................  
....................     // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
4996:  MOVFF  39E,03
499A:  MOVFF  39D,FE9
499E:  MOVFF  03,FEA
49A2:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................         ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
49A4:  MOVF   xB2,W
49A6:  SUBLW  08
49A8:  BNZ   49C0
49AA:  MOVF   xB1,F
49AC:  BZ    49B4
49AE:  MOVF   xB1,W
49B0:  SUBLW  06
49B2:  BNZ   49C0
....................     { 
....................         *type = header.Type.v[0]; 
49B4:  MOVFF  39D,FE9
49B8:  MOVFF  39E,FEA
49BC:  MOVFF  3B1,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
49C0:  MOVLB  1
49C2:  BCF    x0B.2
....................     return TRUE; 
49C4:  MOVLW  01
49C6:  MOVWF  01
49C8:  MOVLB  3
49CA:  MOVLB  0
49CC:  GOTO   6DB8 (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                           MAC address (6 bytes) 
....................  *                  type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                        value to write into the Ethernet header's type field. 
....................  *                  dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *                  advantagous to call this function immediately before 
....................  *                  transmitting a packet rather than initially when the 
....................  *                  packet is first created.  The order in which the packet 
....................  *                  is constructed (header first or data first) is not 
....................  *                  important. 
....................  *****************************************************************************/ 
.................... void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) 
.................... { 
....................     // Set the SPI write pointer to the beginning of the transmit buffer (post per packet control byte) 
....................     WriteReg(EWRPTL, LOW(TXSTART+1)); 
*
1E76:  MOVLW  02
1E78:  MOVLB  4
1E7A:  MOVWF  x35
1E7C:  MOVLW  D7
1E7E:  MOVWF  x36
1E80:  MOVLB  0
1E82:  CALL   05A4
....................     WriteReg(EWRPTH, HIGH(TXSTART+1)); 
1E86:  MOVLW  03
1E88:  MOVLB  4
1E8A:  MOVWF  x35
1E8C:  MOVLW  11
1E8E:  MOVWF  x36
1E90:  MOVLB  0
1E92:  CALL   05A4
....................  
....................     // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
1E96:  MOVLW  E4
1E98:  MOVLB  4
1E9A:  ADDWF  x30,F
1E9C:  MOVLW  11
1E9E:  ADDWFC x31,F
....................  
....................     // Write the TXND pointer into the registers, given the dataLen given 
....................     WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
1EA0:  MOVLW  04
1EA2:  MOVWF  x33
1EA4:  MOVLW  30
1EA6:  MOVWF  x32
1EA8:  MOVWF  FE9
1EAA:  MOVFF  433,FEA
1EAE:  MOVFF  FEF,434
1EB2:  MOVLW  06
1EB4:  MOVWF  x35
1EB6:  MOVFF  434,436
1EBA:  MOVLB  0
1EBC:  CALL   05A4
....................     WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
1EC0:  MOVLW  04
1EC2:  MOVLB  4
1EC4:  MOVWF  x33
1EC6:  MOVLW  30
1EC8:  MOVWF  x32
1ECA:  MOVLW  01
1ECC:  ADDWF  x32,W
1ECE:  MOVWF  FE9
1ED0:  MOVLW  00
1ED2:  ADDWFC x33,W
1ED4:  MOVWF  FEA
1ED6:  MOVFF  FEF,434
1EDA:  MOVLW  07
1EDC:  MOVWF  x35
1EDE:  MOVFF  434,436
1EE2:  MOVLB  0
1EE4:  CALL   05A4
....................  
....................     // Set the per-packet control byte and write the Ethernet destination 
....................     // address 
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
1EE8:  MOVFF  42E,435
1EEC:  MOVFF  42D,434
1EF0:  MOVLB  4
1EF2:  CLRF   x37
1EF4:  MOVLW  06
1EF6:  MOVWF  x36
1EF8:  MOVLB  0
1EFA:  CALL   0B1E
....................  
....................     // Write our MAC address in the Ethernet source field 
....................     MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
1EFE:  MOVLB  4
1F00:  CLRF   x33
1F02:  MOVLW  4F
1F04:  MOVWF  x32
1F06:  MOVFF  433,435
1F0A:  MOVWF  x34
1F0C:  CLRF   x37
1F0E:  MOVLW  06
1F10:  MOVWF  x36
1F12:  MOVLB  0
1F14:  CALL   0B1E
....................  
....................     // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
1F18:  MOVLW  08
1F1A:  MOVLB  4
1F1C:  MOVWF  x33
1F1E:  MOVLB  0
1F20:  CALL   05CE
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
1F24:  MOVLB  4
1F26:  MOVF   x2F,F
1F28:  BNZ   1F2E
1F2A:  MOVLW  00
1F2C:  BRA    1F30
1F2E:  MOVLW  06
1F30:  MOVWF  x32
1F32:  MOVWF  x33
1F34:  MOVLB  0
1F36:  CALL   05CE
1F3A:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *                  MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *                  the Ethernet medium.  The hardware MAC will take control 
....................  *                  and handle CRC generation, collision retransmission and 
....................  *                  other details. 
....................  * 
....................  * Note:            After transmission completes (MACIsTxReady() returns TRUE), 
....................  *                  the packet can be modified and transmitted again by calling 
....................  *                  MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *                  called (in the TX data area), the data in the TX buffer 
....................  *                  will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
....................     // Reset transmit logic if a TX Error has previously occured 
....................     // This is a silicon errata workaround 
....................     BFSReg(ECON1, ECON1_TXRST); 
*
2026:  MOVLW  1F
2028:  MOVLB  4
202A:  MOVWF  x2A
202C:  MOVLW  80
202E:  MOVWF  x2B
2030:  MOVLB  0
2032:  CALL   05F2
....................     BFCReg(ECON1, ECON1_TXRST); 
2036:  MOVLW  1F
2038:  MOVLB  4
203A:  MOVWF  x2A
203C:  MOVLW  80
203E:  MOVWF  x2B
2040:  MOVLB  0
2042:  CALL   04F0
....................     BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
2046:  MOVLW  1C
2048:  MOVLB  4
204A:  MOVWF  x2A
204C:  MOVLW  0A
204E:  MOVWF  x2B
2050:  MOVLB  0
2052:  CALL   04F0
....................  
....................     // Start the transmission 
....................     // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................     // can be modified and transmitted again by calling MACFlush() again. 
....................     // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................     // corrupted. 
....................     BFSReg(ECON1, ECON1_TXRTS); 
2056:  MOVLW  1F
2058:  MOVLB  4
205A:  MOVWF  x2A
205C:  MOVLW  08
205E:  MOVWF  x2B
2060:  MOVLB  0
2062:  CALL   05F2
....................  
....................     // Revision B5 and B7 silicon errata workaround 
....................     if(ENCRevID == 0x05u || ENCRevID == 0x06u) 
2066:  MOVLB  1
2068:  MOVF   x22,W
206A:  SUBLW  05
206C:  BZ    2076
206E:  MOVF   x22,W
2070:  SUBLW  06
2072:  BTFSS  FD8.2
2074:  BRA    225A
....................     { 
....................         WORD AttemptCounter = 0x0000; 
2076:  MOVLB  4
2078:  CLRF   x11
207A:  CLRF   x10
....................         while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF)) && (++AttemptCounter < 1000u)); 
207C:  MOVLW  1C
207E:  MOVWF  x30
2080:  MOVLB  0
2082:  CALL   057A
2086:  MOVFF  01,41E
208A:  MOVLB  4
208C:  MOVF   01,W
208E:  ANDLW  0A
2090:  BNZ   20A6
2092:  INCF   x10,F
2094:  BTFSC  FD8.2
2096:  INCF   x11,F
2098:  MOVF   x11,W
209A:  SUBLW  03
209C:  BNC   20A6
209E:  BNZ   207C
20A0:  MOVF   x10,W
20A2:  SUBLW  E7
20A4:  BC    207C
....................         if(ReadETHReg(EIR).EIRbits.TXERIF || (AttemptCounter >= 1000u)) 
20A6:  MOVLW  1C
20A8:  MOVWF  x30
20AA:  MOVLB  0
20AC:  CALL   057A
20B0:  MOVFF  01,41E
20B4:  MOVLW  00
20B6:  MOVLB  4
20B8:  BTFSC  01.1
20BA:  MOVLW  01
20BC:  XORLW  00
20BE:  BNZ   20D4
20C0:  MOVF   x11,W
20C2:  SUBLW  02
20C4:  BTFSC  FD8.0
20C6:  BRA    2258
20C8:  XORLW  FF
20CA:  BNZ   20D4
20CC:  MOVF   x10,W
20CE:  SUBLW  E7
20D0:  BTFSC  FD8.0
20D2:  BRA    2258
....................         { 
....................             WORD_VAL ReadPtrSave; 
....................             WORD_VAL TXEnd; 
....................             TXSTATUS TXStatus; 
....................             BYTE i; 
....................  
....................             // Cancel the previous transmission if it has become stuck set 
....................             BFCReg(ECON1, ECON1_TXRTS); 
20D4:  MOVLW  1F
20D6:  MOVWF  x2A
20D8:  MOVLW  08
20DA:  MOVWF  x2B
20DC:  MOVLB  0
20DE:  CALL   04F0
....................  
....................             // Save the current read pointer (controlled by application) 
....................             ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
20E2:  MOVLB  4
20E4:  CLRF   x30
20E6:  MOVLB  0
20E8:  CALL   057A
20EC:  MOVFF  01,412
....................             ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
20F0:  MOVLW  01
20F2:  MOVLB  4
20F4:  MOVWF  x30
20F6:  MOVLB  0
20F8:  CALL   057A
20FC:  MOVFF  01,413
....................  
....................             // Get the location of the transmit status vector 
....................             TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
2100:  MOVLW  06
2102:  MOVLB  4
2104:  MOVWF  x30
2106:  MOVLB  0
2108:  CALL   057A
210C:  MOVFF  01,414
....................             TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
2110:  MOVLW  07
2112:  MOVLB  4
2114:  MOVWF  x30
2116:  MOVLB  0
2118:  CALL   057A
211C:  MOVFF  01,415
....................             TXEnd.Val++; 
2120:  MOVLB  4
2122:  INCF   x14,F
2124:  BTFSC  FD8.2
2126:  INCF   x15,F
....................  
....................             // Read the transmit status vector 
....................             WriteReg(ERDPTL, TXEnd.v[0]); 
2128:  CLRF   x35
212A:  MOVFF  414,436
212E:  MOVLB  0
2130:  CALL   05A4
....................             WriteReg(ERDPTH, TXEnd.v[1]); 
2134:  MOVLW  01
2136:  MOVLB  4
2138:  MOVWF  x35
213A:  MOVFF  415,436
213E:  MOVLB  0
2140:  CALL   05A4
....................             MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
2144:  MOVLW  04
2146:  MOVLB  4
2148:  MOVWF  x1F
214A:  MOVLW  16
214C:  MOVWF  x1E
214E:  MOVFF  41F,433
2152:  MOVWF  x32
2154:  CLRF   x35
2156:  MOVLW  07
2158:  MOVWF  x34
215A:  MOVLB  0
215C:  CALL   0BD0
....................  
....................             // Implement retransmission if a late collision occured (this can 
....................             // happen on B5 when certain link pulses arrive at the same time 
....................             // as the transmission) 
....................             for(i = 0; i < 16u; i++) 
2160:  MOVLB  4
2162:  CLRF   x1D
2164:  MOVF   x1D,W
2166:  SUBLW  0F
2168:  BNC   223A
....................             { 
....................                 if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
216A:  MOVLW  1C
216C:  MOVWF  x30
216E:  MOVLB  0
2170:  CALL   057A
2174:  MOVFF  01,41E
2178:  MOVLW  00
217A:  MOVLB  4
217C:  BTFSC  01.1
217E:  MOVLW  01
2180:  XORLW  00
2182:  BZ    2230
2184:  BTFSS  x19.5
2186:  BRA    2230
....................                 { 
....................                     // Reset the TX logic 
....................                     BFSReg(ECON1, ECON1_TXRST); 
2188:  MOVLW  1F
218A:  MOVWF  x2A
218C:  MOVLW  80
218E:  MOVWF  x2B
2190:  MOVLB  0
2192:  CALL   05F2
....................                     BFCReg(ECON1, ECON1_TXRST); 
2196:  MOVLW  1F
2198:  MOVLB  4
219A:  MOVWF  x2A
219C:  MOVLW  80
219E:  MOVWF  x2B
21A0:  MOVLB  0
21A2:  CALL   04F0
....................                     BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
21A6:  MOVLW  1C
21A8:  MOVLB  4
21AA:  MOVWF  x2A
21AC:  MOVLW  0A
21AE:  MOVWF  x2B
21B0:  MOVLB  0
21B2:  CALL   04F0
....................  
....................                     // Transmit the packet again 
....................                     BFSReg(ECON1, ECON1_TXRTS); 
21B6:  MOVLW  1F
21B8:  MOVLB  4
21BA:  MOVWF  x2A
21BC:  MOVLW  08
21BE:  MOVWF  x2B
21C0:  MOVLB  0
21C2:  CALL   05F2
....................                     while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
21C6:  MOVLW  1C
21C8:  MOVLB  4
21CA:  MOVWF  x30
21CC:  MOVLB  0
21CE:  CALL   057A
21D2:  MOVFF  01,41E
21D6:  MOVLB  4
21D8:  MOVF   01,W
21DA:  ANDLW  0A
21DC:  BTFSS  FD8.2
21DE:  BRA    21E4
21E0:  MOVLB  0
21E2:  BRA    21C6
....................  
....................                     // Cancel the previous transmission if it has become stuck set 
....................                     BFCReg(ECON1, ECON1_TXRTS); 
21E4:  MOVLW  1F
21E6:  MOVWF  x2A
21E8:  MOVLW  08
21EA:  MOVWF  x2B
21EC:  MOVLB  0
21EE:  CALL   04F0
....................  
....................                     // Read transmit status vector 
....................                     WriteReg(ERDPTL, TXEnd.v[0]); 
21F2:  MOVLB  4
21F4:  CLRF   x35
21F6:  MOVFF  414,436
21FA:  MOVLB  0
21FC:  CALL   05A4
....................                     WriteReg(ERDPTH, TXEnd.v[1]); 
2200:  MOVLW  01
2202:  MOVLB  4
2204:  MOVWF  x35
2206:  MOVFF  415,436
220A:  MOVLB  0
220C:  CALL   05A4
....................                     MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
2210:  MOVLW  04
2212:  MOVLB  4
2214:  MOVWF  x1F
2216:  MOVLW  16
2218:  MOVWF  x1E
221A:  MOVFF  41F,433
221E:  MOVWF  x32
2220:  CLRF   x35
2222:  MOVLW  07
2224:  MOVWF  x34
2226:  MOVLB  0
2228:  CALL   0BD0
....................                 } 
222C:  BRA    2234
222E:  MOVLB  4
....................                 else 
....................                 { 
....................                     break; 
2230:  BRA    223A
2232:  MOVLB  0
....................                 } 
2234:  MOVLB  4
2236:  INCF   x1D,F
2238:  BRA    2164
....................             } 
....................  
....................             // Restore the current read pointer 
....................             WriteReg(ERDPTL, ReadPtrSave.v[0]); 
223A:  CLRF   x35
223C:  MOVFF  412,436
2240:  MOVLB  0
2242:  CALL   05A4
....................             WriteReg(ERDPTH, ReadPtrSave.v[1]); 
2246:  MOVLW  01
2248:  MOVLB  4
224A:  MOVWF  x35
224C:  MOVFF  413,436
2250:  MOVLB  0
2252:  CALL   05A4
2256:  MOVLB  4
2258:  MOVLB  1
....................         } 
....................     } 
225A:  MOVLB  0
225C:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetReadPtrInRx(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *                  getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                          header's type field to relocate the SPI read 
....................  *                          pointer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read pointer are updated.  All calls to 
....................  *                  MACGet() and MACGetArray() will use these new values. 
....................  * 
....................  * Note:            RXSTOP must be statically defined as being > RXSTART for 
....................  *                  this function to work correctly.  In other words, do not 
....................  *                  define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *                  boundary. 
....................  *****************************************************************************/ 
.................... void MACSetReadPtrInRx(WORD offset) 
.................... { 
....................     WORD_VAL ReadPT; 
....................  
....................     // Determine the address of the beginning of the entire packet 
....................     // and adjust the address to the desired location 
....................     ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
26BA:  MOVLW  14
26BC:  MOVLB  1
26BE:  ADDWF  x20,W
26C0:  MOVLB  3
26C2:  MOVWF  xF2
26C4:  MOVLW  00
26C6:  MOVLB  1
26C8:  ADDWFC x21,W
26CA:  MOVLB  3
26CC:  MOVWF  xF3
26CE:  MOVF   xEE,W
26D0:  ADDWF  xF2,W
26D2:  MOVWF  xF0
26D4:  MOVF   xEF,W
26D6:  ADDWFC xF3,W
26D8:  MOVWF  xF1
....................  
....................     // Since the receive buffer is circular, adjust if a wraparound is needed 
....................     if(ReadPT.Val > RXSTOP) 
26DA:  MOVF   xF1,W
26DC:  SUBLW  10
26DE:  BC    26F2
26E0:  XORLW  FF
26E2:  BNZ   26EA
26E4:  MOVF   xF0,W
26E6:  SUBLW  D5
26E8:  BC    26F2
....................         ReadPT.Val -= RXSIZE; 
26EA:  MOVLW  D6
26EC:  SUBWF  xF0,F
26EE:  MOVLW  11
26F0:  SUBWFB xF1,F
....................  
....................     // Set the SPI read pointer to the new calculated value 
....................     WriteReg(ERDPTL, ReadPT.v[0]); 
26F2:  MOVLB  4
26F4:  CLRF   x35
26F6:  MOVFF  3F0,436
26FA:  MOVLB  0
26FC:  CALL   05A4
....................     WriteReg(ERDPTH, ReadPT.v[1]); 
2700:  MOVLW  01
2702:  MOVLB  4
2704:  MOVWF  x35
2706:  MOVFF  3F1,436
270A:  MOVLB  0
270C:  CALL   05A4
2710:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetWritePtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old EWRPT location 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *                  MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetWritePtr(PTR_BASE address) 
.................... { 
....................     WORD_VAL oldVal; 
....................  
....................     oldVal.v[0] = ReadETHReg(EWRPTL).Val; 
*
0AAE:  MOVLW  02
0AB0:  MOVLB  4
0AB2:  MOVWF  x30
0AB4:  MOVLB  0
0AB6:  RCALL  057A
0AB8:  MOVFF  01,421
....................     oldVal.v[1] = ReadETHReg(EWRPTH).Val; 
0ABC:  MOVLW  03
0ABE:  MOVLB  4
0AC0:  MOVWF  x30
0AC2:  MOVLB  0
0AC4:  RCALL  057A
0AC6:  MOVFF  01,422
....................  
....................     // Set the SPI write pointer to the new calculated value 
....................     WriteReg(EWRPTL, ((WORD_VAL*)&address)->v[0]); 
0ACA:  MOVLW  04
0ACC:  MOVLB  4
0ACE:  MOVWF  x24
0AD0:  MOVLW  1F
0AD2:  MOVWF  x23
0AD4:  MOVWF  FE9
0AD6:  MOVFF  424,FEA
0ADA:  MOVFF  FEF,425
0ADE:  MOVLW  02
0AE0:  MOVWF  x35
0AE2:  MOVFF  425,436
0AE6:  MOVLB  0
0AE8:  RCALL  05A4
....................     WriteReg(EWRPTH, ((WORD_VAL*)&address)->v[1]); 
0AEA:  MOVLW  04
0AEC:  MOVLB  4
0AEE:  MOVWF  x24
0AF0:  MOVLW  1F
0AF2:  MOVWF  x23
0AF4:  MOVLW  01
0AF6:  ADDWF  x23,W
0AF8:  MOVWF  FE9
0AFA:  MOVLW  00
0AFC:  ADDWFC x24,W
0AFE:  MOVWF  FEA
0B00:  MOVFF  FEF,425
0B04:  MOVLW  03
0B06:  MOVWF  x35
0B08:  MOVFF  425,436
0B0C:  MOVLB  0
0B0E:  RCALL  05A4
....................  
....................     return oldVal.Val; 
0B10:  MOVLB  4
0B12:  MOVFF  421,01
0B16:  MOVFF  422,02
0B1A:  MOVLB  0
0B1C:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        PTR_BASE MACSetReadPtr(PTR_BASE Address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Address: Address to seek to 
....................  * 
....................  * Output:          WORD: Old ERDPT value 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI write pointer is updated.  All calls to 
....................  *                  MACPut() and MACPutArray() will use this new value. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PTR_BASE MACSetReadPtr(PTR_BASE address) 
.................... { 
....................     WORD_VAL oldVal; 
....................  
....................     oldVal.v[0] = ReadETHReg(ERDPTL).Val; 
*
0B64:  MOVLB  4
0B66:  CLRF   x30
0B68:  MOVLB  0
0B6A:  RCALL  057A
0B6C:  MOVFF  01,421
....................     oldVal.v[1] = ReadETHReg(ERDPTH).Val; 
0B70:  MOVLW  01
0B72:  MOVLB  4
0B74:  MOVWF  x30
0B76:  MOVLB  0
0B78:  RCALL  057A
0B7A:  MOVFF  01,422
....................  
....................     // Set the SPI write pointer to the new calculated value 
....................     WriteReg(ERDPTL, ((WORD_VAL*)&address)->v[0]); 
0B7E:  MOVLW  04
0B80:  MOVLB  4
0B82:  MOVWF  x24
0B84:  MOVLW  1F
0B86:  MOVWF  x23
0B88:  MOVWF  FE9
0B8A:  MOVFF  424,FEA
0B8E:  MOVFF  FEF,425
0B92:  CLRF   x35
0B94:  MOVFF  425,436
0B98:  MOVLB  0
0B9A:  RCALL  05A4
....................     WriteReg(ERDPTH, ((WORD_VAL*)&address)->v[1]); 
0B9C:  MOVLW  04
0B9E:  MOVLB  4
0BA0:  MOVWF  x24
0BA2:  MOVLW  1F
0BA4:  MOVWF  x23
0BA6:  MOVLW  01
0BA8:  ADDWF  x23,W
0BAA:  MOVWF  FE9
0BAC:  MOVLW  00
0BAE:  ADDWFC x24,W
0BB0:  MOVWF  FEA
0BB2:  MOVFF  FEF,425
0BB6:  MOVLW  01
0BB8:  MOVWF  x35
0BBA:  MOVFF  425,436
0BBE:  MOVLB  0
0BC0:  RCALL  05A4
....................  
....................     return oldVal.Val; 
0BC2:  MOVLB  4
0BC4:  MOVFF  421,01
0BC8:  MOVFF  422,02
0BCC:  MOVLB  0
0BCE:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset  - Number of bytes beyond the beginning of the 
....................  *                          Ethernet data (first byte after the type field) 
....................  *                          where the checksum should begin 
....................  *                  len     - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................     WORD_VAL temp; 
....................     WORD_VAL RDSave; 
....................  
....................     // Add the offset requested by firmware plus the Ethernet header 
....................     temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
4CCC:  MOVLW  14
4CCE:  MOVLB  1
4CD0:  ADDWF  x20,W
4CD2:  MOVLB  3
4CD4:  MOVWF  xC1
4CD6:  MOVLW  00
4CD8:  MOVLB  1
4CDA:  ADDWFC x21,W
4CDC:  MOVLB  3
4CDE:  MOVWF  xC2
4CE0:  MOVF   xB9,W
4CE2:  ADDWF  xC1,W
4CE4:  MOVWF  xBD
4CE6:  MOVF   xBA,W
4CE8:  ADDWFC xC2,W
4CEA:  MOVWF  xBE
....................     if(temp.Val > RXSTOP)       // Adjust value if a wrap is needed 
4CEC:  MOVF   xBE,W
4CEE:  SUBLW  10
4CF0:  BC    4D04
4CF2:  XORLW  FF
4CF4:  BNZ   4CFC
4CF6:  MOVF   xBD,W
4CF8:  SUBLW  D5
4CFA:  BC    4D04
....................     { 
....................         temp.Val -= RXSIZE; 
4CFC:  MOVLW  D6
4CFE:  SUBWF  xBD,F
4D00:  MOVLW  11
4D02:  SUBWFB xBE,F
....................     } 
....................  
....................     RDSave.v[0] = ReadETHReg(ERDPTL).Val; 
4D04:  MOVLB  4
4D06:  CLRF   x30
4D08:  MOVLB  0
4D0A:  CALL   057A
4D0E:  MOVFF  01,3BF
....................     RDSave.v[1] = ReadETHReg(ERDPTH).Val; 
4D12:  MOVLW  01
4D14:  MOVLB  4
4D16:  MOVWF  x30
4D18:  MOVLB  0
4D1A:  CALL   057A
4D1E:  MOVFF  01,3C0
....................  
....................     WriteReg(ERDPTL, temp.v[0]); 
4D22:  MOVLB  4
4D24:  CLRF   x35
4D26:  MOVFF  3BD,436
4D2A:  MOVLB  0
4D2C:  CALL   05A4
....................     WriteReg(ERDPTH, temp.v[1]); 
4D30:  MOVLW  01
4D32:  MOVLB  4
4D34:  MOVWF  x35
4D36:  MOVFF  3BE,436
4D3A:  MOVLB  0
4D3C:  CALL   05A4
....................  
....................     temp.Val = CalcIPBufferChecksum(len); 
4D40:  MOVFF  3BC,411
4D44:  MOVFF  3BB,410
4D48:  CALL   3728
4D4C:  MOVFF  02,3BE
4D50:  MOVFF  01,3BD
....................  
....................     WriteReg(ERDPTL, RDSave.v[0]); 
4D54:  MOVLB  4
4D56:  CLRF   x35
4D58:  MOVFF  3BF,436
4D5C:  MOVLB  0
4D5E:  CALL   05A4
....................     WriteReg(ERDPTH, RDSave.v[1]); 
4D62:  MOVLW  01
4D64:  MOVLB  4
4D66:  MOVWF  x35
4D68:  MOVFF  3C0,436
4D6C:  MOVLB  0
4D6E:  CALL   05A4
....................  
....................     return temp.Val; 
4D72:  MOVLB  3
4D74:  MOVFF  3BD,01
4D78:  MOVFF  3BE,02
4D7C:  MOVLB  0
4D7E:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                       The first byte included in the checksum is the byte 
....................  *                       pointed to by ERDPT, which is updated by calls to 
....................  *                       MACSetReadPtr(), MACGet(), MACGetArray(), 
....................  *                       MACGetHeader(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by RFC 793 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *                  which can calculate the checksum faster than software, so 
....................  *                  this function replaces the CaclIPBufferChecksum() function 
....................  *                  defined in the helpers.c file.  Through the use of 
....................  *                  preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *                  buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     WORD_VAL Start; 
....................     DWORD_VAL Checksum = {0x00000000ul}; 
*
3728:  MOVLB  4
372A:  CLRF   x14
372C:  CLRF   x15
372E:  CLRF   x16
3730:  CLRF   x17
....................     WORD ChunkLen; 
....................     WORD DataBuffer[10]; 
....................     WORD *DataPtr; 
....................  
....................     // Save the SPI read pointer starting address 
....................     Start.v[0] = ReadETHReg(ERDPTL).Val; 
3732:  CLRF   x30
3734:  MOVLB  0
3736:  CALL   057A
373A:  MOVFF  01,412
....................     Start.v[1] = ReadETHReg(ERDPTH).Val; 
373E:  MOVLW  01
3740:  MOVLB  4
3742:  MOVWF  x30
3744:  MOVLB  0
3746:  CALL   057A
374A:  MOVFF  01,413
....................  
....................     while(len) 
374E:  MOVLB  4
3750:  MOVF   x10,W
3752:  IORWF  x11,W
3754:  BZ    3806
....................     { 
....................         // Obtain a chunk of data (less SPI overhead compared 
....................         // to requesting one byte at a time) 
....................         ChunkLen = len > sizeof(DataBuffer) ? sizeof(DataBuffer) : len; 
3756:  MOVF   x11,F
3758:  BNZ   3760
375A:  MOVF   x10,W
375C:  SUBLW  14
375E:  BC    3766
3760:  CLRF   03
3762:  MOVLW  14
3764:  BRA    376C
3766:  MOVFF  411,03
376A:  MOVF   x10,W
376C:  MOVWF  x18
376E:  MOVFF  03,419
....................         MACGetArray((BYTE*)DataBuffer, ChunkLen); 
3772:  MOVLW  04
3774:  MOVWF  x31
3776:  MOVLW  1A
3778:  MOVWF  x30
377A:  MOVFF  431,433
377E:  MOVWF  x32
3780:  MOVFF  419,435
3784:  MOVFF  418,434
3788:  MOVLB  0
378A:  CALL   0BD0
....................  
....................         len -= ChunkLen; 
378E:  MOVLB  4
3790:  MOVF   x18,W
3792:  SUBWF  x10,F
3794:  MOVF   x19,W
3796:  SUBWFB x11,F
....................  
....................         // Take care of a last odd numbered data byte 
....................         if(((WORD_VAL*)&ChunkLen)->bits.b0) 
3798:  MOVLW  04
379A:  MOVWF  x31
379C:  MOVLW  18
379E:  MOVWF  FE9
37A0:  MOVFF  431,FEA
37A4:  BTFSS  FEF.0
37A6:  BRA    37C0
....................         { 
....................             ((BYTE*)DataBuffer)[ChunkLen] = 0x00; 
37A8:  MOVLW  04
37AA:  MOVWF  x31
37AC:  MOVLW  1A
37AE:  ADDWF  x18,W
37B0:  MOVWF  FE9
37B2:  MOVF   x31,W
37B4:  ADDWFC x19,W
37B6:  MOVWF  FEA
37B8:  CLRF   FEF
....................             ChunkLen++; 
37BA:  INCF   x18,F
37BC:  BTFSC  FD8.2
37BE:  INCF   x19,F
....................         } 
....................  
....................         // Calculate the checksum over this chunk 
....................         DataPtr = DataBuffer; 
37C0:  MOVLW  04
37C2:  MOVWF  x2F
37C4:  MOVLW  1A
37C6:  MOVWF  x2E
....................         while(ChunkLen) 
37C8:  MOVF   x18,W
37CA:  IORWF  x19,W
37CC:  BZ    3804
....................         { 
....................             Checksum.Val += *DataPtr++; 
37CE:  MOVFF  42F,03
37D2:  MOVFF  42E,00
37D6:  MOVLW  02
37D8:  ADDWF  x2E,F
37DA:  BTFSC  FD8.0
37DC:  INCF   x2F,F
37DE:  MOVFF  00,FE9
37E2:  MOVFF  03,FEA
37E6:  MOVFF  FEC,03
37EA:  MOVF   FED,F
37EC:  MOVF   FEF,W
37EE:  ADDWF  x14,F
37F0:  MOVF   03,W
37F2:  ADDWFC x15,F
37F4:  MOVLW  00
37F6:  ADDWFC x16,F
37F8:  ADDWFC x17,F
....................             ChunkLen -= 2; 
37FA:  MOVLW  02
37FC:  SUBWF  x18,F
37FE:  MOVLW  00
3800:  SUBWFB x19,F
3802:  BRA    37C8
....................         } 
3804:  BRA    3750
....................     } 
....................  
....................     // Restore old read pointer location 
....................     WriteReg(ERDPTL, Start.v[0]); 
3806:  CLRF   x35
3808:  MOVFF  412,436
380C:  MOVLB  0
380E:  CALL   05A4
....................     WriteReg(ERDPTH, Start.v[1]); 
3812:  MOVLW  01
3814:  MOVLB  4
3816:  MOVWF  x35
3818:  MOVFF  413,436
381C:  MOVLB  0
381E:  CALL   05A4
....................  
....................     // Do an end-around carry (one's complement arrithmatic) 
....................     Checksum.Val = (DWORD)Checksum.w[0] + (DWORD)Checksum.w[1]; 
3822:  MOVLB  4
3824:  CLRF   x33
3826:  CLRF   x32
3828:  MOVFF  415,431
382C:  MOVFF  414,430
3830:  MOVFF  416,00
3834:  MOVFF  417,01
3838:  CLRF   02
383A:  CLRF   03
383C:  MOVF   x16,W
383E:  ADDWF  x14,W
3840:  MOVWF  x14
3842:  MOVF   x17,W
3844:  ADDWFC x15,W
3846:  MOVWF  x15
3848:  MOVF   02,W
384A:  ADDWFC x32,W
384C:  MOVWF  x16
384E:  MOVF   03,W
3850:  ADDWFC x33,W
3852:  MOVWF  x17
....................  
....................     // Do another end-around carry in case if the prior add 
....................     // caused a carry out 
....................     Checksum.w[0] += Checksum.w[1]; 
3854:  MOVF   x16,W
3856:  ADDWF  x14,F
3858:  MOVF   x17,W
385A:  ADDWFC x15,F
....................  
....................     // Return the resulting checksum 
....................     return ~Checksum.w[0]; 
385C:  MOVFF  415,03
3860:  COMF   03,F
3862:  MOVF   x14,W
3864:  XORLW  FF
3866:  MOVWF  01
3868:  MOVFF  03,02
386C:  MOVLB  0
386E:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           destAddr:   Destination address in the Ethernet memory to 
....................  *                              copy to.  If (PTR_BASE)-1 is specified, the  
....................  *                        current EWRPT value will be used instead. 
....................  *                  sourceAddr: Source address to read from.  If (PTR_BASE)-1 is 
....................  *                              specified, the current ERDPT value will be used 
....................  *                              instead. 
....................  *                  len:        Number of bytes to copy 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Bytes are asynchrnously transfered within the buffer.  Call 
....................  *                  MACIsMemCopyDone() to see when the transfer is complete. 
....................  * 
....................  * Note:            If a prior transfer is already in progress prior to 
....................  *                  calling this function, this function will block until it 
....................  *                  can start this transfer. 
....................  * 
....................  *                  If (PTR_BASE)-1 is used for the sourceAddr or destAddr 
....................  *                  parameters, then that pointer will get updated with the 
....................  *                  next address after the read or write. 
....................  *****************************************************************************/ 
.................... void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) 
*
0C70:  MOVLB  4
0C72:  BCF    x29.0
0C74:  BCF    x29.1
.................... { 
....................     WORD_VAL ReadSave, WriteSave; 
....................     BOOL UpdateWritePointer = FALSE; 
....................     BOOL UpdateReadPointer = FALSE; 
....................  
....................     if(destAddr == (PTR_BASE)-1) 
0C76:  INCFSZ x1F,W
0C78:  BRA    0C9E
0C7A:  INCFSZ x20,W
0C7C:  BRA    0C9E
....................     { 
....................         UpdateWritePointer = TRUE; 
0C7E:  BSF    x29.0
....................         destAddr = ReadETHReg(EWRPTL).Val; 
0C80:  MOVLW  02
0C82:  MOVWF  x30
0C84:  MOVLB  0
0C86:  RCALL  057A
0C88:  MOVLB  4
0C8A:  CLRF   x20
0C8C:  MOVFF  01,41F
....................         ((BYTE*)&destAddr)[1] = ReadETHReg(EWRPTH).Val; 
0C90:  MOVLW  03
0C92:  MOVWF  x30
0C94:  MOVLB  0
0C96:  RCALL  057A
0C98:  MOVFF  01,420
0C9C:  MOVLB  4
....................     } 
....................     if(sourceAddr == (PTR_BASE)-1) 
0C9E:  INCFSZ x21,W
0CA0:  BRA    0CC4
0CA2:  INCFSZ x22,W
0CA4:  BRA    0CC4
....................     { 
....................         UpdateReadPointer = TRUE; 
0CA6:  BSF    x29.1
....................         sourceAddr = ReadETHReg(ERDPTL).Val; 
0CA8:  CLRF   x30
0CAA:  MOVLB  0
0CAC:  RCALL  057A
0CAE:  MOVLB  4
0CB0:  CLRF   x22
0CB2:  MOVFF  01,421
....................         ((BYTE*)&sourceAddr)[1] = ReadETHReg(ERDPTH).Val; 
0CB6:  MOVLW  01
0CB8:  MOVWF  x30
0CBA:  MOVLB  0
0CBC:  RCALL  057A
0CBE:  MOVFF  01,422
0CC2:  MOVLB  4
....................     } 
....................  
....................     // Handle special conditions where len == 0 or len == 1 
....................     // The DMA module is not capable of handling those corner cases 
....................     if(len <= 1u) 
0CC4:  MOVF   x24,F
0CC6:  BTFSS  FD8.2
0CC8:  BRA    0DA8
0CCA:  MOVF   x23,W
0CCC:  SUBLW  01
0CCE:  BTFSS  FD8.0
0CD0:  BRA    0DA8
....................     { 
....................         if(!UpdateReadPointer) 
0CD2:  BTFSC  x29.1
0CD4:  BRA    0CF0
....................         { 
....................             ReadSave.v[0] = ReadETHReg(ERDPTL).Val; 
0CD6:  CLRF   x30
0CD8:  MOVLB  0
0CDA:  RCALL  057A
0CDC:  MOVFF  01,425
....................             ReadSave.v[1] = ReadETHReg(ERDPTH).Val; 
0CE0:  MOVLW  01
0CE2:  MOVLB  4
0CE4:  MOVWF  x30
0CE6:  MOVLB  0
0CE8:  RCALL  057A
0CEA:  MOVFF  01,426
0CEE:  MOVLB  4
....................         } 
....................         if(!UpdateWritePointer) 
0CF0:  BTFSC  x29.0
0CF2:  BRA    0D10
....................         { 
....................             WriteSave.v[0] = ReadETHReg(EWRPTL).Val; 
0CF4:  MOVLW  02
0CF6:  MOVWF  x30
0CF8:  MOVLB  0
0CFA:  RCALL  057A
0CFC:  MOVFF  01,427
....................             WriteSave.v[1] = ReadETHReg(EWRPTH).Val; 
0D00:  MOVLW  03
0D02:  MOVLB  4
0D04:  MOVWF  x30
0D06:  MOVLB  0
0D08:  RCALL  057A
0D0A:  MOVFF  01,428
0D0E:  MOVLB  4
....................         } 
....................         WriteReg(ERDPTL, ((BYTE*)&sourceAddr)[0]); 
0D10:  CLRF   x35
0D12:  MOVFF  421,436
0D16:  MOVLB  0
0D18:  RCALL  05A4
....................         WriteReg(ERDPTH, ((BYTE*)&sourceAddr)[1]); 
0D1A:  MOVLW  01
0D1C:  MOVLB  4
0D1E:  MOVWF  x35
0D20:  MOVFF  422,436
0D24:  MOVLB  0
0D26:  RCALL  05A4
....................         WriteReg(EWRPTL, ((BYTE*)&destAddr)[0]); 
0D28:  MOVLW  02
0D2A:  MOVLB  4
0D2C:  MOVWF  x35
0D2E:  MOVFF  41F,436
0D32:  MOVLB  0
0D34:  RCALL  05A4
....................         WriteReg(EWRPTH, ((BYTE*)&destAddr)[1]); 
0D36:  MOVLW  03
0D38:  MOVLB  4
0D3A:  MOVWF  x35
0D3C:  MOVFF  420,436
0D40:  MOVLB  0
0D42:  RCALL  05A4
....................         while(len--) 
0D44:  MOVLB  4
0D46:  MOVFF  424,03
0D4A:  MOVF   x23,W
0D4C:  BTFSC  FD8.2
0D4E:  DECF   x24,F
0D50:  DECF   x23,F
0D52:  IORWF  03,W
0D54:  BZ    0D68
....................             MACPut(MACGet()); 
0D56:  MOVLB  0
0D58:  RCALL  0C46
0D5A:  MOVFF  01,42A
0D5E:  MOVFF  01,433
0D62:  RCALL  05CE
0D64:  BRA    0D44
0D66:  MOVLB  4
....................         if(!UpdateReadPointer) 
0D68:  BTFSC  x29.1
0D6A:  BRA    0D86
....................         { 
....................             WriteReg(ERDPTL, ReadSave.v[0]); 
0D6C:  CLRF   x35
0D6E:  MOVFF  425,436
0D72:  MOVLB  0
0D74:  RCALL  05A4
....................             WriteReg(ERDPTH, ReadSave.v[1]); 
0D76:  MOVLW  01
0D78:  MOVLB  4
0D7A:  MOVWF  x35
0D7C:  MOVFF  426,436
0D80:  MOVLB  0
0D82:  RCALL  05A4
0D84:  MOVLB  4
....................         } 
....................         if(!UpdateWritePointer) 
0D86:  BTFSC  x29.0
0D88:  BRA    0DA6
....................         { 
....................             WriteReg(EWRPTL, WriteSave.v[0]); 
0D8A:  MOVLW  02
0D8C:  MOVWF  x35
0D8E:  MOVFF  427,436
0D92:  MOVLB  0
0D94:  RCALL  05A4
....................             WriteReg(EWRPTH, WriteSave.v[1]); 
0D96:  MOVLW  03
0D98:  MOVLB  4
0D9A:  MOVWF  x35
0D9C:  MOVFF  428,436
0DA0:  MOVLB  0
0DA2:  RCALL  05A4
0DA4:  MOVLB  4
....................         } 
....................     } 
0DA6:  BRA    0EFA
....................     else 
....................     { 
....................         if(UpdateWritePointer) 
0DA8:  BTFSS  x29.0
0DAA:  BRA    0DD8
....................         { 
....................             WriteSave.Val = destAddr + len; 
0DAC:  MOVF   x23,W
0DAE:  ADDWF  x1F,W
0DB0:  MOVWF  x27
0DB2:  MOVF   x24,W
0DB4:  ADDWFC x20,W
0DB6:  MOVWF  x28
....................             WriteReg(EWRPTL, WriteSave.v[0]); 
0DB8:  MOVLW  02
0DBA:  MOVWF  x35
0DBC:  MOVFF  427,436
0DC0:  MOVLB  0
0DC2:  CALL   05A4
....................             WriteReg(EWRPTH, WriteSave.v[1]); 
0DC6:  MOVLW  03
0DC8:  MOVLB  4
0DCA:  MOVWF  x35
0DCC:  MOVFF  428,436
0DD0:  MOVLB  0
0DD2:  CALL   05A4
0DD6:  MOVLB  4
....................         } 
....................         len += sourceAddr - 1; 
0DD8:  MOVLW  01
0DDA:  SUBWF  x21,W
0DDC:  MOVWF  00
0DDE:  MOVLW  00
0DE0:  SUBWFB x22,W
0DE2:  MOVWF  03
0DE4:  MOVF   00,W
0DE6:  ADDWF  x23,F
0DE8:  MOVF   03,W
0DEA:  ADDWFC x24,F
....................         while(ReadETHReg(ECON1).ECON1bits.DMAST); 
0DEC:  MOVLW  1F
0DEE:  MOVWF  x30
0DF0:  MOVLB  0
0DF2:  CALL   057A
0DF6:  MOVFF  01,42A
0DFA:  MOVLW  00
0DFC:  MOVLB  4
0DFE:  BTFSC  01.5
0E00:  MOVLW  01
0E02:  XORLW  00
0E04:  BNZ   0DEC
....................         WriteReg(EDMASTL, ((BYTE*)&sourceAddr)[0]); 
0E06:  MOVLW  10
0E08:  MOVWF  x35
0E0A:  MOVFF  421,436
0E0E:  MOVLB  0
0E10:  CALL   05A4
....................         WriteReg(EDMASTH, ((BYTE*)&sourceAddr)[1]); 
0E14:  MOVLW  11
0E16:  MOVLB  4
0E18:  MOVWF  x35
0E1A:  MOVFF  422,436
0E1E:  MOVLB  0
0E20:  CALL   05A4
....................         WriteReg(EDMADSTL, ((BYTE*)&destAddr)[0]); 
0E24:  MOVLW  14
0E26:  MOVLB  4
0E28:  MOVWF  x35
0E2A:  MOVFF  41F,436
0E2E:  MOVLB  0
0E30:  CALL   05A4
....................         WriteReg(EDMADSTH, ((BYTE*)&destAddr)[1]); 
0E34:  MOVLW  15
0E36:  MOVLB  4
0E38:  MOVWF  x35
0E3A:  MOVFF  420,436
0E3E:  MOVLB  0
0E40:  CALL   05A4
....................         if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
0E44:  MOVLB  4
0E46:  MOVF   x22,W
0E48:  SUBLW  11
0E4A:  BNC   0E6C
0E4C:  BNZ   0E54
0E4E:  MOVF   x21,W
0E50:  SUBLW  D5
0E52:  BNC   0E6C
0E54:  MOVF   x24,W
0E56:  SUBLW  10
0E58:  BC    0E6C
0E5A:  XORLW  FF
0E5C:  BNZ   0E64
0E5E:  MOVF   x23,W
0E60:  SUBLW  D5
0E62:  BC    0E6C
....................             len -= RXSIZE; 
0E64:  MOVLW  D6
0E66:  SUBWF  x23,F
0E68:  MOVLW  11
0E6A:  SUBWFB x24,F
....................         WriteReg(EDMANDL, ((BYTE*)&len)[0]); 
0E6C:  MOVLW  12
0E6E:  MOVWF  x35
0E70:  MOVFF  423,436
0E74:  MOVLB  0
0E76:  CALL   05A4
....................         WriteReg(EDMANDH, ((BYTE*)&len)[1]); 
0E7A:  MOVLW  13
0E7C:  MOVLB  4
0E7E:  MOVWF  x35
0E80:  MOVFF  424,436
0E84:  MOVLB  0
0E86:  CALL   05A4
....................         BFCReg(ECON1, ECON1_CSUMEN); 
0E8A:  MOVLW  1F
0E8C:  MOVLB  4
0E8E:  MOVWF  x2A
0E90:  MOVLW  10
0E92:  MOVWF  x2B
0E94:  MOVLB  0
0E96:  CALL   04F0
....................         BFSReg(ECON1, ECON1_DMAST); 
0E9A:  MOVLW  1F
0E9C:  MOVLB  4
0E9E:  MOVWF  x2A
0EA0:  MOVLW  20
0EA2:  MOVWF  x2B
0EA4:  MOVLB  0
0EA6:  CALL   05F2
....................         if(UpdateReadPointer) 
0EAA:  MOVLB  4
0EAC:  BTFSS  x29.1
0EAE:  BRA    0EFA
....................         { 
....................             len++; 
0EB0:  INCF   x23,F
0EB2:  BTFSC  FD8.2
0EB4:  INCF   x24,F
....................             if((sourceAddr <= RXSTOP) && (len > RXSTOP)) //&& (sourceAddr >= RXSTART)) 
0EB6:  MOVF   x22,W
0EB8:  SUBLW  11
0EBA:  BNC   0EDC
0EBC:  BNZ   0EC4
0EBE:  MOVF   x21,W
0EC0:  SUBLW  D5
0EC2:  BNC   0EDC
0EC4:  MOVF   x24,W
0EC6:  SUBLW  10
0EC8:  BC    0EDC
0ECA:  XORLW  FF
0ECC:  BNZ   0ED4
0ECE:  MOVF   x23,W
0ED0:  SUBLW  D5
0ED2:  BC    0EDC
....................                 len -= RXSIZE; 
0ED4:  MOVLW  D6
0ED6:  SUBWF  x23,F
0ED8:  MOVLW  11
0EDA:  SUBWFB x24,F
....................             WriteReg(ERDPTL, ((BYTE*)&len)[0]); 
0EDC:  CLRF   x35
0EDE:  MOVFF  423,436
0EE2:  MOVLB  0
0EE4:  CALL   05A4
....................             WriteReg(ERDPTH, ((BYTE*)&len)[1]); 
0EE8:  MOVLW  01
0EEA:  MOVLB  4
0EEC:  MOVWF  x35
0EEE:  MOVFF  424,436
0EF2:  MOVLB  0
0EF4:  CALL   05A4
0EF8:  MOVLB  4
....................         } 
....................     } 
0EFA:  MOVLB  0
0EFC:  RETURN 0
.................... } 
....................  
.................... BOOL MACIsMemCopyDone(void) 
.................... { 
....................     return !ReadETHReg(ECON1).ECON1bits.DMAST; 
0EFE:  MOVLW  1F
0F00:  MOVLB  4
0F02:  MOVWF  x30
0F04:  MOVLB  0
0F06:  CALL   057A
0F0A:  MOVFF  01,41F
0F0E:  MOVLW  00
0F10:  MOVLB  4
0F12:  BTFSC  01.5
0F14:  MOVLW  01
0F16:  XORLW  00
0F18:  BZ    0F1E
0F1A:  MOVLW  00
0F1C:  BRA    0F20
0F1E:  MOVLW  01
0F20:  MOVWF  01
0F22:  MOVLB  0
0F24:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *                  increments ERDPT so MACGet() can be called again.  The 
....................  *                  increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
....................     BYTE Result; 
....................  
....................     ENC_CS_IO = 0; 
*
0C46:  BCF    F8B.1
....................    ClearSPIDoneFlag(); 
0C48:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the opcode and read a byte in one 16-bit operation 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = RBM<<8 | 0x00; // Send Read Buffer Memory command plus 8 dummy bits to generate clocks for the return result 
....................         WaitForDataByte();          // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         // Send the opcode and read a byte in one 16-bit operation 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................         ENC_SSPBUF = RBM<<8 | 0x00; // Send Read Buffer Memory command plus 8 dummy bits to generate clocks for the return result 
....................         WaitForDataByte();          // Wait until WORD is transmitted 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................     } 
....................     #else 
....................     { 
....................         // Send the opcode and read a byte in two 8-bit operations 
....................         ENC_SSPBUF = RBM; 
0C4A:  MOVLW  3A
0C4C:  MOVWF  FC9
....................         WaitForDataByte();      // Wait until opcode/address is transmitted. 
0C4E:  BTFSS  F9E.3
0C50:  BRA    0C4E
0C52:  BCF    F9E.3
....................         Result = ENC_SSPBUF; 
0C54:  MOVFF  FC9,42A
....................  
....................         ENC_SSPBUF = 0;         // Send a dummy byte to receive the register 
0C58:  CLRF   FC9
....................                                 //   contents. 
....................         WaitForDataByte();      // Wait until register is received. 
0C5A:  BTFSS  F9E.3
0C5C:  BRA    0C5A
0C5E:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Result = ENC_SSPBUF; 
0C60:  MOVFF  FC9,42A
....................     ENC_CS_IO = 1; 
0C64:  BSF    F8B.1
....................  
....................     return Result; 
0C66:  MOVLB  4
0C68:  MOVFF  42A,01
0C6C:  MOVLB  0
0C6E:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *                  len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *                  and places them into local memory.  With SPI burst support, 
....................  *                  it performs much faster than multiple MACGet() calls. 
....................  *                  ERDPT is incremented after each byte, following the same 
....................  *                  rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = RBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = 0;     // Send a dummy byte to receive a byte 
....................         if(val) 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
....................             *val++ = ENC_SSPBUF; 
....................         } 
....................         else 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
....................         } 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return len; 
.................... #else 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     // Start the burst operation 
....................     ENC_CS_IO = 0; 
*
0BD0:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
0BD2:  BCF    F9E.3
....................     ENC_SSPBUF = RBM;       // Send the Read Buffer Memory opcode. 
0BD4:  MOVLW  3A
0BD6:  MOVWF  FC9
....................     i = 0; 
0BD8:  MOVLB  4
0BDA:  CLRF   x37
0BDC:  CLRF   x36
....................     if(val) 
0BDE:  MOVF   x32,W
0BE0:  IORWF  x33,W
0BE2:  BZ    0BEC
....................         val--; 
0BE4:  MOVF   x32,W
0BE6:  BTFSC  FD8.2
0BE8:  DECF   x33,F
0BEA:  DECF   x32,F
....................     WaitForDataByte();      // Wait until opcode/address is transmitted. 
0BEC:  BTFSS  F9E.3
0BEE:  BRA    0BEC
0BF0:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
0BF2:  MOVFF  FC9,438
....................  
....................     #if defined(__C32__) 
....................     { 
....................         DWORD_VAL dwv; 
....................  
....................         // Read the data, 4 bytes at a time, for as long as possible 
....................         if(len >= 4) 
....................         { 
....................             ENC_SPICON1bits.MODE32 = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = 0x00000000;    // Send a dummy DWORD to generate 32 clocks 
....................                 i += 4; 
....................                 WaitForDataByte();         // Wait until DWORD is transmitted 
....................                 dwv.Val = ENC_SSPBUF; 
....................                 if(val) 
....................                 { 
....................                     *(++val) = dwv.v[3]; 
....................                     *(++val) = dwv.v[2]; 
....................                     *(++val) = dwv.v[1]; 
....................                     *(++val) = dwv.v[0]; 
....................                 } 
....................                 if(len - i < 4) 
....................                     break; 
....................             }; 
....................             ENC_SPICON1bits.MODE32 = 0; 
....................         } 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         WORD_VAL wv; 
....................  
....................         // Read the data, 2 bytes at a time, for as long as possible 
....................         if(len >= 2) 
....................         { 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 1; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = 0x0000;    // Send a dummy WORD to generate 32 clocks 
....................                 i += 2; 
....................                 WaitForDataByte();      // Wait until WORD is transmitted 
....................                 wv.Val = ENC_SSPBUF; 
....................                 if(val) 
....................                 { 
....................                     *(++val) = wv.v[1]; 
....................                     *(++val) = wv.v[0]; 
....................                 } 
....................                 if(len - i < 2) 
....................                     break; 
....................             }; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 0; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................         } 
....................     } 
....................     #endif 
....................  
....................     // Read the data 
....................     while(i<len) 
0BF6:  MOVF   x37,W
0BF8:  SUBWF  x35,W
0BFA:  BNC   0C38
0BFC:  BNZ   0C04
0BFE:  MOVF   x34,W
0C00:  SUBWF  x36,W
0C02:  BC    0C38
....................     { 
....................         ENC_SSPBUF = 0;     // Send a dummy byte to receive a byte 
0C04:  CLRF   FC9
....................         i++; 
0C06:  INCF   x36,F
0C08:  BTFSC  FD8.2
0C0A:  INCF   x37,F
....................         if(val) 
0C0C:  MOVF   x32,W
0C0E:  IORWF  x33,W
0C10:  BZ    0C2C
....................         { 
....................             val++; 
0C12:  INCF   x32,F
0C14:  BTFSC  FD8.2
0C16:  INCF   x33,F
....................             WaitForDataByte();  // Wait until byte is received. 
0C18:  BTFSS  F9E.3
0C1A:  BRA    0C18
0C1C:  BCF    F9E.3
....................             *val = ENC_SSPBUF; 
0C1E:  MOVFF  432,FE9
0C22:  MOVFF  433,FEA
0C26:  MOVFF  FC9,FEF
....................         } 
0C2A:  BRA    0C36
....................         else 
....................         { 
....................             WaitForDataByte();  // Wait until byte is received. 
0C2C:  BTFSS  F9E.3
0C2E:  BRA    0C2C
0C30:  BCF    F9E.3
....................             Dummy = ENC_SSPBUF; 
0C32:  MOVFF  FC9,438
....................         } 
0C36:  BRA    0BF6
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
0C38:  BSF    F8B.1
....................  
....................     return i; 
0C3A:  MOVFF  436,01
0C3E:  MOVFF  437,02
.................... #endif 
0C42:  MOVLB  0
0C44:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *                  (8 bits) and data to write (8 bits) over the SPI. 
....................  *                  EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
05CE:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
05D0:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = (WBM<<8) | (WORD)val;  // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................         ENC_SSPBUF = (WBM<<8) | (WORD)val;  // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPISTATbits.SPIEN = 0; 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................         ENC_SPISTATbits.SPIEN = 1; 
....................     } 
....................     #else 
....................     { 
....................         ENC_SSPBUF = WBM;       // Send the opcode and constant. 
05D2:  MOVLW  7A
05D4:  MOVWF  FC9
....................         WaitForDataByte();      // Wait until opcode/constant is transmitted. 
05D6:  BTFSS  F9E.3
05D8:  BRA    05D6
05DA:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
05DC:  MOVFF  FC9,434
....................         ENC_SSPBUF = val;       // Send the byte to be writen. 
05E0:  MOVFF  433,FC9
....................         WaitForDataByte();      // Wait until finished transmitting 
05E4:  BTFSS  F9E.3
05E6:  BRA    05E4
05E8:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Dummy = ENC_SSPBUF; 
05EA:  MOVFF  FC9,434
....................     ENC_CS_IO = 1; 
05EE:  BSF    F8B.1
05F0:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *                  len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *                  ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *                  calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = WBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = *val++;    // Send byte 
....................         WaitForDataByte();      // Wait until byte is sent 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return; 
.................... #else 
....................     volatile BYTE Dummy; 
....................  
....................     // Select the chip and send the proper opcode 
....................     ENC_CS_IO = 0; 
*
0B1E:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
0B20:  BCF    F9E.3
....................     ENC_SSPBUF = WBM;       // Send the Write Buffer Memory opcode 
0B22:  MOVLW  7A
0B24:  MOVWF  FC9
....................     WaitForDataByte();      // Wait until opcode/constant is transmitted. 
0B26:  BTFSS  F9E.3
0B28:  BRA    0B26
0B2A:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
0B2C:  MOVFF  FC9,438
....................  
....................     #if defined(__C32__) 
....................     { 
....................         DWORD_VAL dwv; 
....................  
....................         // Send the data, 4 bytes at a time, for as long as possible 
....................         if(len >= 4) 
....................         { 
....................             dwv.v[3] = *val++; 
....................             dwv.v[2] = *val++; 
....................             dwv.v[1] = *val++; 
....................             dwv.v[0] = *val++; 
....................             ENC_SPICON1bits.MODE32 = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = dwv.Val;       // Start sending the DWORD 
....................                 len -= 4; 
....................                 if(len < 4) 
....................                     break; 
....................                 dwv.v[3] = *val++; 
....................                 dwv.v[2] = *val++; 
....................                 dwv.v[1] = *val++; 
....................                 dwv.v[0] = *val++; 
....................                 WaitForDataByte();          // Wait until DWORD is transmitted 
....................                 Dummy = ENC_SSPBUF; 
....................             }; 
....................             WaitForDataByte();              // Wait until DWORD is transmitted 
....................             Dummy = ENC_SSPBUF; 
....................             ENC_SPICON1bits.MODE32 = 0; 
....................         } 
....................     } 
....................     #elif defined(__C30__) 
....................     { 
....................         WORD_VAL wv; 
....................  
....................         // Send the data, 2 bytes at a time, for as long as possible 
....................         if(len >= 2) 
....................         { 
....................             wv.v[1] = *val++; 
....................             wv.v[0] = *val++; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 1; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................             while(1) 
....................             { 
....................                 ENC_SSPBUF = wv.Val;        // Start sending the WORD 
....................                 len -= 2; 
....................                 if(len < 2) 
....................                     break; 
....................                 wv.v[1] = *val++; 
....................                 wv.v[0] = *val++; 
....................                 WaitForDataByte();          // Wait until WORD is transmitted 
....................                 Dummy = ENC_SSPBUF; 
....................             }; 
....................             WaitForDataByte();              // Wait until WORD is transmitted 
....................             Dummy = ENC_SSPBUF; 
....................             ENC_SPISTATbits.SPIEN = 0; 
....................             ENC_SPICON1bits.MODE16 = 0; 
....................             ENC_SPISTATbits.SPIEN = 1; 
....................         } 
....................     } 
....................     #endif 
....................  
....................     // Send the data, one byte at a time 
....................     while(len) 
0B30:  MOVLB  4
0B32:  MOVF   x36,W
0B34:  IORWF  x37,W
0B36:  BZ    0B5E
....................     { 
....................         ENC_SSPBUF = *val;  // Start sending the byte 
0B38:  MOVFF  434,FE9
0B3C:  MOVFF  435,FEA
0B40:  MOVFF  FEF,FC9
....................         val++;              // Increment after writing to ENC_SSPBUF to increase speed 
0B44:  INCF   x34,F
0B46:  BTFSC  FD8.2
0B48:  INCF   x35,F
....................         len--;              // Decrement after writing to ENC_SSPBUF to increase speed 
0B4A:  MOVF   x36,W
0B4C:  BTFSC  FD8.2
0B4E:  DECF   x37,F
0B50:  DECF   x36,F
....................         WaitForDataByte();  // Wait until byte is transmitted 
0B52:  BTFSS  F9E.3
0B54:  BRA    0B52
0B56:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
0B58:  MOVFF  FC9,438
0B5C:  BRA    0B32
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
0B5E:  BSF    F8B.1
.................... #endif 
0B60:  MOVLB  0
0B62:  RETURN 0
.................... }//end MACPutArray 
....................  
....................  
.................... #if defined(__18CXX) 
.................... /****************************************************************************** 
....................  * Function:        void MACPutROMArray(ROM BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *                  len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *                  ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *                  calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutROMArray(ROM BYTE *val, WORD len) 
.................... { 
.................... // Workaround needed on HPC Explorer (classic) board to prevent interference 
.................... // with I2C temperature sensor on the same SPI wires 
.................... #if defined(__18F8722) || defined(_18F8722) ||  defined(__18F8723) || defined(_18F8723) 
....................     WORD i; 
....................     volatile BYTE Dummy; 
....................  
....................     i = len; 
....................     Dummy = 0xFF; 
....................     ClearSPIDoneFlag(); 
....................     while(i--) 
....................     { 
....................         if(((BYTE_VAL*)&Dummy)->bits.b0) 
....................         { 
....................             // End bust operation 
....................             ENC_CS_IO = 1; 
....................             ((BYTE_VAL*)&Dummy)->bits.b0 = 0; 
....................  
....................             // Start the burst operation 
....................             ENC_CS_IO = 0; 
....................             ENC_SSPBUF = WBM;       // Send the Read Buffer Memory opcode. 
....................             WaitForDataByte();      // Wait until opcode/address is transmitted. 
....................         } 
....................         else 
....................             Dummy = 0xFF; 
....................  
....................         ENC_SSPBUF = *val++;    // Send byte 
....................         WaitForDataByte();      // Wait until byte is sent 
....................     } 
....................  
....................     ENC_CS_IO = 1; 
....................  
....................     return; 
.................... #else 
....................     volatile BYTE Dummy; 
....................  
....................     // Select the chip and send the proper opcode 
....................     ENC_CS_IO = 0; 
....................     ClearSPIDoneFlag(); 
....................     ENC_SSPBUF = WBM;       // Send the Write Buffer Memory opcode 
....................     WaitForDataByte();      // Wait until opcode/constant is transmitted. 
....................     Dummy = ENC_SSPBUF; 
....................  
....................     // Send the data 
....................     while(len) 
....................     { 
....................         ENC_SSPBUF = *val;  // Start sending the byte 
....................         val++;              // Increment after writing to ENC_SSPBUF to increase speed 
....................         len--;              // Decrement after writing to ENC_SSPBUF to increase speed 
....................         WaitForDataByte();  // Wait until byte is transmitted 
....................         Dummy = ENC_SSPBUF; 
....................     }; 
....................  
....................     // Terminate the burst operation 
....................     ENC_CS_IO = 1; 
.................... #endif 
.................... }//end MACPutROMArray 
.................... #endif 
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *                  the Ethernet controller.  It resets all register contents 
....................  *                  (except for ECOCON) and returns the device to the power 
....................  *                  on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     // Note: The power save feature may prevent the reset from executing, so 
....................     // we must make sure that the device is not in power save before issuing 
....................     // a reset. 
....................     BFCReg(ECON2, ECON2_PWRSV); 
*
0542:  MOVLW  1E
0544:  MOVLB  4
0546:  MOVWF  x2A
0548:  MOVLW  20
054A:  MOVWF  x2B
054C:  MOVLB  0
054E:  RCALL  04F0
....................  
....................     // Give some opportunity for the regulator to reach normal regulation and 
....................     // have all clocks running 
....................     DelayMs(1); 
0550:  MOVLW  01
0552:  MOVLB  3
0554:  MOVWF  x94
0556:  MOVLB  0
0558:  RCALL  051A
....................  
....................     // Execute the System Reset command 
....................     ENC_CS_IO = 0; 
055A:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
055C:  BCF    F9E.3
....................     ENC_SSPBUF = SR; 
055E:  SETF   FC9
....................     WaitForDataByte();      // Wait until the command is transmitted. 
0560:  BTFSS  F9E.3
0562:  BRA    0560
0564:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
0566:  MOVFF  FC9,37C
....................     ENC_CS_IO = 1; 
056A:  BSF    F8B.1
....................  
....................     // Wait for the oscillator start up timer and PHY to become ready 
....................     DelayMs(1); 
056C:  MOVLW  01
056E:  MOVLB  3
0570:  MOVWF  x94
0572:  MOVLB  0
0574:  RCALL  051A
0576:  GOTO   0742 (RETURN)
.................... }//end SendSystemReset 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                    The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *                  the SPI and then retrives the register contents in the 
....................  *                  next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *                  registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *                  purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................     REG r; 
....................  
....................     // Select the chip and send the Read Control Register opcode/address 
....................     ENC_CS_IO = 0; 
057A:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
057C:  BCF    F9E.3
....................     ENC_SSPBUF = RCR | Address; 
057E:  MOVLB  4
0580:  MOVFF  430,FC9
....................  
....................     WaitForDataByte();      // Wait until the opcode/address is transmitted 
0584:  BTFSS  F9E.3
0586:  BRA    0584
0588:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
058A:  MOVFF  FC9,431
....................     ENC_SSPBUF = 0;         // Send a dummy byte to receive the register 
058E:  CLRF   FC9
....................                             //   contents 
....................     WaitForDataByte();      // Wait until the register is received 
0590:  BTFSS  F9E.3
0592:  BRA    0590
0594:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
0596:  MOVFF  FC9,431
....................     ENC_CS_IO = 1; 
059A:  BSF    F8B.1
....................  
....................     return r; 
059C:  MOVFF  431,01
05A0:  MOVLB  0
05A2:  RETURN 0
.................... }//end ReadETHReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                    The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *                  as a dummy byte over the SPI and then retrives the 
....................  *                  register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *                  registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *                  purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................     REG r; 
....................  
....................     ENC_CS_IO = 0; 
*
0652:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
0654:  BCF    F9E.3
....................     ENC_SSPBUF = RCR | Address; // Send the Read Control Register opcode and 
0656:  MOVLB  3
0658:  MOVFF  39F,FC9
....................                                 //   address. 
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
065C:  BTFSS  F9E.3
065E:  BRA    065C
0660:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
0662:  MOVFF  FC9,3A0
....................     ENC_SSPBUF = 0;             // Send a dummy byte 
0666:  CLRF   FC9
....................     WaitForDataByte();          // Wait for the dummy byte to be transmitted 
0668:  BTFSS  F9E.3
066A:  BRA    0668
066C:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
066E:  MOVFF  FC9,3A0
....................     ENC_SSPBUF = 0;             // Send another dummy byte to receive the register 
0672:  CLRF   FC9
....................                                 //   contents. 
....................     WaitForDataByte();          // Wait until register is received. 
0674:  BTFSS  F9E.3
0676:  BRA    0674
0678:  BCF    F9E.3
....................     r.Val = ENC_SSPBUF; 
067A:  MOVFF  FC9,3A0
....................     ENC_CS_IO = 1; 
067E:  BSF    F8B.1
....................  
....................     return r; 
0680:  MOVFF  3A0,01
0684:  MOVLB  0
0686:  RETURN 0
.................... }//end ReadMACReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *                  progress, it simply polls the MII BUSY bit wasting time 
....................  *                  (10.24us). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................     PHYREG Result; 
....................  
....................     // Set the right address and start the register read operation 
....................     BankSel(MIREGADR); 
*
17BE:  MOVLW  02
17C0:  MOVLB  4
17C2:  MOVWF  x15
17C4:  MOVLW  14
17C6:  MOVWF  x14
17C8:  MOVLB  0
17CA:  CALL   061C
....................     WriteReg((BYTE)MIREGADR, Register); 
17CE:  MOVLW  14
17D0:  MOVLB  4
17D2:  MOVWF  x35
17D4:  MOVFF  39C,436
17D8:  MOVLB  0
17DA:  CALL   05A4
....................     WriteReg((BYTE)MICMD, MICMD_MIIRD); 
17DE:  MOVLW  12
17E0:  MOVLB  4
17E2:  MOVWF  x35
17E4:  MOVLW  01
17E6:  MOVWF  x36
17E8:  MOVLB  0
17EA:  CALL   05A4
....................  
....................     // Loop to wait until the PHY register has been read through the MII 
....................     // This requires 10.24us 
....................     BankSel(MISTAT); 
17EE:  MOVLW  03
17F0:  MOVLB  4
17F2:  MOVWF  x15
17F4:  MOVLW  0A
17F6:  MOVWF  x14
17F8:  MOVLB  0
17FA:  CALL   061C
....................     while(ReadMACReg((BYTE)MISTAT).MISTATbits.BUSY); 
17FE:  MOVLW  0A
1800:  MOVLB  3
1802:  MOVWF  x9F
1804:  MOVLB  0
1806:  CALL   0652
180A:  MOVFF  01,39F
180E:  MOVLW  00
1810:  MOVLB  3
1812:  BTFSC  01.0
1814:  MOVLW  01
1816:  XORLW  00
1818:  BTFSC  FD8.2
181A:  BRA    1820
181C:  MOVLB  0
181E:  BRA    17FE
....................  
....................     // Stop reading 
....................     BankSel(MIREGADR); 
1820:  MOVLW  02
1822:  MOVLB  4
1824:  MOVWF  x15
1826:  MOVLW  14
1828:  MOVWF  x14
182A:  MOVLB  0
182C:  CALL   061C
....................     WriteReg((BYTE)MICMD, 0x00); 
1830:  MOVLW  12
1832:  MOVLB  4
1834:  MOVWF  x35
1836:  CLRF   x36
1838:  MOVLB  0
183A:  CALL   05A4
....................  
....................     // Obtain results and return 
....................     Result.VAL.v[0] = ReadMACReg((BYTE)MIRDL).Val; 
183E:  MOVLW  18
1840:  MOVLB  3
1842:  MOVWF  x9F
1844:  MOVLB  0
1846:  CALL   0652
184A:  MOVFF  01,39D
....................     Result.VAL.v[1] = ReadMACReg((BYTE)MIRDH).Val; 
184E:  MOVLW  19
1850:  MOVLB  3
1852:  MOVWF  x9F
1854:  MOVLB  0
1856:  CALL   0652
185A:  MOVFF  01,39E
....................  
....................     BankSel(ERDPTL);    // Return to Bank 0 
185E:  MOVLB  4
1860:  CLRF   x15
1862:  CLRF   x14
1864:  MOVLB  0
1866:  CALL   061C
....................     return Result; 
186A:  MOVLB  3
186C:  MOVFF  39D,01
1870:  MOVFF  39E,02
1874:  MOVLB  0
1876:  GOTO   1884 (RETURN)
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                    The top 3 bits must be 0. 
....................  *                  Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *                  SPI and then sends the data to write in the next 8 SPI 
....................  *                  clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *                  BFSReg() functions.  It is seperate to maximize speed. 
....................  *                  Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *                  can write to any ETH or MAC register.  Writing to PHY 
....................  *                  registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
05A4:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
05A6:  BCF    F9E.3
....................  
....................     #if defined(__C32__) 
....................     { 
....................         // Send the Write Buffer Memory and data, in on 16-bit write 
....................         ENC_SPICON1bits.MODE16 = 1; 
....................         ENC_SSPBUF = ((WCR | Address)<<8) | (WORD)Data; // Start sending the WORD 
....................         WaitForDataByte();                  // Wait until WORD is transmitted 
....................         ENC_SPICON1bits.MODE16 = 0; 
....................     } 
....................     #else 
....................     { 
....................         ENC_SSPBUF = WCR | Address; // Send the opcode and address. 
05A8:  MOVLB  4
05AA:  MOVF   x35,W
05AC:  IORLW  40
05AE:  MOVWF  FC9
....................         WaitForDataByte();          // Wait until opcode/constant is transmitted. 
05B0:  BTFSS  F9E.3
05B2:  BRA    05B0
05B4:  BCF    F9E.3
....................         Dummy = ENC_SSPBUF; 
05B6:  MOVFF  FC9,437
....................         ENC_SSPBUF = Data;          // Send the byte to be writen. 
05BA:  MOVFF  436,FC9
....................         WaitForDataByte();          // Wait until finished transmitting 
05BE:  BTFSS  F9E.3
05C0:  BRA    05BE
05C2:  BCF    F9E.3
....................     } 
....................     #endif 
....................  
....................     Dummy = ENC_SSPBUF; 
05C4:  MOVFF  FC9,437
....................  
....................  
....................    // For faster processors (dsPIC), delay for a few clock cycles to ensure  
....................    // the MAC/MII register write Chip Select hold time minimum of 210ns is met. 
....................    #if (GetInstructionClock() > 30000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................    #if (GetInstructionClock() > 40000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................    #if (GetInstructionClock() > 50000000) 
....................       Nop(); 
....................       Nop(); 
....................    #endif 
....................  
....................    ENC_CS_IO = 1; 
05C8:  BSF    F8B.1
05CA:  MOVLB  0
05CC:  RETURN 0
.................... }//end WriteReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                    to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                    must be 0. 
....................  *                  Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *                  SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *                  BFSReg() functions.  It is separate to maximize speed. 
....................  *                  BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
04F0:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
04F2:  BCF    F9E.3
....................     ENC_SSPBUF = BFC | Address; // Send the opcode and address. 
04F4:  MOVLB  4
04F6:  MOVF   x2A,W
04F8:  IORLW  A0
04FA:  MOVWF  FC9
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
04FC:  BTFSS  F9E.3
04FE:  BRA    04FC
0500:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
0502:  MOVFF  FC9,42C
....................     ENC_SSPBUF = Data;          // Send the byte to be writen. 
0506:  MOVFF  42B,FC9
....................     WaitForDataByte();          // Wait until register is written. 
050A:  BTFSS  F9E.3
050C:  BRA    050A
050E:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
0510:  MOVFF  FC9,42C
....................     ENC_CS_IO = 1; 
0514:  BSF    F8B.1
0516:  MOVLB  0
0518:  RETURN 0
.................... }//end BFCReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                  Bank select bits must be set corresponding to the register 
....................  *                  to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                    must be 0. 
....................  *                  Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *                  SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *                  BFCReg() functions.  It is separate to maximize speed. 
....................  *                  BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
....................     volatile BYTE Dummy; 
....................  
....................     ENC_CS_IO = 0; 
*
05F2:  BCF    F8B.1
....................     ClearSPIDoneFlag(); 
05F4:  BCF    F9E.3
....................     ENC_SSPBUF = BFS | Address; // Send the opcode and address. 
05F6:  MOVLB  4
05F8:  MOVF   x2A,W
05FA:  IORLW  80
05FC:  MOVWF  FC9
....................     WaitForDataByte();          // Wait until opcode/address is transmitted. 
05FE:  BTFSS  F9E.3
0600:  BRA    05FE
0602:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
0604:  MOVFF  FC9,42C
....................     ENC_SSPBUF = Data;          // Send the byte to be writen. 
0608:  MOVFF  42B,FC9
....................     WaitForDataByte();          // Wait until register is written. 
060C:  BTFSS  F9E.3
060E:  BRA    060C
0610:  BCF    F9E.3
....................     Dummy = ENC_SSPBUF; 
0612:  MOVFF  FC9,42C
....................     ENC_CS_IO = 1; 
0616:  BSF    F8B.1
0618:  MOVLB  0
061A:  RETURN 0
.................... }//end BFSReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *                  16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *                  progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................     // Write the register address 
....................     BankSel(MIREGADR); 
*
0688:  MOVLW  02
068A:  MOVLB  4
068C:  MOVWF  x15
068E:  MOVLW  14
0690:  MOVWF  x14
0692:  MOVLB  0
0694:  RCALL  061C
....................     WriteReg((BYTE)MIREGADR, Register); 
0696:  MOVLW  14
0698:  MOVLB  4
069A:  MOVWF  x35
069C:  MOVFF  37C,436
06A0:  MOVLB  0
06A2:  RCALL  05A4
....................  
....................     // Write the data 
....................     // Order is important: write low byte first, high byte last 
....................     WriteReg((BYTE)MIWRL, ((WORD_VAL*)&Data)->v[0]); 
06A4:  MOVLW  03
06A6:  MOVLB  3
06A8:  MOVWF  x80
06AA:  MOVLW  7D
06AC:  MOVWF  x7F
06AE:  MOVWF  FE9
06B0:  MOVFF  380,FEA
06B4:  MOVFF  FEF,381
06B8:  MOVLW  16
06BA:  MOVLB  4
06BC:  MOVWF  x35
06BE:  MOVFF  381,436
06C2:  MOVLB  0
06C4:  RCALL  05A4
....................     WriteReg((BYTE)MIWRH, ((WORD_VAL*)&Data)->v[1]); 
06C6:  MOVLW  03
06C8:  MOVLB  3
06CA:  MOVWF  x80
06CC:  MOVLW  7D
06CE:  MOVWF  x7F
06D0:  MOVLW  01
06D2:  ADDWF  x7F,W
06D4:  MOVWF  FE9
06D6:  MOVLW  00
06D8:  ADDWFC x80,W
06DA:  MOVWF  FEA
06DC:  MOVFF  FEF,381
06E0:  MOVLW  17
06E2:  MOVLB  4
06E4:  MOVWF  x35
06E6:  MOVFF  381,436
06EA:  MOVLB  0
06EC:  RCALL  05A4
....................  
....................     // Wait until the PHY register has been written 
....................     BankSel(MISTAT); 
06EE:  MOVLW  03
06F0:  MOVLB  4
06F2:  MOVWF  x15
06F4:  MOVLW  0A
06F6:  MOVWF  x14
06F8:  MOVLB  0
06FA:  RCALL  061C
....................     while(ReadMACReg((BYTE)MISTAT).MISTATbits.BUSY); 
06FC:  MOVLW  0A
06FE:  MOVLB  3
0700:  MOVWF  x9F
0702:  MOVLB  0
0704:  RCALL  0652
0706:  MOVFF  01,37F
070A:  MOVLW  00
070C:  MOVLB  3
070E:  BTFSC  01.0
0710:  MOVLW  01
0712:  XORLW  00
0714:  BTFSC  FD8.2
0716:  BRA    071C
0718:  MOVLB  0
071A:  BRA    06FC
....................  
....................     BankSel(ERDPTL);    // Return to Bank 0 
071C:  MOVLB  4
071E:  CLRF   x15
0720:  CLRF   x14
0722:  MOVLB  0
0724:  RCALL  061C
0726:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                    select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *                  changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................     BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
061C:  MOVLW  1F
061E:  MOVLB  4
0620:  MOVWF  x2A
0622:  MOVLW  03
0624:  MOVWF  x2B
0626:  MOVLB  0
0628:  RCALL  04F0
....................     BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
062A:  MOVLW  04
062C:  MOVLB  4
062E:  MOVWF  x17
0630:  MOVLW  14
0632:  MOVWF  x16
0634:  MOVLW  01
0636:  ADDWF  x16,W
0638:  MOVWF  FE9
063A:  MOVLW  00
063C:  ADDWFC x17,W
063E:  MOVWF  FEA
0640:  MOVFF  FEF,418
0644:  MOVLW  1F
0646:  MOVWF  x2A
0648:  MOVFF  418,42B
064C:  MOVLB  0
064E:  RCALL  05F2
0650:  RETURN 0
.................... }//end BankSel 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *                  sleep mode, no packets can be transmitted or received. 
....................  *                  All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                  called, this function will block until it is it complete. 
....................  *                  If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................     // Disable packet reception 
....................     BFCReg(ECON1, ECON1_RXEN); 
....................  
....................     // Make sure any last packet which was in-progress when RXEN was cleared 
....................     // is completed 
....................     while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................     // If a packet is being transmitted, wait for it to finish 
....................     while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................     // Enter sleep mode 
....................     BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *                  after a previous call to MACPowerDown().  Calling this 
....................  *                  function when already powered up will have no effect. 
....................  * 
....................  * Note:            If a link partner is present, it will take 10s of 
....................  *                  milliseconds before a new link will be established after 
....................  *                  waking up.  While not linked, packets which are 
....................  *                  transmitted will most likely be lost.  MACIsLinked() can 
....................  *                  be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................     // Leave power down mode 
....................     BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................     // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................     // delay is required for the PHY module to return to an operational state. 
....................     while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................     // Enable packet reception 
....................     BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                              0x01: Divide by 1 (25 MHz) 
....................  *                              0x02: Divide by 2 (12.5 MHz) 
....................  *                              0x03: Divide by 3 (8.333333 MHz) 
....................  *                              0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                              0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *                  The CLKOUT pin will beginning outputting the new frequency 
....................  *                  immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................     BankSel(ECOCON); 
....................     WriteReg((BYTE)ECOCON, NewConfig); 
....................     BankSel(ERDPTL); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                         0x01: Divide by 1 (25 MHz) 
....................  *                         0x02: Divide by 2 (12.5 MHz) 
....................  *                         0x03: Divide by 3 (8.333333 MHz) 
....................  *                         0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                         0x05: Divide by 8 (3.125 MHz) 
....................  *                         0x06: Reserved 
....................  *                         0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................     BYTE i; 
....................  
....................     BankSel(ECOCON); 
....................     i = ReadETHReg((BYTE)ECOCON).Val; 
....................     BankSel(ERDPTL); 
....................     return i; 
.................... }//end GetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
....................  * 
....................  * PreCondition:    SPI interface must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           DestMACAddr: 6 byte group destination MAC address to allow  
....................  *                         through the Hash Table Filter.  If DestMACAddr  
....................  *                         is set to 00-00-00-00-00-00, then the hash  
....................  *                         table will be cleared of all entries and the  
....................  *                         filter will be disabled. 
....................  * 
....................  * Output:          Sets the appropriate bit in the EHT* registers to allow  
....................  *               packets sent to DestMACAddr to be received and enables the  
....................  *               Hash Table receive filter (if not already). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Calculates a CRC-32 using polynomial 0x4C11DB7 and then,  
....................  *               using bits 28:23 of the CRC, sets the appropriate bit in  
....................  *               the EHT0-EHT7 registers. 
....................  * 
....................  * Note:            This code is commented out to save code space on systems  
....................  *               that do not need this function.  Change the  
....................  *               "#if STACK_USE_ZEROCONF_MDNS_SD" line to "#if 1" to  
....................  *               uncomment it, assuming you aren't using the Zeroconf module,  
....................  *               which requires mutlicast support and enables this function  
....................  *               automatically. 
....................  * 
....................  *               There is no way to individually unset destination MAC  
....................  *               addresses from the hash table since it is possible to have  
....................  *               a hash collision and therefore multiple MAC addresses  
....................  *               relying on the same hash table bit.  The stack would have  
....................  *               to individually store each 6 byte MAC address to support  
....................  *               this feature, which would waste a lot of RAM and be  
....................  *               unnecessary in most applications.  As a simple compromise,  
....................  *               you can call SetRXHashTableEntry() using a  
....................  *               00-00-00-00-00-00 destination MAC address, which will clear  
....................  *               the entire hash table and disable the hash table filter.   
....................  *               This will allow you to then re-add the necessary  
....................  *               destination address(es). 
....................  * 
....................  *               This function is intended to be used when  
....................  *               ERXFCON.ANDOR == 0 (OR). 
....................  *****************************************************************************/ 
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
.................... void SetRXHashTableEntry(MAC_ADDR DestMACAddr) 
.................... { 
....................     DWORD_VAL CRC = {0xFFFFFFFF}; 
....................     BYTE HTRegister; 
....................     BYTE i, j; 
....................  
....................    // Select proper bank for ERXFCON and EHT0-EHT7 register access 
....................    BankSel(ERXFCON); 
....................  
....................    // Clear the Hash Table bits and disable the Hash Table Filter if a special  
....................    // 00-00-00-00-00-00 destination MAC address is provided. 
....................    if((DestMACAddr.v[0] | DestMACAddr.v[1] | DestMACAddr.v[2] | DestMACAddr.v[3] | DestMACAddr.v[4] | DestMACAddr.v[5]) == 0x00u) 
....................    { 
....................       // Disable the Hash Table receive filter and clear the hash table 
....................       BFCReg((BYTE)ERXFCON, ERXFCON_HTEN); 
....................       for(i = (BYTE)EHT0; i <= (BYTE)EHT7; i++) 
....................          WriteReg(i, 0x00); 
....................    } 
....................    else 
....................    { 
....................       // Calculate a CRC-32 over the 6 byte MAC address 
....................       // using polynomial 0x4C11DB7 
....................       for(i = 0; i < sizeof(MAC_ADDR); i++) 
....................       { 
....................          BYTE  crcnext; 
....................  
....................          // shift in 8 bits 
....................          for(j = 0; j < 8; j++) 
....................          { 
....................             crcnext = 0; 
....................             if(((BYTE_VAL*)&(CRC.v[3]))->bits.b7) 
....................                crcnext = 1; 
....................             crcnext ^= (((BYTE_VAL*)&DestMACAddr.v[i])->bits.b0); 
....................  
....................             CRC.Val <<= 1; 
....................             if(crcnext) 
....................                CRC.Val ^= 0x4C11DB7; 
....................             // next bit 
....................             DestMACAddr.v[i] >>= 1; 
....................          } 
....................       } 
....................  
....................       // CRC-32 calculated, now extract bits 28:23 
....................       // Bits 25:23 define where within the Hash Table byte the bit needs to be set 
....................       // Bits 28:26 define which of the 8 Hash Table bytes that bits 25:23 apply to 
....................       i = CRC.v[3] & 0x1F; 
....................       HTRegister = (i >> 2) + (BYTE)EHT0; 
....................       i = (i << 1) & 0x06; 
....................       ((BYTE_VAL*)&i)->bits.b0 = ((BYTE_VAL*)&CRC.v[2])->bits.b7; 
....................  
....................       // Set the proper bit in the Hash Table 
....................       BFSReg(HTRegister, 1<<i); 
....................  
....................       // Ensure that the Hash Table receive filter is enabled 
....................       BFSReg((BYTE)ERXFCON, ERXFCON_HTEN); 
....................    } 
....................  
....................     BankSel(ERDPTL);            // Return to Bank 0 
.................... } 
.................... #endif 
....................  
.................... //// GetRegs is a function for debugging purposes only.  It will read all 
.................... //// registers and store them in the PIC's RAM so they can be viewed with 
.................... //// the ICD2. 
.................... //REG Regs[4][32]; 
.................... //void GetRegs(void) 
.................... //{ 
.................... //  BYTE i; 
.................... // 
.................... //  BankSel(0x000); 
.................... //  for(i=0; i<0x1A; i++) 
.................... //      Regs[0][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[0][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x100); 
.................... //  for(i=0; i<0x1A; i++) 
.................... //      Regs[1][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[1][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x200); 
.................... //  for(i=0; i<5; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][5] = ReadETHReg(i); 
.................... //  for(i=6; i<0x0F; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][0x0F] = ReadETHReg(i); 
.................... //  for(i=0x10; i<0x13; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  Regs[2][0x13] = ReadETHReg(i); 
.................... //  for(i=0x14; i<0x1A; i++) 
.................... //      Regs[2][i] = ReadMACReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[2][i] = ReadETHReg(i); 
.................... // 
.................... //  BankSel(0x300); 
.................... //  for(i=0; i<0x06; i++) 
.................... //      Regs[3][i] = ReadMACReg(i); 
.................... //  for(i=6; i<0x0A; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... //  Regs[3][0x0A] = ReadMACReg(i); 
.................... //  for(i=0x0B; i<0x1A; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... //  for(i=0x1B; i<32; i++) 
.................... //      Regs[3][i] = ReadETHReg(i); 
.................... // 
.................... //  Regs[0][0x1A].Val = 0; 
.................... //  Regs[1][0x1A].Val = 0; 
.................... //  Regs[2][0x1A].Val = 0; 
.................... //  Regs[3][0x1A].Val = 0; 
.................... // 
.................... //  BankSel(ERDPTL); 
.................... // 
.................... //  return; 
.................... //} 
....................  
.................... //// Get8KBMem is a function intended for debugging purposes.  It will read all 
.................... //// Ethernet RAM and output it in hex out the UART 
.................... //void Get8KBMem(void) 
.................... //{ 
.................... //  WORD_VAL i; 
.................... //  BYTE v; 
.................... //  WORD_VAL RDSave; 
.................... // 
.................... //  RDSave.v[0] = ReadETHReg(ERDPTL).Val; 
.................... //  RDSave.v[1] = ReadETHReg(ERDPTH).Val; 
.................... // 
.................... //  for(i.Val = 0; i.Val < 8192; i.Val++) 
.................... //  { 
.................... //      WriteReg(ERDPTL, i.v[0]); 
.................... //      WriteReg(ERDPTH, i.v[1]); 
.................... //      v = MACGet(); 
.................... // 
.................... //      putcUART('0'); 
.................... //      while(BusyUART()); 
.................... //      putcUART('x'); 
.................... //      while(BusyUART()); 
.................... //      putcUART(btohexa_high(v)); 
.................... //      while(BusyUART()); 
.................... //      putcUART(btohexa_low(v)); 
.................... //      while(BusyUART()); 
.................... //  } 
.................... // 
.................... //  WriteReg(ERDPTL, RDSave.v[0]); 
.................... //  WriteReg(ERDPTH, RDSave.v[1]); 
.................... // 
.................... //} 
....................  
.................... #endif //#if defined(ENC_CS_TRIS) 
....................  
.................... #elif defined(ENC100_INTERFACE_MODE) 
....................    #include "ENCX24J600.c" 
....................    #define PHYREG WORD 
.................... #elif defined(__PIC32MX__) && defined(_ETH) 
....................    // extra includes for PIC32MX with embedded ETH Controller 
.................... #else 
....................    #error No Ethernet/WiFi controller defined in HardwareProfile.h.  Defines for an ENC28J60, ENC424J600/624J600, or ZeroG ZG2100 must be present. 
.................... #endif 
.................... #include "IP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Protocol (IP) Version 4 Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides a transport for TCP, UDP, and ICMP messages 
....................  *	 -Reference: RFC 791 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.c 
....................  * Dependencies:    Network Layer interface (ENC28J60.c, ETH97J60.c,  
....................  *					ENCX24J600.c or WFMac.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook			9/21/06	Corrected IPHeaderLen not being  
....................  * 								initialized when NON_MCHP_MAC defined. 
....................  ********************************************************************/ 
.................... #define __IP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #if defined(STACK_USE_ZEROCONF_MDNS_SD) 
....................   #define MY_IP_TTL           (255)  // Time-To-Live in hops  
....................   // IP TTL is set to 255 for Multicast DNS compatibility. See mDNS-draft-08, section 4. 
.................... #else 
....................   #define MY_IP_TTL           (100)  // Time-To-Live in hops 
.................... #endif 
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if defined(NON_MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... 	#define MAX_OPTIONS_LEN     (40u)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
4D80:  MOVLW  03
4D82:  MOVLB  3
4D84:  MOVWF  xBA
4D86:  MOVLW  A5
4D88:  MOVWF  xB9
4D8A:  MOVFF  3BA,433
4D8E:  MOVFF  FE8,432
4D92:  MOVLB  4
4D94:  CLRF   x35
4D96:  MOVLW  14
4D98:  MOVWF  x34
4D9A:  MOVLB  0
4D9C:  CALL   0BD0
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if((header.VersionIHL & 0xf0) != IP_VERSION) 
4DA0:  MOVLB  3
4DA2:  MOVF   xA5,W
4DA4:  ANDLW  F0
4DA6:  SUBLW  40
4DA8:  BZ    4DB0
....................     	return FALSE; 
4DAA:  MOVLW  00
4DAC:  MOVWF  01
4DAE:  BRA    4E80
....................  
.................... 	// Throw this packet away if it is a fragment.   
.................... 	// We don't have enough RAM for IP fragment reconstruction. 
.................... 	if(header.FragmentInfo & 0xFF1F) 
4DB0:  MOVF   xAB,W
4DB2:  ANDLW  1F
4DB4:  MOVWF  00
4DB6:  MOVFF  3AC,03
4DBA:  MOVF   00,W
4DBC:  IORWF  xAC,W
4DBE:  BZ    4DC6
.................... 		return FALSE; 
4DC0:  MOVLW  00
4DC2:  MOVWF  01
4DC4:  BRA    4E80
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
4DC6:  MOVF   xA5,W
4DC8:  ANDLW  0F
4DCA:  MOVWF  00
4DCC:  RLCF   00,W
4DCE:  MOVLB  1
4DD0:  MOVWF  x25
4DD2:  RLCF   x25,F
4DD4:  MOVLW  FC
4DD6:  ANDWF  x25,F
....................  
.................... #if !defined(NON_MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum  
.................... 	// will come out to 0x0000 (because the header contains a  
.................... 	// precomputed checksum).  A corrupt header will have a  
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
4DD8:  MOVLB  3
4DDA:  CLRF   xBA
4DDC:  CLRF   xB9
4DDE:  CLRF   xBC
4DE0:  MOVFF  125,3BB
4DE4:  MOVLB  0
4DE6:  RCALL  4CCC
4DE8:  MOVFF  02,3A4
4DEC:  MOVFF  01,3A3
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetReadPtrInRx(IPHeaderLen); 
4DF0:  MOVLB  3
4DF2:  CLRF   xEF
4DF4:  MOVFF  125,3EE
4DF8:  MOVLB  0
4DFA:  CALL   26BA
....................  
....................     if(CalcChecksum.Val) 
4DFE:  MOVLB  3
4E00:  MOVF   xA3,W
4E02:  IORWF  xA4,W
4E04:  BZ    4E0C
.................... #else 
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = IPHeaderLen - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0u ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0u ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE  
....................         // return value and it should discard the packet. 
....................         return FALSE; 
4E06:  MOVLW  00
4E08:  MOVWF  01
4E0A:  BRA    4E80
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
4E0C:  MOVLW  03
4E0E:  MOVLB  4
4E10:  MOVWF  x2A
4E12:  MOVLW  A5
4E14:  MOVWF  x29
4E16:  MOVLB  0
4E18:  CALL   1CB4
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
4E1C:  MOVLB  3
4E1E:  MOVF   x9B,W
4E20:  IORWF  x9C,W
4E22:  BZ    4E3C
....................         localIP->Val    = header.DestAddress.Val; 
4E24:  MOVFF  39B,FE9
4E28:  MOVFF  39C,FEA
4E2C:  MOVFF  3B5,FEF
4E30:  MOVFF  3B6,FEC
4E34:  MOVFF  3B7,FEC
4E38:  MOVFF  3B8,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
4E3C:  MOVFF  39D,FE9
4E40:  MOVF   x9E,W
4E42:  MOVWF  FEA
4E44:  MOVFF  3B1,FEF
4E48:  MOVFF  3B2,FEC
4E4C:  MOVFF  3B3,FEC
4E50:  MOVFF  3B4,FEC
....................     *protocol           = header.Protocol; 
4E54:  MOVFF  39F,FE9
4E58:  MOVFF  3A0,FEA
4E5C:  MOVFF  3AE,FEF
....................     *len 				= header.TotalLength - IPHeaderLen; 
4E60:  MOVFF  3A1,FE9
4E64:  MOVFF  3A2,FEA
4E68:  MOVLB  1
4E6A:  MOVF   x25,W
4E6C:  MOVLB  3
4E6E:  SUBWF  xA7,W
4E70:  MOVWF  00
4E72:  MOVLW  00
4E74:  SUBWFB xA8,W
4E76:  MOVFF  00,FEF
4E7A:  MOVWF  FEC
....................  
....................     return TRUE; 
4E7C:  MOVLW  01
4E7E:  MOVWF  01
4E80:  MOVLB  0
4E82:  GOTO   6DFA (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                  BYTE protocol, 
....................                  WORD len) 
.................... { 
....................     IP_HEADER   header; 
....................      
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
1F3C:  MOVLW  14
1F3E:  MOVLB  1
1F40:  MOVWF  x25
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
1F42:  MOVLW  45
1F44:  MOVLB  4
1F46:  MOVWF  x15
....................     header.TypeOfService    = IP_SERVICE; 
1F48:  CLRF   x16
....................     header.TotalLength      = sizeof(header) + len; 
1F4A:  MOVLW  14
1F4C:  ADDWF  x13,W
1F4E:  MOVWF  x17
1F50:  MOVLW  00
1F52:  ADDWFC x14,W
1F54:  MOVWF  x18
....................     header.Identification   = ++_Identifier; 
1F56:  MOVLB  1
1F58:  INCF   x23,F
1F5A:  BTFSC  FD8.2
1F5C:  INCF   x24,F
1F5E:  MOVFF  124,41A
1F62:  MOVFF  123,419
....................     header.FragmentInfo     = 0; 
1F66:  MOVLB  4
1F68:  CLRF   x1C
1F6A:  CLRF   x1B
....................     header.TimeToLive       = MY_IP_TTL; 
1F6C:  MOVLW  64
1F6E:  MOVWF  x1D
....................     header.Protocol         = protocol; 
1F70:  MOVFF  412,41E
....................     header.HeaderChecksum   = 0; 
1F74:  CLRF   x20
1F76:  CLRF   x1F
.................... 	header.SourceAddress 	= AppConfig.MyIPAddr; 
1F78:  MOVFF  25,424
1F7C:  MOVFF  24,423
1F80:  MOVFF  23,422
1F84:  MOVFF  22,421
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
1F88:  MOVFF  410,FE9
1F8C:  MOVFF  411,FEA
1F90:  MOVFF  FEF,425
1F94:  MOVFF  FEC,426
1F98:  MOVFF  FEC,427
1F9C:  MOVFF  FEC,428
....................  
....................     SwapIPHeader(&header); 
1FA0:  MOVLW  04
1FA2:  MOVWF  x2A
1FA4:  MOVLW  15
1FA6:  MOVWF  x29
1FA8:  MOVLB  0
1FAA:  RCALL  1CB4
....................  
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, sizeof(header)); 
1FAC:  MOVLW  04
1FAE:  MOVLB  4
1FB0:  MOVWF  x2A
1FB2:  MOVLW  15
1FB4:  MOVWF  x29
1FB6:  MOVFF  42A,42C
1FBA:  MOVWF  x2B
1FBC:  CLRF   x2E
1FBE:  MOVLW  14
1FC0:  MOVWF  x2D
1FC2:  MOVLB  0
1FC4:  RCALL  1D8E
1FC6:  MOVFF  02,420
1FCA:  MOVFF  01,41F
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
1FCE:  MOVLW  04
1FD0:  MOVLB  4
1FD2:  ADDWF  x10,W
1FD4:  MOVWF  01
1FD6:  MOVLW  00
1FD8:  ADDWFC x11,W
1FDA:  MOVWF  03
1FDC:  MOVFF  01,429
1FE0:  MOVWF  x2A
1FE2:  MOVLW  14
1FE4:  ADDWF  x13,W
1FE6:  MOVWF  x2B
1FE8:  MOVLW  00
1FEA:  ADDWFC x14,W
1FEC:  MOVWF  x2C
1FEE:  MOVFF  03,42E
1FF2:  MOVFF  01,42D
1FF6:  CLRF   x2F
1FF8:  MOVWF  x31
1FFA:  MOVFF  42B,430
1FFE:  MOVLB  0
2000:  RCALL  1E76
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
2002:  MOVLW  04
2004:  MOVLB  4
2006:  MOVWF  x2A
2008:  MOVLW  15
200A:  MOVWF  x29
200C:  MOVFF  42A,435
2010:  MOVWF  x34
2012:  CLRF   x37
2014:  MOVLW  14
2016:  MOVWF  x36
2018:  MOVLB  0
201A:  CALL   0B1E
....................  
....................     return 0x0000; 
201E:  MOVLW  00
2020:  MOVWF  01
2022:  MOVWF  02
2024:  RETURN 0
....................  
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by  
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset  
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset)  
.................... { 
.................... 	MACSetReadPtrInRx(Offset+IPHeaderLen); 
*
2712:  MOVLB  1
2714:  MOVF   x25,W
2716:  MOVLB  3
2718:  ADDWF  xEA,W
271A:  MOVWF  xEC
271C:  MOVLW  00
271E:  ADDWFC xEB,W
2720:  MOVWF  xED
2722:  MOVWF  xEF
2724:  MOVFF  3EC,3EE
2728:  MOVLB  0
272A:  RCALL  26BA
272C:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
1CB4:  MOVLW  02
1CB6:  MOVLB  4
1CB8:  ADDWF  x29,W
1CBA:  MOVWF  01
1CBC:  MOVLW  00
1CBE:  ADDWFC x2A,W
1CC0:  MOVWF  03
1CC2:  MOVFF  01,42B
1CC6:  MOVWF  x2C
1CC8:  MOVLW  02
1CCA:  ADDWF  x29,W
1CCC:  MOVWF  FE9
1CCE:  MOVLW  00
1CD0:  ADDWFC x2A,W
1CD2:  MOVWF  FEA
1CD4:  MOVFF  FEC,42E
1CD8:  MOVF   FED,F
1CDA:  MOVFF  FEF,42D
1CDE:  MOVFF  42E,430
1CE2:  MOVFF  42D,42F
1CE6:  MOVLB  0
1CE8:  RCALL  1C92
1CEA:  MOVFF  42C,FEA
1CEE:  MOVFF  42B,FE9
1CF2:  MOVFF  02,FEC
1CF6:  MOVF   FED,F
1CF8:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
1CFC:  MOVLW  04
1CFE:  MOVLB  4
1D00:  ADDWF  x29,W
1D02:  MOVWF  01
1D04:  MOVLW  00
1D06:  ADDWFC x2A,W
1D08:  MOVWF  03
1D0A:  MOVFF  01,42B
1D0E:  MOVWF  x2C
1D10:  MOVLW  04
1D12:  ADDWF  x29,W
1D14:  MOVWF  FE9
1D16:  MOVLW  00
1D18:  ADDWFC x2A,W
1D1A:  MOVWF  FEA
1D1C:  MOVFF  FEC,42E
1D20:  MOVF   FED,F
1D22:  MOVFF  FEF,42D
1D26:  MOVFF  42E,430
1D2A:  MOVFF  42D,42F
1D2E:  MOVLB  0
1D30:  RCALL  1C92
1D32:  MOVFF  42C,FEA
1D36:  MOVFF  42B,FE9
1D3A:  MOVFF  02,FEC
1D3E:  MOVF   FED,F
1D40:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
1D44:  MOVLW  0A
1D46:  MOVLB  4
1D48:  ADDWF  x29,W
1D4A:  MOVWF  01
1D4C:  MOVLW  00
1D4E:  ADDWFC x2A,W
1D50:  MOVWF  03
1D52:  MOVFF  01,42B
1D56:  MOVWF  x2C
1D58:  MOVLW  0A
1D5A:  ADDWF  x29,W
1D5C:  MOVWF  FE9
1D5E:  MOVLW  00
1D60:  ADDWFC x2A,W
1D62:  MOVWF  FEA
1D64:  MOVFF  FEC,42E
1D68:  MOVF   FED,F
1D6A:  MOVFF  FEF,42D
1D6E:  MOVFF  42E,430
1D72:  MOVFF  42D,42F
1D76:  MOVLB  0
1D78:  RCALL  1C92
1D7A:  MOVFF  42C,FEA
1D7E:  MOVFF  42B,FE9
1D82:  MOVFF  02,FEC
1D86:  MOVF   FED,F
1D88:  MOVFF  01,FEF
1D8C:  RETURN 0
.................... } 
....................  
.................... #include "ARP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Address Resolution Protocol (ARP) Client and Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides IP address to Ethernet MAC address translation 
....................  *    -Reference: RFC 826 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  ARP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02  Cleanup 
....................  * Nilesh Rajbharti     5/22/02 Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder      8/17/06   Combined ARP.c and ARPTsk.c into ARP.c;  
....................  *                        rewrote some of it to look more linear 
....................  * Darren Rook/CCS      Added call to GratArpReset() if using STACK_USE_CCS_GRATUITOUS_ARP 
....................  ********************************************************************/ 
.................... #define __ARP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Constants and Variables 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... //#define ARP_OPERATION_REQ       0x01u      // Operation code indicating an ARP Request 
.................... //#define ARP_OPERATION_RESP      0x02u      // Operation code indicating an ARP Response 
....................  
.................... #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3 
.................... #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3 
.................... #endif 
....................  
.................... #ifdef STACK_CLIENT_MODE 
.................... static NODE_INFO Cache;                  // Cache for one ARP response 
.................... #endif 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define MAX_REG_APPS            2           // MAX num allowed registrations of Modules/Apps 
.................... static struct arp_app_callbacks reg_apps[MAX_REG_APPS]; // Call-Backs storage for MAX of two Modules/Apps 
.................... /* 
.................... // ARP packet structure 
.................... typedef struct __attribute__((aligned(2), packed)) 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
.................... */ 
.................... #endif 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Helper Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static BOOL ARPPut(ARP_PACKET* packet); 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Implementations 
....................   ***************************************************************************/ 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... /************ User Application APIs ****************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
....................  
....................   Summary: 
....................    Registering callback with ARP module to get notified about certian events. 
....................     
....................   Description: 
....................      This function allows end user application to register with callbacks, which 
....................     will be called by ARP module to give notification to user-application about  
....................     events occurred at ARP layer. For ex: when a ARP-packet is received, which is 
....................     conflicting with our own pair of addresses (MAC-Address and IP-address). 
....................     This is an extension for zeroconf protocol implementation (ZeroconfLL.c) 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    app - ARP-Application callbacks structure supplied by user-application  
....................      
....................   Returns: 
....................     id > 0 - Returns non-negative value that represents the id of registration 
....................              The same id needs to be used in de-registration 
....................     -1     - When registered applications exceed MAX_REG_APPS and there is no 
....................              free slot for registration 
....................   
....................   ***************************************************************************/ 
.................... CHAR ARPRegisterCallbacks(struct arp_app_callbacks *app) 
.................... { 
....................     BYTE i; 
....................     for(i=0; i<MAX_REG_APPS; i++) 
....................     { 
....................         if(!reg_apps[i].used) 
....................         { 
....................             reg_apps[i].ARPPkt_notify = app->ARPPkt_notify; 
....................             reg_apps[i].used = 1; 
....................             return (i+1); // Return Code. Should be used in deregister. 
....................         } 
....................     } 
....................     return -1; // No space for registration 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
....................  
....................   Summary: 
....................    De-Registering callbacks with ARP module that are registered previously. 
....................     
....................   Description: 
....................      This function allows end user-application to de-register with callbacks,  
....................     which were registered previously. 
....................     This is called by user-application, when its no longer interested in  
....................     notifications from ARP-Module. This allows the other application to get  
....................     registered with ARP-module.    
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    reg_id - Registration-id returned in ARPRegisterCallbacks call 
....................      
....................   Returns: 
....................     TRUE  - On success 
....................     FALSE - Failure to indicate invalid reg_id   
....................   ***************************************************************************/  
.................... BOOL ARPDeRegisterCallbacks(CHAR reg_id) 
.................... { 
....................     if(reg_id <= 0 || reg_id > MAX_REG_APPS) 
....................         return FALSE; 
....................  
....................     reg_apps[reg_id-1].used = 0; // To indicate free slot for registration 
....................    return TRUE; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPProcessRxPkt(ARP_PACKET* packet) 
....................  
....................   Summary: 
....................    Processes Received-ARP packet (ARP request/Reply). 
....................     
....................   Description: 
....................      This function is to pass-on the ARP-packet to registered application, 
....................     with the notification of Rx-ARP packet.  
....................  
....................   Precondition: 
....................    ARP packet is received completely from MAC 
....................  
....................   Parameters: 
....................    packet - Rx packet to be processed      
....................  
....................   Returns: 
....................     None    
....................   ***************************************************************************/ 
.................... void ARPProcessRxPkt(ARP_PACKET* packet) 
.................... { 
....................     BYTE pass_on = 0; // Flag to indicate whether need to be forwarded 
....................     BYTE i; 
....................  
....................     // Probing Stage 
....................     if(AppConfig.MyIPAddr.Val == 0x00) 
....................     { 
....................         pass_on = 1; // Pass to Registered-Application for further processing         
....................     } 
....................     else if(AppConfig.MyIPAddr.Val) 
....................     { 
....................         /* Late-conflict */ 
....................         if(packet->SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................         { 
....................             pass_on = 1; 
....................         } 
....................     } 
....................     if(pass_on) 
....................     { 
....................      
....................         for(i =0; i< MAX_REG_APPS; i++) 
....................         { 
....................             if(reg_apps[i].used) 
....................             { 
....................                 reg_apps[i].ARPPkt_notify(packet->SenderIPAddr.Val, 
....................                                       packet->TargetIPAddr.Val, 
....................                                       &packet->SenderMACAddr, 
....................                                       &packet->TargetMACAddr, 
....................                                       packet->Operation);                 
....................             } 
....................         } 
....................     } 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPSendPkt(IP_ADDR* SrcIPAddr, IP_ADDR* DestIPAddr, int op_req ) 
....................  
....................   Summary: 
....................    Transmits an ARP request/Reply initated by Application or external module. 
....................     
....................   Description: 
....................      This function transmits and ARP request/reply to determine the hardware 
....................      address of a given IP address (or) Announce self-address to all nodes in 
....................     network. Extended for zeroconf protocol.  
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    SrcIPAddr - The Source IP-address  
....................     DestIPAddr - The Destination IP-Address 
....................     op_req     - Operation Request (ARP_REQ/ARP_RESP) 
....................  
....................   Returns: 
....................     TRUE - The ARP packet was generated properly 
....................      FALSE - Not possible return value 
....................  
....................   Remarks: 
....................      This API is to give control over AR-packet to external modules.  
....................   ***************************************************************************/ 
.................... BOOL ARPSendPkt(DWORD SrcIPAddr, DWORD DestIPAddr, BYTE op_req ) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................    DWORD_VAL *DestAddr = (DWORD_VAL *)&DestIPAddr; 
....................    if ((DestAddr->v[0] >= 224) &&(DestAddr->v[0] <= 239)) { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................     
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & DestAddr->v[1]; 
....................       Cache.MACAddr.v[4] = DestAddr->v[2]; 
....................       Cache.MACAddr.v[5] = DestAddr->v[3]; 
....................     
....................       Cache.IPAddr.Val = DestAddr->Val; 
....................     
....................       return TRUE; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................     packet.Operation = op_req; 
....................    packet.TargetMACAddr.v[0]   = 0xff; 
....................    packet.TargetMACAddr.v[1]   = 0xff; 
....................    packet.TargetMACAddr.v[2]   = 0xff; 
....................    packet.TargetMACAddr.v[3]   = 0xff; 
....................    packet.TargetMACAddr.v[4]   = 0xff; 
....................    packet.TargetMACAddr.v[5]   = 0xff; 
....................  
....................     packet.TargetIPAddr.Val   = DestIPAddr; 
....................     packet.SenderIPAddr.Val = SrcIPAddr; 
....................  
....................     return ( ARPPut(&packet) ); 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL ARPPut(ARP_PACKET* packet) 
....................  
....................   Description: 
....................    Writes an ARP packet to the MAC. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    packet - A pointer to an ARP_PACKET structure with correct operation 
....................             and target preconfigured. 
....................  
....................   Return Values: 
....................      TRUE - The ARP packet was generated properly 
....................      FALSE - Not a possible return value 
....................   ***************************************************************************/ 
.................... static BOOL ARPPut(ARP_PACKET* packet) 
.................... { 
....................    while(!MACIsTxReady()); 
*
4AAA:  CALL   19F2
4AAE:  MOVF   01,F
4AB0:  BZ    4AAA
....................    MACSetWritePtr(BASE_TX_ADDR); 
4AB2:  MOVLW  11
4AB4:  MOVLB  4
4AB6:  MOVWF  x20
4AB8:  MOVLW  D7
4ABA:  MOVWF  x1F
4ABC:  MOVLB  0
4ABE:  CALL   0AAE
....................     
....................  
....................     packet->HardwareType  = HW_ETHERNET; 
4AC2:  MOVLB  3
4AC4:  MOVFF  3B7,FE9
4AC8:  MOVFF  3B8,FEA
4ACC:  CLRF   FEC
4ACE:  MOVF   FED,F
4AD0:  MOVLW  01
4AD2:  MOVWF  FEF
....................     packet->Protocol      = ARP_IP; 
4AD4:  MOVLW  02
4AD6:  ADDWF  xB7,W
4AD8:  MOVWF  FE9
4ADA:  MOVLW  00
4ADC:  ADDWFC xB8,W
4ADE:  MOVWF  FEA
4AE0:  MOVLW  08
4AE2:  MOVWF  FEC
4AE4:  MOVF   FED,F
4AE6:  CLRF   FEF
....................     packet->MACAddrLen    = sizeof(MAC_ADDR); 
4AE8:  MOVLW  04
4AEA:  ADDWF  xB7,W
4AEC:  MOVWF  FE9
4AEE:  MOVLW  00
4AF0:  ADDWFC xB8,W
4AF2:  MOVWF  FEA
4AF4:  MOVLW  06
4AF6:  MOVWF  FEF
....................     packet->ProtocolLen   = sizeof(IP_ADDR); 
4AF8:  MOVLW  05
4AFA:  ADDWF  xB7,W
4AFC:  MOVWF  FE9
4AFE:  MOVLW  00
4B00:  ADDWFC xB8,W
4B02:  MOVWF  FEA
4B04:  MOVLW  04
4B06:  MOVWF  FEF
.................... //    packet->SenderMACAddr = AppConfig.MyMACAddr;   // HI-TECH PICC-18 compiler can't handle this statement, use memcpy() as a workaround 
....................    memcpy(&packet->SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(packet->SenderMACAddr)); 
4B08:  MOVLW  08
4B0A:  ADDWF  xB7,W
4B0C:  MOVWF  01
4B0E:  MOVLW  00
4B10:  ADDWFC xB8,W
4B12:  MOVWF  03
4B14:  MOVFF  01,3B9
4B18:  MOVWF  xBA
4B1A:  CLRF   xBC
4B1C:  MOVLW  4F
4B1E:  MOVFF  03,FEA
4B22:  MOVFF  01,FE9
4B26:  MOVFF  3BC,FE2
4B2A:  MOVWF  FE1
4B2C:  MOVLW  06
4B2E:  MOVWF  01
4B30:  MOVFF  FE6,FEE
4B34:  DECFSZ 01,F
4B36:  BRA    4B30
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................     //packet->SenderIPAddr  = AppConfig.MyIPAddr; /* Removed for ZCLL, SenderIPAddr should be filled in */ 
.................... #else 
....................     packet->SenderIPAddr  = AppConfig.MyIPAddr; 
4B38:  MOVLW  0E
4B3A:  ADDWF  xB7,W
4B3C:  MOVWF  FE9
4B3E:  MOVLW  00
4B40:  ADDWFC xB8,W
4B42:  MOVWF  FEA
4B44:  MOVFF  22,FEF
4B48:  MOVFF  23,FEC
4B4C:  MOVFF  24,FEC
4B50:  MOVFF  25,FEC
.................... #endif 
....................  
....................     SwapARPPacket(packet); 
4B54:  MOVFF  3B8,3BA
4B58:  MOVFF  3B7,3B9
4B5C:  MOVLB  0
4B5E:  RCALL  49D0
....................  
....................     MACPutHeader(&packet->TargetMACAddr, MAC_ARP, sizeof(*packet)); 
4B60:  MOVLW  12
4B62:  MOVLB  3
4B64:  ADDWF  xB7,W
4B66:  MOVWF  01
4B68:  MOVLW  00
4B6A:  ADDWFC xB8,W
4B6C:  MOVWF  03
4B6E:  MOVFF  01,3B9
4B72:  MOVWF  xBA
4B74:  MOVFF  FE8,42E
4B78:  MOVFF  01,42D
4B7C:  MOVLW  06
4B7E:  MOVLB  4
4B80:  MOVWF  x2F
4B82:  CLRF   x31
4B84:  MOVLW  1C
4B86:  MOVWF  x30
4B88:  MOVLB  0
4B8A:  CALL   1E76
....................     MACPutArray((BYTE*)packet, sizeof(*packet)); 
4B8E:  MOVFF  3B8,435
4B92:  MOVFF  3B7,434
4B96:  MOVLB  4
4B98:  CLRF   x37
4B9A:  MOVLW  1C
4B9C:  MOVWF  x36
4B9E:  MOVLB  0
4BA0:  CALL   0B1E
....................     MACFlush(); 
4BA4:  CALL   2026
....................     
....................    return TRUE; 
4BA8:  MOVLW  01
4BAA:  MOVWF  01
4BAC:  GOTO   4CAC (RETURN)
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPInit(void) 
....................  
....................   Summary: 
....................    Initializes the ARP module. 
....................     
....................   Description: 
....................      Initializes the ARP module.  Call this function once at boot to  
....................      invalidate the cached lookup. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................    
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPInit(void) 
.................... { 
....................     Cache.MACAddr.v[0] = 0xff; 
....................     Cache.MACAddr.v[1] = 0xff; 
....................     Cache.MACAddr.v[2] = 0xff; 
....................     Cache.MACAddr.v[3] = 0xff; 
....................     Cache.MACAddr.v[4] = 0xff; 
....................     Cache.MACAddr.v[5] = 0xff; 
....................  
....................    Cache.IPAddr.Val = 0xfffffffful; 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPProcess(void) 
....................  
....................   Summary: 
....................    Processes an incoming ARP packet. 
....................     
....................   Description: 
....................      Retrieves an ARP packet from the MAC buffer and determines if it is a 
....................      response to our request (in which case the ARP is resolved) or if it 
....................      is a request requiring our response (in which case we transmit one.) 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Return Values: 
....................      TRUE - All processing of this ARP packet is complete.  Do not call  
....................            again until a new ARP packet is waiting in the RX buffer. 
....................      FALSE - This function must be called again.  More time is needed to  
....................            send an ARP response. 
....................   ***************************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................    ARP_PACKET packet; 
....................    static NODE_INFO Target; 
....................     #if defined(STACK_USE_AUTO_IP) 
....................         BYTE i; 
....................     #endif 
....................    static enum 
....................    { 
....................        SM_ARP_IDLE = 0, 
....................        SM_ARP_REPLY 
....................    } smARP = SM_ARP_IDLE; 
....................  
....................     switch(smARP) 
4BB0:  MOVLW  00
4BB2:  MOVLB  1
4BB4:  BTFSC  x0B.3
4BB6:  MOVLW  01
4BB8:  XORLW  00
4BBA:  MOVLB  0
4BBC:  BZ    4BC4
4BBE:  XORLW  01
4BC0:  BZ    4C6C
4BC2:  BRA    4CC0
....................     { 
....................        case SM_ARP_IDLE: 
....................          // Obtain the incoming ARP packet 
....................           MACGetArray((BYTE*)&packet, sizeof(packet));       
4BC4:  MOVLW  03
4BC6:  MOVLB  3
4BC8:  MOVWF  xB8
4BCA:  MOVLW  9B
4BCC:  MOVWF  xB7
4BCE:  MOVFF  3B8,433
4BD2:  MOVFF  FE8,432
4BD6:  MOVLB  4
4BD8:  CLRF   x35
4BDA:  MOVLW  1C
4BDC:  MOVWF  x34
4BDE:  MOVLB  0
4BE0:  CALL   0BD0
....................           MACDiscardRx(); 
4BE4:  CALL   2870
....................           SwapARPPacket(&packet); 
4BE8:  MOVLW  03
4BEA:  MOVLB  3
4BEC:  MOVWF  xBA
4BEE:  MOVLW  9B
4BF0:  MOVWF  xB9
4BF2:  MOVLB  0
4BF4:  RCALL  49D0
....................        
....................          // Validate the ARP packet 
....................           if ( packet.HardwareType != HW_ETHERNET     || 
....................                packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................                packet.ProtocolLen != sizeof(IP_ADDR) ) 
4BF6:  MOVLB  3
4BF8:  DECFSZ x9B,W
4BFA:  BRA    4C0C
4BFC:  MOVF   x9C,F
4BFE:  BNZ   4C0C
4C00:  MOVF   x9F,W
4C02:  SUBLW  06
4C04:  BNZ   4C0C
4C06:  MOVF   xA0,W
4C08:  SUBLW  04
4C0A:  BZ    4C12
....................           { 
....................                return TRUE; 
4C0C:  MOVLW  01
4C0E:  MOVWF  01
4C10:  BRA    4CC6
....................           } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................          ARPProcessRxPkt(&packet); 
.................... #endif 
....................  
.................... #ifdef STACK_USE_AUTO_IP 
....................             if (packet.SenderIPAddr.Val == AppConfig.MyIPAddr.Val) 
....................             { 
....................                 AutoIPConflict(0); 
....................                 return TRUE;                 
....................             } 
.................... #endif 
.................... #ifdef STACK_USE_CCS_GRATUITOUS_ARP 
.................... GratArpReset(); 
.................... #endif 
....................          // Handle incoming ARP responses 
.................... #ifdef STACK_CLIENT_MODE 
....................          if(packet.Operation == ARP_OPERATION_RESP) 
....................          { 
.................... /*                #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                         AutoIPConflict(i); 
....................                 #endif*/ 
....................             Cache.MACAddr = packet.SenderMACAddr; 
....................             Cache.IPAddr = packet.SenderIPAddr; 
....................             return TRUE; 
....................          } 
.................... #endif 
....................  
....................          // Handle incoming ARP requests for our MAC address 
....................          if(packet.Operation == ARP_OPERATION_REQ) 
4C12:  DECFSZ xA1,W
4C14:  BRA    4C6A
4C16:  MOVF   xA2,F
4C18:  BNZ   4C6A
....................          { 
....................             if(packet.TargetIPAddr.Val != AppConfig.MyIPAddr.Val) 
4C1A:  MOVF   22,W
4C1C:  SUBWF  xB3,W
4C1E:  BNZ   4C32
4C20:  MOVF   23,W
4C22:  SUBWF  xB4,W
4C24:  BNZ   4C32
4C26:  MOVF   24,W
4C28:  SUBWF  xB5,W
4C2A:  BNZ   4C32
4C2C:  MOVF   25,W
4C2E:  SUBWF  xB6,W
4C30:  BZ    4C38
....................             { 
....................                return TRUE; 
4C32:  MOVLW  01
4C34:  MOVWF  01
4C36:  BRA    4CC6
....................             } 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................                                /* Fix for Loop-Back suppression: 
....................                                 * For ZCLL-Claim packets, host should not respond. 
....................                                 * Check Sender's MAC-address with own MAC-address and  
....................                                 * if it is matched, response will not be sent back. This 
....................                                 * was leading to flooding of ARP-answeres */ 
....................                                 if(!memcmp (&packet.SenderMACAddr, &AppConfig.MyMACAddr, 6)) 
....................                                 { 
....................                                      putsUART("Loopback answer suppressed \r\n"); 
....................                                      return TRUE; 
....................                                 } 
.................... #endif 
....................                 #if defined(STACK_USE_AUTO_IP) 
....................                 for (i = 0; i < NETWORK_INTERFACES; i++) 
....................                     if (AutoIPConfigIsInProgress(i)) 
....................                     { 
....................                         AutoIPConflict(i); 
....................                         return TRUE; 
....................                     }              
....................                 #endif 
....................             Target.IPAddr = packet.SenderIPAddr; 
4C38:  MOVFF  3AC,129
4C3C:  MOVFF  3AB,128
4C40:  MOVFF  3AA,127
4C44:  MOVFF  3A9,126
....................             Target.MACAddr = packet.SenderMACAddr; 
4C48:  MOVLW  01
4C4A:  MOVWF  FEA
4C4C:  MOVLW  2A
4C4E:  MOVWF  FE9
4C50:  MOVLW  03
4C52:  MOVWF  FE2
4C54:  MOVLW  A3
4C56:  MOVWF  FE1
4C58:  MOVLW  06
4C5A:  MOVWF  01
4C5C:  MOVFF  FE6,FEE
4C60:  DECFSZ 01,F
4C62:  BRA    4C5C
....................  
....................             smARP = SM_ARP_REPLY; 
4C64:  MOVLB  1
4C66:  BSF    x0B.3
4C68:  MOVLB  3
4C6A:  MOVLB  0
....................          } 
....................          // Do not break.  If we get down here, we need to send a reply.    
....................  
....................        case SM_ARP_REPLY: 
....................            packet.Operation      = ARP_OPERATION_RESP; 
4C6C:  MOVLB  3
4C6E:  CLRF   xA2
4C70:  MOVLW  02
4C72:  MOVWF  xA1
....................             #if defined(STACK_USE_AUTO_IP) 
....................             if (AutoIPIsConfigured(0)) 
....................             { 
....................                 packet.TargetMACAddr.v[0] = 0xFF; 
....................                 packet.TargetMACAddr.v[1] = 0xFF; 
....................                 packet.TargetMACAddr.v[2] = 0xFF; 
....................                 packet.TargetMACAddr.v[3] = 0xFF; 
....................                 packet.TargetMACAddr.v[4] = 0xFF; 
....................                 packet.TargetMACAddr.v[5] = 0xFF; 
....................             } 
....................             else 
....................             #endif 
....................                packet.TargetMACAddr   = Target.MACAddr; 
4C74:  MOVLW  03
4C76:  MOVWF  FEA
4C78:  MOVLW  AD
4C7A:  MOVWF  FE9
4C7C:  MOVLW  01
4C7E:  MOVWF  FE2
4C80:  MOVLW  2A
4C82:  MOVWF  FE1
4C84:  MOVLW  06
4C86:  MOVWF  01
4C88:  MOVFF  FE6,FEE
4C8C:  DECFSZ 01,F
4C8E:  BRA    4C88
....................            packet.TargetIPAddr      = Target.IPAddr; 
4C90:  MOVFF  129,3B6
4C94:  MOVFF  128,3B5
4C98:  MOVFF  127,3B4
4C9C:  MOVFF  126,3B3
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................             packet.SenderIPAddr      = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................          // Send an ARP response to a previously received request 
....................          if(!ARPPut(&packet)) 
4CA0:  MOVLW  03
4CA2:  MOVWF  xB8
4CA4:  MOVLW  9B
4CA6:  MOVWF  xB7
4CA8:  MOVLB  0
4CAA:  BRA    4AAA
4CAC:  MOVF   01,F
4CAE:  BNZ   4CBA
....................          { 
....................               return FALSE; 
4CB0:  MOVLW  00
4CB2:  MOVWF  01
4CB4:  MOVLB  3
4CB6:  BRA    4CC6
4CB8:  MOVLB  0
....................          } 
....................  
....................          // Begin listening for ARP requests again 
....................          smARP = SM_ARP_IDLE; 
4CBA:  MOVLB  1
4CBC:  BCF    x0B.3
....................            break; 
4CBE:  MOVLB  0
....................    } 
....................  
....................     return TRUE; 
4CC0:  MOVLW  01
4CC2:  MOVWF  01
4CC4:  MOVLB  3
4CC6:  MOVLB  0
4CC8:  GOTO   6EFA (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void ARPResolve(IP_ADDR* IPAddr) 
....................  
....................   Summary: 
....................    Transmits an ARP request to resolve an IP address. 
....................     
....................   Description: 
....................      This function transmits and ARP request to determine the hardware 
....................      address of a given IP address. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  The address must be specified  
....................           in network byte order (big endian). 
....................  
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................  
....................    To retrieve the ARP query result, call the ARPIsResolved() function. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... void ARPResolve(IP_ADDR* IPAddr) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
.................... #define KS_ARP_IP_MULTICAST_HACK y 
.................... #ifdef KS_ARP_IP_MULTICAST_HACK 
....................     if ((IPAddr->v[0] >= 224) &&(IPAddr->v[0] <= 239)) 
....................     { 
....................       // "Resolve" the IP to MAC address mapping for 
....................       // IP multicast address range from 224.0.0.0 to 239.255.255.255 
....................  
....................       Cache.MACAddr.v[0] = 0x01; 
....................       Cache.MACAddr.v[1] = 0x00; 
....................       Cache.MACAddr.v[2] = 0x5E; 
....................       Cache.MACAddr.v[3] = 0x7f & IPAddr->v[1]; 
....................       Cache.MACAddr.v[4] = IPAddr->v[2]; 
....................       Cache.MACAddr.v[5] = IPAddr->v[3]; 
....................  
....................       Cache.IPAddr.Val = IPAddr->Val; 
....................  
....................       return; 
....................    } 
.................... #endif 
.................... #endif 
....................  
....................    packet.Operation            = ARP_OPERATION_REQ; 
....................    packet.TargetMACAddr.v[0]   = 0xff; 
....................    packet.TargetMACAddr.v[1]   = 0xff; 
....................    packet.TargetMACAddr.v[2]   = 0xff; 
....................    packet.TargetMACAddr.v[3]   = 0xff; 
....................    packet.TargetMACAddr.v[4]   = 0xff; 
....................    packet.TargetMACAddr.v[5]   = 0xff; 
....................  
....................  
....................     // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet 
....................    packet.TargetIPAddr         = ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr; 
.................... #ifdef STACK_USE_ZEROCONF_LINK_LOCAL 
....................    packet.SenderIPAddr         = AppConfig.MyIPAddr; 
.................... #endif 
....................  
....................     ARPPut(&packet); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
....................  
....................   Summary: 
....................    Determines if an ARP request has been resolved yet. 
....................     
....................   Description: 
....................      This function checks if an ARP request has been resolved yet, and if 
....................      so, stores the resolved MAC address in the pointer provided. 
....................  
....................   Precondition: 
....................    ARP packet is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    IPAddr - The IP address to be resolved.  This must match the IP address  
....................           provided to the ARPResolve() function call. 
....................    MACAddr - A buffer to store the corresponding MAC address retrieved from  
....................           the ARP query. 
....................  
....................   Return Values: 
....................      TRUE - The IP address has been resolved and MACAddr MAC address field 
....................          indicates the response. 
....................      FALSE -   The IP address is not yet resolved.  Try calling ARPIsResolved()  
....................          again at a later time.  If you don't get a response after a  
....................          application specific timeout period, you may want to call  
....................          ARPResolve() again to transmit another ARP query (in case if the  
....................          original query or response was lost on the network).  If you never  
....................          receive an ARP response, this may indicate that the IP address  
....................          isn't in use. 
....................  
....................   Remarks: 
....................      This function is only required when the stack is a client, and therefore 
....................      is only enabled when STACK_CLIENT_MODE is enabled. 
....................   ***************************************************************************/ 
.................... #ifdef STACK_CLIENT_MODE 
.................... BOOL ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr) 
.................... { 
....................     if((Cache.IPAddr.Val == IPAddr->Val) ||  
....................      ((Cache.IPAddr.Val == AppConfig.MyGateway.Val) && ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val))) 
....................     { 
....................         *MACAddr = Cache.MACAddr; 
....................         return TRUE; 
....................     } 
....................     return FALSE; 
.................... } 
.................... #endif 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void SwapARPPacket(ARP_PACKET* p) 
....................  
....................   Description: 
....................      Swaps endian-ness of header information in an ARP packet. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    p - The ARP packet to be swapped 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void SwapARPPacket(ARP_PACKET* p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
49D0:  MOVLB  3
49D2:  MOVFF  3B9,01
49D6:  MOVFF  3BA,03
49DA:  MOVFF  3B9,3BB
49DE:  MOVFF  3BA,3BC
49E2:  MOVFF  3B9,FE9
49E6:  MOVFF  3BA,FEA
49EA:  MOVFF  FEC,3BE
49EE:  MOVF   FED,F
49F0:  MOVFF  FEF,3BD
49F4:  MOVFF  3BE,430
49F8:  MOVFF  3BD,42F
49FC:  MOVLB  0
49FE:  CALL   1C92
4A02:  MOVFF  3BC,FEA
4A06:  MOVFF  3BB,FE9
4A0A:  MOVFF  02,FEC
4A0E:  MOVF   FED,F
4A10:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
4A14:  MOVLW  02
4A16:  MOVLB  3
4A18:  ADDWF  xB9,W
4A1A:  MOVWF  01
4A1C:  MOVLW  00
4A1E:  ADDWFC xBA,W
4A20:  MOVWF  03
4A22:  MOVFF  01,3BB
4A26:  MOVWF  xBC
4A28:  MOVLW  02
4A2A:  ADDWF  xB9,W
4A2C:  MOVWF  FE9
4A2E:  MOVLW  00
4A30:  ADDWFC xBA,W
4A32:  MOVWF  FEA
4A34:  MOVFF  FEC,3BE
4A38:  MOVF   FED,F
4A3A:  MOVFF  FEF,3BD
4A3E:  MOVFF  3BE,430
4A42:  MOVFF  3BD,42F
4A46:  MOVLB  0
4A48:  CALL   1C92
4A4C:  MOVFF  3BC,FEA
4A50:  MOVFF  3BB,FE9
4A54:  MOVFF  02,FEC
4A58:  MOVF   FED,F
4A5A:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
4A5E:  MOVLW  06
4A60:  MOVLB  3
4A62:  ADDWF  xB9,W
4A64:  MOVWF  01
4A66:  MOVLW  00
4A68:  ADDWFC xBA,W
4A6A:  MOVWF  03
4A6C:  MOVFF  01,3BB
4A70:  MOVWF  xBC
4A72:  MOVLW  06
4A74:  ADDWF  xB9,W
4A76:  MOVWF  FE9
4A78:  MOVLW  00
4A7A:  ADDWFC xBA,W
4A7C:  MOVWF  FEA
4A7E:  MOVFF  FEC,3BE
4A82:  MOVF   FED,F
4A84:  MOVFF  FEF,3BD
4A88:  MOVFF  3BE,430
4A8C:  MOVFF  3BD,42F
4A90:  MOVLB  0
4A92:  CALL   1C92
4A96:  MOVFF  3BC,FEA
4A9A:  MOVFF  3BB,FE9
4A9E:  MOVFF  02,FEC
4AA2:  MOVF   FED,F
4AA4:  MOVFF  01,FEF
4AA8:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) 
....................    #include "ICMP.c" 
.................... /********************************************************************* 
....................  * 
....................  *  Internet Control Message Protocol (ICMP) Server 
....................  *  Module for Microchip TCP/IP Stack 
....................  *   -Provides "ping" diagnostics 
....................  *	 -Reference: RFC 792 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.c 
....................  * Dependencies:    IP, ARP 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    	Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		03/16/07	Original 
....................  ********************************************************************/ 
.................... #define __ICMP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... // ICMP Timeout Value 
.................... #define ICMP_TIMEOUT	(4ul*TICK_SECOND) 
....................  
.................... // ICMP Packet Structure 
.................... typedef struct 
.................... { 
.................... 	BYTE vType; 
.................... 	BYTE vCode; 
.................... 	WORD wChecksum; 
.................... 	WORD wIdentifier; 
.................... 	WORD wSequenceNumber; 
.................... 	WORD wData; 
.................... } ICMP_PACKET; 
....................  
.................... // ICMP Sequence Number 
.................... static WORD wICMPSequenceNumber; 
.................... // ICMP tick timer variable 
.................... static DWORD ICMPTimer; 
....................  
.................... // ICMP Flag structure 
.................... static struct 
.................... { 
.................... 	unsigned char bICMPInUse:1;         // Indicates that the ICMP Client is in use 
.................... 	unsigned char bReplyValid:1;        // Indicates that a correct Ping response to one of our pings was received 
.................... 	unsigned char bRemoteHostIsROM:1;   // Indicates that a remote host name was passed as a ROM pointer argument 
.................... } ICMPFlags = {0x00}; 
....................  
.................... // ICMP Static Variables 
.................... static union 
.................... { 
.................... 	union 
.................... 	{ 
.................... 		ROM BYTE *szROM; 
.................... 		BYTE *szRAM; 
.................... 	} RemoteHost; 
.................... 	NODE_INFO ICMPRemote; 
.................... } StaticVars; 
....................  
.................... // ICMP State Machine Enumeration 
.................... static enum 
.................... { 
.................... 	SM_IDLE = 0, 
.................... 	SM_DNS_SEND_QUERY, 
.................... 	SM_DNS_GET_RESPONSE, 
.................... 	SM_ARP_SEND_QUERY, 
.................... 	SM_ARP_GET_RESPONSE, 
.................... 	SM_ICMP_SEND_ECHO_REQUEST, 
.................... 	SM_ICMP_GET_ECHO_RESPONSE 
.................... } ICMPState; 
....................  
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPProcess(void) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           *remote: Pointer to a NODE_INFO structure of the  
....................  *					ping requester 
....................  *					len: Count of how many bytes the ping header and  
....................  *					payload are in this IP packet 
....................  * 
....................  * Output:          Generates an echo reply, if requested 
....................  *					Validates and sets ICMPFlags.bReplyValid if a  
....................  *					correct ping response to one of ours is received. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPProcess(NODE_INFO *remote, WORD len) 
.................... { 
.................... 	DWORD_VAL dwVal; 
....................  
....................     // Obtain the ICMP header Type, Code, and Checksum fields 
....................     MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
*
4E86:  MOVLW  03
4E88:  MOVLB  3
4E8A:  MOVWF  xA4
4E8C:  MOVLW  9F
4E8E:  MOVWF  xA3
4E90:  MOVFF  3A4,433
4E94:  MOVFF  FE8,432
4E98:  MOVLB  4
4E9A:  CLRF   x35
4E9C:  MOVLW  04
4E9E:  MOVWF  x34
4EA0:  MOVLB  0
4EA2:  CALL   0BD0
.................... 	 
.................... 	// See if this is an ICMP echo (ping) request 
.................... 	if(dwVal.w[0] == 0x0008u) 
4EA6:  MOVLB  3
4EA8:  MOVF   x9F,W
4EAA:  SUBLW  08
4EAC:  BNZ   4F6A
4EAE:  MOVF   xA0,F
4EB0:  BNZ   4F6A
.................... 	{ 
.................... 		// Validate the checksum using the Microchip MAC's DMA module 
.................... 		// The checksum data includes the precomputed checksum in the  
.................... 		// header, so a valid packet will always have a checksum of  
.................... 		// 0x0000 if the packet is not disturbed. 
.................... 		if(MACCalcRxChecksum(0+sizeof(IP_HEADER), len)) 
4EB2:  CLRF   xBA
4EB4:  MOVLW  14
4EB6:  MOVWF  xB9
4EB8:  MOVFF  39E,3BC
4EBC:  MOVFF  39D,3BB
4EC0:  MOVLB  0
4EC2:  RCALL  4CCC
4EC4:  MOVF   01,W
4EC6:  IORWF  02,W
4EC8:  BZ    4ECC
.................... 			return; 
4ECA:  BRA    4F68
.................... 	 
.................... 		// Calculate new Type, Code, and Checksum values 
.................... 		dwVal.v[0] = 0x00;	// Type: 0 (ICMP echo/ping reply) 
4ECC:  MOVLB  3
4ECE:  CLRF   x9F
.................... 		dwVal.v[2] += 8;	// Subtract 0x0800 from the checksum 
4ED0:  MOVLW  08
4ED2:  ADDWF  xA1,F
.................... 		if(dwVal.v[2] < 8u) 
4ED4:  MOVF   xA1,W
4ED6:  SUBLW  07
4ED8:  BNC   4EE2
.................... 		{ 
.................... 			dwVal.v[3]++; 
4EDA:  INCF   xA2,F
.................... 			if(dwVal.v[3] == 0u) 
4EDC:  MOVF   xA2,F
4EDE:  BNZ   4EE2
.................... 				dwVal.v[2]++; 
4EE0:  INCF   xA1,F
.................... 		} 
.................... 	 
.................... 	    // Wait for TX hardware to become available (finish transmitting  
.................... 	    // any previous packet) 
.................... 	    while(!IPIsTxReady()); 
4EE2:  MOVLB  0
4EE4:  CALL   19F2
4EE8:  MOVF   01,F
4EEA:  BZ    4EE4
....................  
.................... 		// Position the write pointer for the next IPPutHeader operation 
.................... 		// NOTE: do not put this before the IPIsTxReady() call for WF compatbility 
.................... 	    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
4EEC:  MOVLW  11
4EEE:  MOVLB  4
4EF0:  MOVWF  x20
4EF2:  MOVLW  E5
4EF4:  MOVWF  x1F
4EF6:  MOVLB  0
4EF8:  CALL   0AAE
....................         	 
.................... 		// Create IP header in TX memory 
.................... 		IPPutHeader(remote, IP_PROT_ICMP, len); 
4EFC:  MOVFF  39C,411
4F00:  MOVFF  39B,410
4F04:  MOVLW  01
4F06:  MOVLB  4
4F08:  MOVWF  x12
4F0A:  MOVFF  39E,414
4F0E:  MOVFF  39D,413
4F12:  MOVLB  0
4F14:  CALL   1F3C
.................... 	 
.................... 		// Copy ICMP response into the TX memory 
.................... 		MACPutArray((BYTE*)&dwVal, sizeof(dwVal)); 
4F18:  MOVLW  03
4F1A:  MOVLB  3
4F1C:  MOVWF  xA4
4F1E:  MOVLW  9F
4F20:  MOVWF  xA3
4F22:  MOVFF  3A4,435
4F26:  MOVFF  FE8,434
4F2A:  MOVLB  4
4F2C:  CLRF   x37
4F2E:  MOVLW  04
4F30:  MOVWF  x36
4F32:  MOVLB  0
4F34:  CALL   0B1E
.................... 		MACMemCopyAsync(-1, -1, len-4); 
4F38:  MOVLW  04
4F3A:  MOVLB  3
4F3C:  SUBWF  x9D,W
4F3E:  MOVWF  xA3
4F40:  MOVLW  00
4F42:  SUBWFB x9E,W
4F44:  MOVWF  xA4
4F46:  MOVLB  4
4F48:  SETF   x20
4F4A:  SETF   x1F
4F4C:  SETF   x22
4F4E:  SETF   x21
4F50:  MOVWF  x24
4F52:  MOVFF  3A3,423
4F56:  MOVLB  0
4F58:  CALL   0C70
.................... 		while(!MACIsMemCopyDone()); 
4F5C:  CALL   0EFE
4F60:  MOVF   01,F
4F62:  BZ    4F5C
.................... 	 
.................... 		// Transmit the echo reply packet 
.................... 	    MACFlush(); 
4F64:  CALL   2026
4F68:  MOVLB  3
.................... 	} 
.................... #if defined(STACK_USE_ICMP_CLIENT) 
4F6A:  MOVLB  0
4F6C:  GOTO   6EA4 (RETURN)
.................... 	else if(dwVal.w[0] == 0x0000u)	// See if this an ICMP Echo reply to our request 
.................... 	{ 
.................... 		// Get the sequence number and identifier fields 
.................... 		MACGetArray((BYTE*)&dwVal, sizeof(dwVal)); 
.................... 		 
.................... 		// See if the identifier matches the one we sent 
.................... 		if(dwVal.w[0] != 0xEFBE)	 
.................... 			return; 
.................... 	 
.................... 		if(dwVal.w[1] != wICMPSequenceNumber) 
.................... 			return; 
....................  
.................... 		// Validate the ICMP checksum field 
.................... 	    IPSetRxBuffer(0); 
.................... 		if(CalcIPBufferChecksum(sizeof(ICMP_PACKET)))	// Two bytes of payload were sent in the echo request 
.................... 			return; 
.................... 		 
.................... 		// Flag that we received the response and stop the timer ticking 
.................... 		ICMPFlags.bReplyValid = 1; 
.................... 		ICMPTimer = TickGet() - ICMPTimer; 
.................... 	} 
.................... #endif 
.................... } 
....................  
.................... #if defined(STACK_USE_ICMP_CLIENT) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPing(DWORD dwRemoteIP) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           dwRemoteIP: IP Address to ping.  Must be stored  
....................  *								big endian.  Ex. 192.168.0.1 should be 
....................  *								passed as 0x0100A8C0. 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPing(DWORD dwRemoteIP) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	StaticVars.ICMPRemote.IPAddr.Val = dwRemoteIP; 
.................... 	ICMPState = SM_ARP_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHost (BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in RAM if being called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHost(BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 0; 
.................... 	StaticVars.RemoteHost.szRAM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #if defined(__18CXX) 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPSendPingToHostROM (ROM BYTE * szRemoteHost) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE 
....................  * 
....................  * Input:           szRemoteHost: Host name to ping.  Must be stored  
....................  *								  in ROM. Should only be called by PIC18. 
....................  *								  Ex. www.microchip.com 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Begins the process of transmitting an ICMP echo  
....................  *					request.  This normally involves an ARP  
....................  *					resolution procedure first. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPSendPingToHostROM(ROM BYTE * szRemoteHost) 
.................... { 
.................... 	ICMPFlags.bReplyValid = 0; 
.................... 	ICMPTimer = TickGet(); 
.................... 	ICMPFlags.bRemoteHostIsROM = 1; 
.................... 	StaticVars.RemoteHost.szROM = szRemoteHost; 
.................... 	ICMPState = SM_DNS_SEND_QUERY; 
.................... } 
....................  
.................... #endif 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        LONG ICMPGetReply(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() returned TRUE and ICMPSendPing()  
....................  *					was called 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          -3: Could not resolve hostname (DNS timeout or  
....................  *			    	    hostname invalid) 
....................  *					-2: No response received yet 
....................  *					-1: Operation timed out (longer than ICMP_TIMEOUT)  
....................  *						has elapsed. 
....................  *					>=0: Number of TICKs that elapsed between  
....................  *						 initial ICMP transmission and reception of  
....................  *						 a valid echo. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... LONG ICMPGetReply(void) 
.................... { 
.................... 	ICMP_PACKET ICMPPacket; 
....................  
.................... 	switch(ICMPState) 
.................... 	{ 
.................... #if defined(STACK_USE_DNS) 
.................... 		case SM_DNS_SEND_QUERY: 
.................... 			// Obtain DNS module ownership 
.................... 			if(!DNSBeginUsage()) 
.................... 				break; 
.................... 			 
.................... 			// Send DNS query 
.................... 			if(ICMPFlags.bRemoteHostIsROM) 
.................... 				DNSResolveROM(StaticVars.RemoteHost.szROM, DNS_TYPE_A); 
.................... 			else 
.................... 				DNSResolve(StaticVars.RemoteHost.szRAM, DNS_TYPE_A); 
.................... 			 
.................... 			ICMPState = SM_DNS_GET_RESPONSE; 
.................... 			break; 
.................... 				 
.................... 		case SM_DNS_GET_RESPONSE: 
.................... 			// See if DNS is done, and if so, get the remote IP address 
.................... 			if(!DNSIsResolved(&StaticVars.ICMPRemote.IPAddr)) 
.................... 				break; 
.................... 			 
.................... 			// Free the DNS module 
.................... 			DNSEndUsage(); 
.................... 			 
.................... 			// Return error code if the DNS query failed 
.................... 			if(StaticVars.ICMPRemote.IPAddr.Val == 0x00000000ul) 
.................... 			{ 
.................... 				ICMPState = SM_IDLE; 
.................... 				return -3; 
.................... 			} 
....................  
.................... 			ICMPState = SM_ARP_SEND_QUERY;	 
.................... 			// No break;	 
.................... #endif 
....................  
.................... 		case SM_ARP_SEND_QUERY: 
.................... 			ARPResolve(&StaticVars.ICMPRemote.IPAddr); 
.................... 			ICMPState = SM_ARP_GET_RESPONSE; 
.................... 			break; 
.................... 			 
.................... 		case SM_ARP_GET_RESPONSE: 
.................... 			// See if the ARP reponse was successfully received 
.................... 			if(!ARPIsResolved(&StaticVars.ICMPRemote.IPAddr, &StaticVars.ICMPRemote.MACAddr)) 
.................... 				break; 
.................... 			 
.................... 			ICMPState = SM_ICMP_SEND_ECHO_REQUEST; 
.................... 			// No break;  
.................... 		 
.................... 		case SM_ICMP_SEND_ECHO_REQUEST: 
.................... 		    if(!IPIsTxReady()) 
.................... 		    	break; 
....................  
.................... 			// Set up the ping packet 
.................... 			ICMPPacket.vType = 0x08;	// 0x08: Echo (ping) request 
.................... 			ICMPPacket.vCode = 0x00; 
.................... 			ICMPPacket.wChecksum = 0x0000; 
.................... 			ICMPPacket.wIdentifier = 0xEFBE; 
.................... 			wICMPSequenceNumber++;  
.................... 			ICMPPacket.wSequenceNumber = wICMPSequenceNumber; 
.................... 			ICMPPacket.wData = 0x2860; 
.................... 			ICMPPacket.wChecksum = CalcIPChecksum((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 		 
.................... 			// Record the current time.  This will be used as a basis for  
.................... 			// finding the echo response time, which exludes the ARP and DNS  
.................... 			// steps 
.................... 			ICMPTimer = TickGet(); 
....................  
.................... 			// Position the write pointer for the next IPPutHeader operation 
.................... 		    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
.................... 		 
.................... 			// Create IP header in TX memory 
.................... 			IPPutHeader(&StaticVars.ICMPRemote, IP_PROT_ICMP, sizeof(ICMPPacket)); 
.................... 			MACPutArray((BYTE*)&ICMPPacket, sizeof(ICMPPacket)); 
.................... 			MACFlush(); 
....................  
.................... 			// Echo sent, advance state 
.................... 			ICMPState = SM_ICMP_GET_ECHO_RESPONSE; 
.................... 			break; 
....................  
.................... 		case SM_ICMP_GET_ECHO_RESPONSE: 
.................... 			// See if the echo was successfully received 
.................... 			if(ICMPFlags.bReplyValid) 
.................... 				return (LONG)ICMPTimer; 
.................... 		 
.................... 			break; 
.................... 		 
.................... 		// SM_IDLE or illegal/impossible state: 
.................... 		default: 
.................... 			return -1; 
.................... 	} 
....................  
.................... 	// See if the DNS/ARP/echo request timed out 
.................... 	if(TickGet() - ICMPTimer > ICMP_TIMEOUT) 
.................... 	{ 
.................... 		// Free DNS module if we have it in use 
.................... 		#if defined(STACK_USE_DNS) 
.................... 			if(ICMPState == SM_DNS_GET_RESPONSE) 
.................... 				DNSEndUsage(); 
.................... 		#endif 
.................... 		 
.................... 		// Stop ICMP echo test and return error to caller 
.................... 		ICMPState = SM_IDLE; 
.................... 		return -1; 
.................... 	} 
....................  
.................... 	// Still working.  No response to report yet. 
.................... 	return -2; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPBeginUsage(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: You have successfully gained ownership of  
....................  *						  the ICMP client module and can now use the  
....................  *						  ICMPSendPing() and ICMPGetReply() functions. 
....................  *					FALSE: Some other application is using the ICMP  
....................  *						   client module.  Calling ICMPSendPing()  
....................  *						   will corrupt the other application's ping  
....................  *						   result. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Claims ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPBeginUsage(void) 
.................... { 
.................... 	if(ICMPFlags.bICMPInUse) 
.................... 		return FALSE; 
....................  
.................... 	ICMPFlags.bICMPInUse = TRUE; 
.................... 	return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPEndUsage(void) 
....................  * 
....................  * PreCondition:    ICMPBeginUsage() was called by you and it  
....................  *					returned TRUE. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Your ownership of the ICMP module is released.   
....................  *					You can no longer use ICMPSendPing(). 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Gives up ownership of the ICMP module. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ICMPEndUsage(void) 
.................... { 
.................... 	ICMPFlags.bICMPInUse = FALSE; 
.................... } 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif //#if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP) 
....................    #include "UDP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   User Datagram Protocol (UDP) Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides unreliable, minimum latency transport of application  
....................  *    datagram (packet) oriented data 
....................  *    -Reference: RFC 768 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        UDP.c 
....................  * Dependencies:    IP, Ethernet (ENC28J60.c or ETH97J60.c) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date    Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     3/19/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/26/03  Fixed UDPGet and UDPProcess bugs 
....................  *                               as discovered and fixed by John Owen 
....................  *                               of Powerwave. 
....................  *                               1. UDPGet would return FALSE on last good byte 
....................  *                               2. UDPProcess was incorrectly calculating length. 
....................  * Nilesh Rajbharti     5/19/03  Added bFirstRead flag similar to TCP 
....................  *                               to detect very first UDPGet and 
....................  *                               reset MAC Rx pointer to begining of 
....................  *                               UDP data area.  This would ensure that 
....................  *                               if UDP socket has pending Rx data and 
....................  *                               another module resets MAC Rx pointer, 
....................  *                               next UDP socket Get would get correct 
....................  *                               data. 
....................  * Robert Sloan (RSS)    5/29/03 Improved FindMatchingSocket() 
....................  * Nilesh Rajbharti     12/2/03  Added UDPChecksum logic in UDPProcess() 
....................  * Nilesh Rajbharti     12/5/03  Modified UDPProcess() and FindMatchingSocket() 
....................  *                               to include localIP as new parameter. 
....................  *                               This corrects pseudo header checksum 
....................  *                               logic in UDPProcess(). 
....................  *                               It also corrects broadcast packet 
....................  *                               matching correct in FindMatchingSocket(). 
....................  * Howard Schlunder      1/16/06    Fixed an imporbable RX checksum bug  
....................  *                         when using a Microchip Ethernet controller) 
....................  * Howard Schlunder      6/02/06    Fixed a bug where all RXed UDP packets  
....................  *                         without a checksum (0x0000) were thrown 
....................  *                         away.  No checksum is legal in UDP. 
....................  * Howard Schlunder      8/10/06    Fixed a bug where UDP sockets would  
....................  *                         unintentionally keep the remote MAC  
....................  *                         address cached, even after calling  
....................  *                         UDPInit(), UDPClose(), or reseting  
....................  *                         the part without clearing all the  
....................  *                         PIC memory. 
....................  ********************************************************************/ 
.................... #define __UDP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_UDP) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Configuration Parameters 
....................   ***************************************************************************/ 
....................  
.................... // First port number for randomized local port number selection 
.................... #define LOCAL_UDP_PORT_START_NUMBER (4096u) 
....................  
.................... // Last port number for randomized local port number selection 
.................... #define LOCAL_UDP_PORT_END_NUMBER   (8192u) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    UDP Global Variables 
....................   ***************************************************************************/ 
....................  
.................... // Stores an array of information pertaining to each UDP socket 
.................... UDP_SOCKET_INFO      UDPSocketInfo[MAX_UDP_SOCKETS]; 
....................  
.................... // Indicates which UDP socket is currently active 
.................... UDP_SOCKET         activeUDPSocket; 
....................  
.................... WORD UDPTxCount;   // Number of bytes written to this UDP segment 
.................... WORD UDPRxCount;   // Number of bytes read from this UDP segment 
.................... static UDP_SOCKET   LastPutSocket = INVALID_UDP_SOCKET;   // Indicates the last socket to which data was written 
.................... static WORD wPutOffset;      // Offset from beginning of payload where data is to be written. 
.................... static WORD wGetOffset;      // Offset from beginning of payload from where data is to be read. 
....................  
.................... // Stores various flags for the UDP module 
.................... static struct 
.................... { 
....................    unsigned char bFirstRead : 1;      // No data has been read from this segment yet 
....................    unsigned char bWasDiscarded : 1;   // The data in this segment has been discarded 
.................... } Flags; 
....................  
.................... // Indicates which socket has currently received data for this loop 
.................... static UDP_SOCKET SocketWithRxData = INVALID_UDP_SOCKET; 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static UDP_SOCKET FindMatchingUDPSocket(UDP_HEADER *h, NODE_INFO *remoteNode, 
....................                                     IP_ADDR *localIP); 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Connection Management Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPInit(void) 
....................  
....................   Summary: 
....................    Initializes the UDP module. 
....................  
....................   Description: 
....................    Initializes the UDP module.  This function initializes all the UDP  
....................    sockets to the closed state. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void UDPInit(void) 
.................... { 
....................     UDP_SOCKET s; 
....................  
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
*
09D0:  MOVLB  3
09D2:  CLRF   x7B
09D4:  MOVF   x7B,W
09D6:  SUBLW  06
09D8:  BNC   09E8
....................     { 
....................       UDPClose(s); 
09DA:  MOVFF  37B,39D
09DE:  MOVLB  0
09E0:  RCALL  094C
09E2:  MOVLB  3
09E4:  INCF   x7B,F
09E6:  BRA    09D4
....................     } 
....................    Flags.bWasDiscarded = 1; 
09E8:  MOVLB  1
09EA:  BSF    x35.1
09EC:  MOVLB  0
09EE:  GOTO   14F0 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
.................... Function: 
....................    UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort, 
....................    UDP_PORT remotePort) 
....................  
....................  Summary: 
....................     Opens a UDP socket for a client. 
....................  
....................  Description: 
....................     Provides a unified method for opening UDP sockets. This function can open both client and  
....................     server   sockets. For client sockets, it can accept a host name string to query in DNS, an IP 
....................     address as a string, an IP address in binary form, or a previously resolved NODE_INFO  
....................     structure containing the remote IP address and associated MAC address. When a host name 
....................     or IP address only is provided, UDP module will internally perform the necessary DNSResolve 
....................     and/or ARP resolution steps before reporting that the UDP socket is connected (via a call to 
....................     UDPISOpen returning TRUE). Server sockets ignore this destination parameter and listen  
....................     only on the indicated port.   Sockets are statically allocated on boot, but can be claimed with 
....................     this function and freed using UDPClose . 
....................  
.................... Conditions: 
.................... UDPInit should be called. 
....................  
.................... Input: 
....................     remoteHost -     Pointer to remote node info (MAC and IP address) for this connection.   
....................     If this is a     server socket (receives the first packet) or the destination is the broadcast  
....................     address, then this parameter should be NULL. For client sockets only. Provide a pointer to 
....................     a null-terminated string of the remote host name (ex\:"www.microchip.com" or  
....................     "192.168.1.123"), a literal destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR data type), 
....................     or a pointer to a NODE_INFO structure with the remote IP address and remote node or gateway 
....................     MAC address specified, If a string is provided. 
....................      
....................     remoteHostType - Any one of the following flags to identify the meaning of the remoteHost parameter: 
....................        - UDP_OPEN_SERVER   = Open a server socket and ignore the remoteHost parameter.  
....................           (e.g. - SNMP agent, DHCP server, Announce) 
....................        - UDP_OPEN_IP_ADDRESS = Open a client socket and connect it to a remote IP address. 
....................           Ex: 0x7B01A8C0 for 192.168.1.123 (DWORD type). Note that the byte ordering is big endian. 
....................        - UDP_OPEN_NODE_INFO = Open a client socket and connect it to a remote IP and MAC  
....................           addresses pair stored in a NODE_INFO structure. 
....................         - UDP_OPEN_RAM_HOST = Open a client socket and connect it to a remote host who's  
....................            name is stored as a null terminated string in a RAM array. Ex:"www.microchip.com" or 
....................            "192.168.0.123" 
....................         - UDP_OPEN_ROM_HOST = Open a client socket and connect it to a remote host who's 
....................            name is stored as a null terminated string in a literal string or ROM array. Ex:  
....................            "www.microchip.com" or "192.168.0.123"  
....................  
....................     localPort - UDP port number to listen on.  If 0, stack will dynamically assign a unique port  
....................     number to use. 
....................  
....................     remotePort - For client sockets, the remote port number. 
....................  
.................... Return Values: 
....................      Success -  
....................       A UDP socket handle that can be used for subsequent UDP API calls. 
....................    Failure - 
....................       INVALID_UDP_SOCKET.  This function fails when no more UDP socket 
....................       handles are available.  Increase MAX_UDP_SOCKETS to make more sockets    available. 
.................... Remarks: 
....................    When finished using the UDP socket handle, call the UDPClose() function to free the  
....................    socket and delete the handle. 
....................  
.................... *****************************************************************************/ 
.................... UDP_SOCKET UDPOpenEx(DWORD remoteHost, BYTE remoteHostType, UDP_PORT localPort, 
....................       UDP_PORT remotePort) 
.................... { 
....................    UDP_SOCKET s; 
....................    UDP_SOCKET_INFO *p; 
....................  
....................    // Local temp port numbers. 
....................    static WORD NextPort __attribute__((persistent)); 
....................  
....................  
....................    p = UDPSocketInfo; 
*
1896:  MOVLB  3
1898:  CLRF   xA7
189A:  MOVLW  56
189C:  MOVWF  xA6
....................    for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
189E:  CLRF   xA5
18A0:  MOVF   xA5,W
18A2:  SUBLW  06
18A4:  BTFSS  FD8.0
18A6:  BRA    19EA
....................    { 
....................       if(p->localPort == INVALID_UDP_PORT) 
18A8:  MOVLW  0C
18AA:  ADDWF  xA6,W
18AC:  MOVWF  FE9
18AE:  MOVLW  00
18B0:  ADDWFC xA7,W
18B2:  MOVWF  FEA
18B4:  MOVFF  FEC,3A9
18B8:  MOVF   FED,F
18BA:  MOVFF  FEF,3A8
18BE:  MOVF   xA8,F
18C0:  BTFSS  FD8.2
18C2:  BRA    19DE
18C4:  MOVF   xA9,F
18C6:  BTFSS  FD8.2
18C8:  BRA    19DE
....................       { 
....................           p->localPort = localPort;   
18CA:  MOVLW  0C
18CC:  ADDWF  xA6,W
18CE:  MOVWF  FE9
18D0:  MOVLW  00
18D2:  ADDWFC xA7,W
18D4:  MOVWF  FEA
18D6:  MOVFF  3A2,FEC
18DA:  MOVF   FED,F
18DC:  MOVFF  3A1,FEF
....................          if(localPort == 0x0000u) 
18E0:  MOVF   xA1,F
18E2:  BNZ   192A
18E4:  MOVF   xA2,F
18E6:  BNZ   192A
....................             { 
....................             if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER) 
18E8:  MOVLB  1
18EA:  MOVF   x38,W
18EC:  SUBLW  1F
18EE:  BC    18FA
18F0:  XORLW  FF
18F2:  BNZ   1900
18F4:  MOVF   x37,W
18F6:  SUBLW  00
18F8:  BNC   1900
18FA:  MOVF   x38,W
18FC:  SUBLW  0F
18FE:  BNC   1906
....................                NextPort = LOCAL_UDP_PORT_START_NUMBER; 
1900:  MOVLW  10
1902:  MOVWF  x38
1904:  CLRF   x37
....................  
....................             p->localPort    = NextPort++; 
1906:  MOVLW  0C
1908:  MOVLB  3
190A:  ADDWF  xA6,W
190C:  MOVWF  FE9
190E:  MOVLW  00
1910:  ADDWFC xA7,W
1912:  MOVWF  FEA
1914:  MOVLB  1
1916:  MOVFF  138,03
191A:  MOVF   x37,W
191C:  INCF   x37,F
191E:  BTFSC  FD8.2
1920:  INCF   x38,F
1922:  MOVWF  FEF
1924:  MOVFF  03,FEC
1928:  MOVLB  3
....................             } 
....................          if((remoteHostType == UDP_OPEN_SERVER) || (remoteHost == 0)) 
192A:  MOVF   xA0,F
192C:  BZ    193E
192E:  MOVF   x9C,F
1930:  BNZ   1974
1932:  MOVF   x9D,F
1934:  BNZ   1974
1936:  MOVF   x9E,F
1938:  BNZ   1974
193A:  MOVF   x9F,F
193C:  BNZ   1974
....................          { 
....................               //Set remote node as 0xFF ( broadcast address) 
....................               // else Set broadcast address 
....................               memset((void*)&p->remote.remoteNode, 0xFF, sizeof(p->remote)); 
193E:  MOVFF  3A7,03
1942:  MOVFF  3A6,3A8
1946:  MOVFF  3A7,3A9
194A:  MOVFF  3A7,FEA
194E:  MOVFF  3A6,FE9
1952:  SETF   00
1954:  CLRF   02
1956:  MOVLW  0A
1958:  MOVWF  01
195A:  MOVLB  0
195C:  CALL   09F2
....................               p->smState = UDP_OPENED; 
1960:  MOVLW  0E
1962:  MOVLB  3
1964:  ADDWF  xA6,W
1966:  MOVWF  FE9
1968:  MOVLW  00
196A:  ADDWFC xA7,W
196C:  MOVWF  FEA
196E:  MOVLW  05
1970:  MOVWF  FEF
....................          } 
1972:  BRA    19BE
....................          else 
....................          { 
....................             switch(remoteHostType) 
1974:  MOVF   xA0,W
1976:  XORLW  04
1978:  MOVLB  0
197A:  BZ    197E
197C:  BRA    19BC
....................             { 
.................... #if defined (STACK_CLIENT_MODE) 
.................... #if defined (STACK_USE_DNS) 
....................                case UDP_OPEN_RAM_HOST: 
....................                case UDP_OPEN_ROM_HOST: 
....................                   //set the UDP state to UDP_GET_DNS_MODULE 
....................                   p->remote.remoteHost = remoteHost; 
....................                   p->flags.bRemoteHostIsROM = (remoteHostType == UDP_OPEN_ROM_HOST); 
....................                   p->smState = UDP_DNS_RESOLVE; 
....................                break; 
.................... #endif 
....................                case UDP_OPEN_IP_ADDRESS: 
....................                // remoteHost is a literal IP address.   This doesn't need DNS and can skip directly to the Gateway ARPing step.     
....................                //Next UDP state UDP_GATEWAY_SEND_ARP; 
....................                p->remote.remoteNode.IPAddr.Val = remoteHost; 
....................                p->retryCount = 0; 
....................                p->retryInterval = (TICK_SECOND/4)/256; 
....................                p->smState = UDP_GATEWAY_SEND_ARP; 
....................                break; 
.................... #endif                   
....................                case UDP_OPEN_NODE_INFO: 
....................                //skip DNS and ARP resolution steps if connecting to a remote node which we've already 
....................                   memcpy((void*)(BYTE*)&p->remote,(void*)(BYTE*)(PTR_BASE)remoteHost,sizeof(p->remote)); 
197E:  MOVLB  3
1980:  MOVFF  3A7,03
1984:  MOVFF  3A6,3A8
1988:  MOVFF  3A7,3A9
198C:  MOVFF  3A7,FEA
1990:  MOVFF  3A6,FE9
1994:  MOVFF  39D,FE2
1998:  MOVFF  39C,FE1
199C:  MOVLW  0A
199E:  MOVWF  01
19A0:  MOVFF  FE6,FEE
19A4:  DECFSZ 01,F
19A6:  BRA    19A0
....................                   p->smState = UDP_OPENED; 
19A8:  MOVLW  0E
19AA:  ADDWF  xA6,W
19AC:  MOVWF  FE9
19AE:  MOVLW  00
19B0:  ADDWFC xA7,W
19B2:  MOVWF  FEA
19B4:  MOVLW  05
19B6:  MOVWF  FEF
....................                // CALL UDPFlushto transmit incluind peding data. 
....................                break; 
19B8:  BRA    19BE
19BA:  MOVLB  0
....................                default: 
....................                   break; 
19BC:  MOVLB  3
....................             } 
....................          } 
....................          p->remotePort   = remotePort; 
19BE:  MOVLW  0A
19C0:  ADDWF  xA6,W
19C2:  MOVWF  FE9
19C4:  MOVLW  00
19C6:  ADDWFC xA7,W
19C8:  MOVWF  FEA
19CA:  MOVFF  3A4,FEC
19CE:  MOVF   FED,F
19D0:  MOVFF  3A3,FEF
....................  
....................          // Mark this socket as active. 
....................          // Once an active socket is set, subsequent operation can be 
....................          // done without explicitely supply socket identifier. 
....................          activeUDPSocket = s; 
19D4:  MOVFF  3A5,55
....................          return s; 
19D8:  MOVFF  3A5,01
19DC:  BRA    19EE
....................       } 
....................       p++; 
19DE:  MOVLW  17
19E0:  ADDWF  xA6,F
19E2:  BTFSC  FD8.0
19E4:  INCF   xA7,F
19E6:  INCF   xA5,F
19E8:  BRA    18A0
....................    } 
....................  
....................    return (UDP_SOCKET)INVALID_UDP_SOCKET; 
19EA:  MOVLW  FF
19EC:  MOVWF  01
19EE:  MOVLB  0
19F0:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... /****************************************************************************** 
.................... Function: 
....................    void UDPTask(void) 
....................  
....................   Summary: 
....................      Performs periodic UDP tasks. 
....................  
....................   Description: 
....................    This function performs any required periodic UDP tasks.  Each socket's state machine is  
....................    checked, and any elapsed timeout periods are handled. 
....................  
....................   Precondition: 
....................    UDP is initialized. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................  
.................... ******************************************************************************/ 
.................... void UDPTask(void) 
.................... { 
....................    UDP_SOCKET ss; 
....................     
....................    for ( ss = 0; ss < MAX_UDP_SOCKETS; ss++ ) 
*
47F0:  MOVLB  3
47F2:  CLRF   x9B
47F4:  MOVF   x9B,W
47F6:  SUBLW  06
47F8:  BNC   4874
....................    { 
....................  
....................       // need to put Extra check if UDP has opened or NOT 
....................  
....................       if((UDPSocketInfo[ss].smState == UDP_OPENED) || 
....................          (UDPSocketInfo[ss].smState == UDP_CLOSED)) 
47FA:  MOVF   x9B,W
47FC:  MULLW  17
47FE:  MOVF   FF3,W
4800:  CLRF   x9D
4802:  MOVWF  x9C
4804:  MOVLW  0E
4806:  ADDWF  x9C,W
4808:  MOVWF  01
480A:  MOVLW  00
480C:  ADDWFC x9D,W
480E:  MOVWF  03
4810:  MOVF   01,W
4812:  ADDLW  56
4814:  MOVWF  FE9
4816:  MOVLW  00
4818:  ADDWFC 03,W
481A:  MOVWF  FEA
481C:  MOVF   FEF,W
481E:  SUBLW  05
4820:  BZ    484A
4822:  MOVF   x9B,W
4824:  MULLW  17
4826:  MOVF   FF3,W
4828:  CLRF   x9D
482A:  MOVWF  x9C
482C:  MOVLW  0E
482E:  ADDWF  x9C,W
4830:  MOVWF  01
4832:  MOVLW  00
4834:  ADDWFC x9D,W
4836:  MOVWF  03
4838:  MOVF   01,W
483A:  ADDLW  56
483C:  MOVWF  FE9
483E:  MOVLW  00
4840:  ADDWFC 03,W
4842:  MOVWF  FEA
4844:  MOVF   FEF,W
4846:  SUBLW  04
4848:  BNZ   484C
....................          continue; 
484A:  BRA    4870
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(UDPSocketInfo[ss].smState) 
484C:  MOVF   x9B,W
484E:  MULLW  17
4850:  MOVF   FF3,W
4852:  CLRF   x9D
4854:  MOVWF  x9C
4856:  MOVLW  0E
4858:  ADDWF  x9C,W
485A:  MOVWF  01
485C:  MOVLW  00
485E:  ADDWFC x9D,W
4860:  MOVWF  03
4862:  MOVF   01,W
4864:  ADDLW  56
4866:  MOVWF  FE9
4868:  MOVLW  00
486A:  ADDWFC 03,W
486C:  MOVWF  FEA
486E:  MOVF   FEF,W
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          #if defined(STACK_USE_DNS) 
....................          case UDP_DNS_RESOLVE: 
....................          if(DNSBeginUsage()) 
....................          { 
....................             // call DNS Resolve function and move to UDP next State machine 
....................             UDPSocketInfo[ss].smState = UDP_DNS_IS_RESOLVED; 
....................             if(UDPSocketInfo[ss].flags.bRemoteHostIsROM) 
....................                DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A); 
....................             else 
....................                DNSResolve((BYTE*)(PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A); 
....................          } 
....................          break;             
....................          case UDP_DNS_IS_RESOLVED: 
....................          { 
....................             IP_ADDR ipResolvedDNSIP; 
....................             // See if DNS resolution has finished.   Note that if the DNS  
....................             // fails, the &ipResolvedDNSIP will be written with 0x00000000.  
....................             // MyTCB.remote.dwRemoteHost is unioned with  
....................             // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write  
....................             // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We  
....................             // must copy it over only if the DNS is resolution step was  
....................             // successful. 
....................              
....................             if(DNSIsResolved(&ipResolvedDNSIP)) 
....................             { 
....................                if(DNSEndUsage()) 
....................                { 
....................                   UDPSocketInfo[ss].remote.remoteNode.IPAddr.Val = ipResolvedDNSIP.Val; 
....................                   UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP; 
....................                   UDPSocketInfo[ss].retryCount = 0; 
....................                   UDPSocketInfo[ss].retryInterval = (TICK_SECOND/4)/256; 
....................                } 
....................                else 
....................                { 
....................                   UDPSocketInfo[ss].smState = UDP_DNS_RESOLVE; 
....................                } 
....................             }          
....................          } 
....................          break; 
....................          #endif // #if defined(STACK_USE_DNS) 
....................  
....................          case UDP_GATEWAY_SEND_ARP: 
....................             // Obtain the MAC address associated with the server's IP address  
....................             //(either direct MAC address on same subnet, or the MAC address of the Gateway machine) 
....................             UDPSocketInfo[ss].eventTime = (WORD)TickGetDiv256(); 
....................             ARPResolve(&UDPSocketInfo[ss].remote.remoteNode.IPAddr); 
....................             UDPSocketInfo[ss].smState = UDP_GATEWAY_GET_ARP; 
....................             break; 
....................  
....................          case UDP_GATEWAY_GET_ARP: 
....................          if(!ARPIsResolved(&UDPSocketInfo[ss].remote.remoteNode.IPAddr,  
....................                         &UDPSocketInfo[ss].remote.remoteNode.MACAddr)) 
....................          { 
....................             // Time out if too much time is spent in this state 
....................             // Note that this will continuously send out ARP  
....................             // requests for an infinite time if the Gateway  
....................             // never responds 
....................             if((WORD)TickGetDiv256() - UDPSocketInfo[ss].eventTime> (WORD)UDPSocketInfo[ss].retryInterval) 
....................             { 
....................                // Exponentially increase timeout until we reach 6 attempts then stay constant 
....................                if(UDPSocketInfo[ss].retryCount < 6u) 
....................                { 
....................                   UDPSocketInfo[ss].retryCount++; 
....................                   UDPSocketInfo[ss].retryInterval <<= 1; 
....................                } 
....................                // Retransmit ARP request 
....................                UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP; 
....................             }             
....................          } 
....................          else 
....................          { 
....................             UDPSocketInfo[ss].smState = UDP_OPENED; 
....................          } 
....................          break; 
....................          default: 
....................          case UDP_OPENED: 
....................          case UDP_CLOSED: 
....................          // not used 
....................          break; 
.................... #endif // #if defined(STACK_CLIENT_MODE) 
....................       } 
4870:  INCF   x9B,F
4872:  BRA    47F4
....................    } 
4874:  MOVLB  0
4876:  GOTO   6D9C (RETURN)
.................... }  
....................  
.................... /****************************************************************************** 
....................   
....................   Function: 
....................      BOOL UDPISOpened(UDP_SOCKET socket) 
....................    
....................  Summary: 
....................      Determines if a socket has an established connection. 
....................  
....................  Description: 
....................    This function determines if a socket has an established connection to a remote node .   
....................    Call this function after calling UDPOpen to determine when the connection is set up  
....................    and ready for use.   
....................  
....................  Precondition: 
....................    UDP is initialized. 
....................  
....................  Parameters: 
....................    socket - The socket to check. 
....................  
....................  Return Values: 
....................    TRUE - The socket has been opened and ARP has been resolved. 
....................    FALSE - The socket is not currently connected. 
....................  
....................  Remarks: 
....................    None 
....................   
....................  *****************************************************************************/ 
.................... BOOL UDPIsOpened(UDP_SOCKET socket) 
.................... { 
....................    return (UDPSocketInfo[socket].smState == UDP_OPENED); 
.................... } 
....................  
....................  
.................... #if 0 
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPTask(void) 
....................  
....................   Summary: 
....................    Performs state management and housekeeping for UDP. 
....................     
....................   Description: 
....................    Performs state management and housekeeping for UDP.  This is an internal 
....................    function meant to be called by StackTask() (not a user API). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Return Values: 
....................      None 
....................       
....................   Remarks: 
....................    UDPTask() is called once per StackTask() iteration to ensure that calls  
....................    to UDPIsPutReady() always update the Ethernet Write pointer location  
....................    between StackTask() iterations. 
....................   ***************************************************************************/ 
.................... void UDPTask(void) 
.................... { 
....................    LastPutSocket = INVALID_UDP_SOCKET; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO* remoteNode,  
....................                   UDP_PORT remotePort) 
....................  
....................   Summary: 
....................    Creates a UDP socket handle for transmiting or receiving UDP packets. 
....................     
....................   Description: 
....................    Creates a UDP socket handle for transmiting or receiving UDP packets.   
....................    Call this function to obtain a handle required by other UDP function. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    localPort - UDP port number to listen on.  If 0, stack will dynamically  
....................       assign a unique port number to use. 
....................    remoteNode - Pointer to remote node info (MAC and IP address) for this 
....................       connection.  If this is a server socket (receives the first packet)  
....................       or the destination is the broadcast address, then this parameter 
....................       should be NULL. 
....................    remotePort - For client sockets, the remote port number. 
....................  
....................   Return Values: 
....................      Success - 
....................       A UDP socket handle that can be used for subsequent UDP API calls. 
....................    Failure - 
....................       INVALID_UDP_SOCKET.  This function fails when no more UDP socket  
....................       handles are available.  Increase MAX_UDP_SOCKETS to make more sockets  
....................       available. 
....................       
....................   Remarks: 
....................    When finished using the UDP socket handle, call the UDPClose() function  
....................    to free the socket and delete the handle. 
....................   ***************************************************************************/ 
.................... UDP_SOCKET UDPOpen(UDP_PORT localPort, 
....................                    NODE_INFO *remoteNode, 
....................                    UDP_PORT remotePort) 
.................... { 
....................     UDP_SOCKET s; 
....................     UDP_SOCKET_INFO *p; 
....................  
....................    // Local temp port numbers. 
....................    static WORD NextPort __attribute__((persistent)); 
....................  
....................  
....................     p = UDPSocketInfo; 
....................     for ( s = 0; s < MAX_UDP_SOCKETS; s++ ) 
....................     { 
....................         if(p->localPort == INVALID_UDP_PORT) 
....................         { 
....................          p->localPort = localPort;    
....................  
....................          if(localPort == 0x0000u) 
....................          { 
....................             if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER) 
....................                NextPort = LOCAL_UDP_PORT_START_NUMBER; 
....................     
....................                p->localPort    = NextPort++; 
....................          } 
....................  
....................             // If remoteNode is supplied, remember it. 
....................             if(remoteNode) 
....................             { 
....................                 memcpy((void*)&p->remoteNode, 
....................                         (const void*)remoteNode, 
....................                         sizeof(p->remoteNode)); 
....................             } 
....................             else 
....................          { 
....................             // else Set broadcast address 
....................             memset((void*)&p->remoteNode, 0xFF, sizeof(p->remoteNode)); 
....................          } 
....................  
....................             p->remotePort   = remotePort; 
....................  
....................             // Mark this socket as active. 
....................             // Once an active socket is set, subsequent operation can be 
....................             // done without explicitely supply socket identifier. 
....................             activeUDPSocket = s; 
....................             return s; 
....................         } 
....................         p++; 
....................     } 
....................  
....................     return (UDP_SOCKET)INVALID_UDP_SOCKET; 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPClose(UDP_SOCKET s) 
....................  
....................   Summary: 
....................    Closes a UDP socket and frees the handle. 
....................     
....................   Description: 
....................    Closes a UDP socket and frees the handle.  Call this function to release 
....................    a socket and return it to the pool for use by future communications. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    s - The socket handle to be released.  If an illegal handle value is  
....................       provided, the function safely does nothing. 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function does not affect the previously designated active socket. 
....................   ***************************************************************************/ 
.................... void UDPClose(UDP_SOCKET s) 
.................... { 
....................    if(s >= MAX_UDP_SOCKETS) 
*
094C:  MOVLB  3
094E:  MOVF   x9D,W
0950:  SUBLW  06
0952:  BC    0956
....................       return; 
0954:  BRA    09CC
....................  
....................    UDPSocketInfo[s].localPort = INVALID_UDP_PORT; 
0956:  MOVF   x9D,W
0958:  MULLW  17
095A:  MOVF   FF3,W
095C:  CLRF   x9F
095E:  MOVWF  x9E
0960:  MOVLW  0C
0962:  ADDWF  x9E,W
0964:  MOVWF  01
0966:  MOVLW  00
0968:  ADDWFC x9F,W
096A:  MOVWF  03
096C:  MOVF   01,W
096E:  ADDLW  56
0970:  MOVWF  FE9
0972:  MOVLW  00
0974:  ADDWFC 03,W
0976:  MOVWF  FEA
0978:  CLRF   FEC
097A:  MOVF   FED,F
097C:  CLRF   FEF
....................    UDPSocketInfo[s].remote.remoteNode.IPAddr.Val = 0x00000000; 
097E:  MOVF   x9D,W
0980:  MULLW  17
0982:  MOVF   FF3,W
0984:  CLRF   x9F
0986:  MOVWF  x9E
0988:  MOVLW  56
098A:  ADDWF  x9E,W
098C:  MOVWF  FE9
098E:  MOVLW  00
0990:  ADDWFC x9F,W
0992:  MOVWF  FEA
0994:  MOVF   FEE,F
0996:  MOVF   FEE,F
0998:  CLRF   FEC
099A:  MOVF   FED,F
099C:  CLRF   FEF
099E:  MOVF   FED,F
09A0:  CLRF   FEF
09A2:  MOVF   FED,F
09A4:  CLRF   FEF
....................    UDPSocketInfo[s].smState = UDP_CLOSED; 
09A6:  MOVF   x9D,W
09A8:  MULLW  17
09AA:  MOVF   FF3,W
09AC:  CLRF   x9F
09AE:  MOVWF  x9E
09B0:  MOVLW  0E
09B2:  ADDWF  x9E,W
09B4:  MOVWF  01
09B6:  MOVLW  00
09B8:  ADDWFC x9F,W
09BA:  MOVWF  03
09BC:  MOVF   01,W
09BE:  ADDLW  56
09C0:  MOVWF  FE9
09C2:  MOVLW  00
09C4:  ADDWFC 03,W
09C6:  MOVWF  FEA
09C8:  MOVLW  04
09CA:  MOVWF  FEF
09CC:  MOVLB  0
09CE:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPSetTxBuffer(WORD wOffset) 
....................  
....................   Summary: 
....................    Moves the pointer within the TX buffer. 
....................     
....................   Description: 
....................    This function allows the write location within the TX buffer to be  
....................    specified.  Future calls to UDPPut, UDPPutArray, UDPPutString, etc will 
....................    write data from the indicated location. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called and a socket is currently  
....................    active. 
....................  
....................   Parameters: 
....................    wOffset - Offset from beginning of UDP packet data payload to place the 
....................       write pointer. 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UDPSetTxBuffer(WORD wOffset) 
.................... { 
....................    IPSetTxBuffer(wOffset+sizeof(UDP_HEADER)); 
*
1A1A:  MOVLW  08
1A1C:  MOVLB  3
1A1E:  ADDWF  x9D,W
1A20:  MOVWF  x9F
1A22:  MOVLW  00
1A24:  ADDWFC x9E,W
1A26:  MOVWF  xA0
1A28:  MOVLW  D7
1A2A:  ADDWF  x9F,F
1A2C:  MOVLW  11
1A2E:  ADDWFC xA0,F
1A30:  MOVLW  0E
1A32:  ADDWF  x9F,F
1A34:  MOVLW  00
1A36:  ADDWFC xA0,F
1A38:  MOVLW  14
1A3A:  ADDWF  x9F,F
1A3C:  MOVLW  00
1A3E:  ADDWFC xA0,F
1A40:  MOVFF  3A0,420
1A44:  MOVFF  39F,41F
1A48:  MOVLB  0
1A4A:  CALL   0AAE
....................    wPutOffset = wOffset; 
1A4E:  MOVFF  39E,132
1A52:  MOVFF  39D,131
1A56:  GOTO   1A86 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPSetRxBuffer(WORD wOffset) 
....................  
....................   Summary: 
....................    Moves the pointer within the RX buffer. 
....................     
....................   Description: 
....................    This function allows the read location within the RX buffer to be  
....................    specified.  Future calls to UDPGet and UDPGetArray will read data from 
....................    the indicated location forward. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called and a socket is currently  
....................    active. 
....................  
....................   Parameters: 
....................    wOffset - Offset from beginning of UDP packet data payload to place the 
....................       read pointer. 
....................  
....................   Returns: 
....................      None 
....................   ***************************************************************************/ 
.................... void UDPSetRxBuffer(WORD wOffset) 
.................... { 
....................    IPSetRxBuffer(wOffset+sizeof(UDP_HEADER)); 
*
272E:  MOVLW  08
2730:  MOVLB  3
2732:  ADDWF  xA9,W
2734:  MOVWF  xAB
2736:  MOVLW  00
2738:  ADDWFC xAA,W
273A:  MOVWF  xAC
273C:  MOVWF  xEB
273E:  MOVFF  3AB,3EA
2742:  MOVLB  0
2744:  RCALL  2712
....................    wGetOffset = wOffset; 
2746:  MOVFF  3AA,134
274A:  MOVFF  3A9,133
274E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Transmit Functions 
....................   ***************************************************************************/ 
....................    
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPIsPutReady(UDP_SOCKET s) 
....................  
....................   Summary: 
....................    Determines how many bytes can be written to the UDP socket. 
....................     
....................   Description: 
....................    This function determines if bytes can be written to the specified UDP 
....................    socket.  It also prepares the UDP module for writing by setting the  
....................    indicated socket as the currently active connection. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    s - The socket to be made active 
....................  
....................   Returns: 
....................      The number of bytes that can be written to this socket. 
....................   ***************************************************************************/ 
.................... WORD UDPIsPutReady(UDP_SOCKET s) 
.................... { 
....................    if(!MACIsTxReady()) 
*
1A5A:  RCALL  19F2
1A5C:  MOVF   01,F
1A5E:  BNZ   1A68
....................       return 0; 
1A60:  MOVLW  00
1A62:  MOVWF  01
1A64:  MOVWF  02
1A66:  BRA    1AA2
....................  
....................    if(LastPutSocket != s) 
1A68:  MOVLB  3
1A6A:  MOVF   x9C,W
1A6C:  MOVLB  1
1A6E:  SUBWF  x30,W
1A70:  BZ    1A88
....................    { 
....................       LastPutSocket = s; 
1A72:  MOVFF  39C,130
....................       UDPTxCount = 0; 
1A76:  MOVLB  0
1A78:  CLRF   xF8
1A7A:  CLRF   xF7
....................       UDPSetTxBuffer(0); 
1A7C:  MOVLB  3
1A7E:  CLRF   x9E
1A80:  CLRF   x9D
1A82:  MOVLB  0
1A84:  BRA    1A1A
1A86:  MOVLB  1
....................    } 
....................  
....................    activeUDPSocket = s; 
1A88:  MOVFF  39C,55
....................  
....................    return MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER) - UDPTxCount; 
1A8C:  MOVLW  C0
1A8E:  BSF    FD8.0
1A90:  MOVLB  0
1A92:  SUBFWB xF7,W
1A94:  MOVWF  00
1A96:  MOVLW  05
1A98:  SUBFWB xF8,W
1A9A:  MOVWF  03
1A9C:  MOVFF  00,01
1AA0:  MOVWF  02
1AA2:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL UDPPut(BYTE v) 
....................  
....................   Summary: 
....................    Writes a byte to the currently active socket. 
....................     
....................   Description: 
....................    This function writes a single byte to the currently active UDP socket,  
....................    while incrementing the buffer length.  UDPIsPutReady should be used  
....................    before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    v - The byte to be loaded into the transmit buffer. 
....................  
....................   Return Values: 
....................      TRUE - The byte was successfully written to the socket. 
....................      FALSE - The transmit buffer is already full and so the write failed. 
....................   ***************************************************************************/ 
.................... BOOL UDPPut(BYTE v) 
.................... { 
....................    // See if we are out of transmit space. 
....................    if(wPutOffset >= (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER))) 
*
1BBA:  MOVLB  1
1BBC:  MOVF   x32,W
1BBE:  SUBLW  04
1BC0:  BC    1BD2
1BC2:  XORLW  FF
1BC4:  BNZ   1BCC
1BC6:  MOVF   x31,W
1BC8:  SUBLW  BF
1BCA:  BC    1BD2
....................    { 
....................       return FALSE; 
1BCC:  MOVLW  00
1BCE:  MOVWF  01
1BD0:  BRA    1C0C
....................    } 
....................  
....................     // Load application data byte 
....................     MACPut(v); 
1BD2:  MOVFF  3A5,433
1BD6:  MOVLB  0
1BD8:  CALL   05CE
....................    wPutOffset++; 
1BDC:  MOVLB  1
1BDE:  INCF   x31,F
1BE0:  BTFSC  FD8.2
1BE2:  INCF   x32,F
....................    if(wPutOffset > UDPTxCount) 
1BE4:  MOVLB  0
1BE6:  MOVF   xF8,W
1BE8:  MOVLB  1
1BEA:  SUBWF  x32,W
1BEC:  BNC   1C08
1BEE:  BNZ   1C00
1BF0:  MOVF   x31,W
1BF2:  MOVLB  0
1BF4:  SUBWF  xF7,W
1BF6:  BTFSS  FD8.0
1BF8:  BRA    1BFE
1BFA:  MOVLB  1
1BFC:  BRA    1C08
1BFE:  MOVLB  1
....................       UDPTxCount = wPutOffset; 
1C00:  MOVFF  132,F8
1C04:  MOVFF  131,F7
....................  
....................     return TRUE; 
1C08:  MOVLW  01
1C0A:  MOVWF  01
1C0C:  MOVLB  0
1C0E:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPPutArray(BYTE *cData, WORD wDataLen) 
....................  
....................   Summary: 
....................    Writes an array of bytes to the currently active socket. 
....................     
....................   Description: 
....................    This function writes an array of bytes to the currently active UDP socket,  
....................    while incrementing the buffer length.  UDPIsPutReady should be used  
....................    before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - The array to write to the socket. 
....................    wDateLen - Number of bytes from cData to be written. 
....................     
....................   Returns: 
....................      The number of bytes successfully placed in the UDP transmit buffer.  If 
....................      this value is less than wDataLen, then the buffer became full and the 
....................      input was truncated. 
....................   ***************************************************************************/ 
.................... WORD UDPPutArray(BYTE *cData, WORD wDataLen) 
.................... { 
....................    WORD wTemp; 
....................  
....................    wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset; 
1C10:  MOVLW  C0
1C12:  BSF    FD8.0
1C14:  MOVLB  1
1C16:  SUBFWB x31,W
1C18:  MOVLB  3
1C1A:  MOVWF  xA9
1C1C:  MOVLW  05
1C1E:  MOVLB  1
1C20:  SUBFWB x32,W
1C22:  MOVLB  3
1C24:  MOVWF  xAA
....................    if(wTemp < wDataLen) 
1C26:  MOVF   xAA,W
1C28:  SUBWF  xA8,W
1C2A:  BNC   1C3C
1C2C:  BNZ   1C34
1C2E:  MOVF   xA7,W
1C30:  SUBWF  xA9,W
1C32:  BC    1C3C
....................       wDataLen = wTemp; 
1C34:  MOVFF  3AA,3A8
1C38:  MOVFF  3A9,3A7
....................  
....................    wPutOffset += wDataLen; 
1C3C:  MOVF   xA7,W
1C3E:  MOVLB  1
1C40:  ADDWF  x31,F
1C42:  MOVLB  3
1C44:  MOVF   xA8,W
1C46:  MOVLB  1
1C48:  ADDWFC x32,F
....................    if(wPutOffset > UDPTxCount) 
1C4A:  MOVLB  0
1C4C:  MOVF   xF8,W
1C4E:  MOVLB  1
1C50:  SUBWF  x32,W
1C52:  BNC   1C6E
1C54:  BNZ   1C66
1C56:  MOVF   x31,W
1C58:  MOVLB  0
1C5A:  SUBWF  xF7,W
1C5C:  BTFSS  FD8.0
1C5E:  BRA    1C64
1C60:  MOVLB  1
1C62:  BRA    1C6E
1C64:  MOVLB  1
....................       UDPTxCount = wPutOffset; 
1C66:  MOVFF  132,F8
1C6A:  MOVFF  131,F7
....................  
....................     // Load application data bytes 
....................     MACPutArray(cData, wDataLen); 
1C6E:  MOVFF  3A6,435
1C72:  MOVFF  3A5,434
1C76:  MOVFF  3A8,437
1C7A:  MOVFF  3A7,436
1C7E:  MOVLB  0
1C80:  CALL   0B1E
....................  
....................     return wDataLen; 
1C84:  MOVLB  3
1C86:  MOVFF  3A7,01
1C8A:  MOVFF  3A8,02
1C8E:  MOVLB  0
1C90:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen) 
....................  
....................   Summary: 
....................    Writes an array of bytes from ROM to the currently active socket. 
....................     
....................   Description: 
....................    This function writes an array of bytes from ROM to the currently active  
....................    UDP socket, while incrementing the buffer length.  UDPIsPutReady should  
....................    be used before calling this function to specify the currently active  
....................    socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - The array to write to the socket. 
....................    wDateLen - Number of bytes from cData to be written. 
....................     
....................   Returns: 
....................      The number of bytes successfully placed in the UDP transmit buffer.  If 
....................      this value is less than wDataLen, then the buffer became full and the 
....................      input was truncated. 
....................       
....................   Remarks: 
....................    This function is aliased to UDPPutArray on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD UDPPutROMArray(ROM BYTE *cData, WORD wDataLen) 
.................... { 
....................    WORD wTemp; 
....................  
....................    wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset; 
....................    if(wTemp < wDataLen) 
....................       wDataLen = wTemp; 
....................  
....................    wPutOffset += wDataLen; 
....................    if(wPutOffset > UDPTxCount) 
....................       UDPTxCount = wPutOffset; 
....................  
....................     // Load application data bytes 
....................     MACPutROMArray(cData, wDataLen); 
....................  
....................     return wDataLen; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* UDPPutString(BYTE *strData) 
....................  
....................   Summary: 
....................    Writes null-terminated string to the currently active socket. 
....................     
....................   Description: 
....................    This function writes a null-terminated string to the currently active  
....................    UDP socket, while incrementing the buffer length.  UDPIsPutReady should  
....................    be used before calling this function to specify the currently active 
....................    socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - Pointer to the string to be written to the socket. 
....................     
....................   Returns: 
....................      A pointer to the byte following the last byte written.  Note that this 
....................      is different than the UDPPutArray functions.  If this pointer does not 
....................      dereference to a NULL byte, then the buffer became full and the input 
....................      data was truncated. 
....................   ***************************************************************************/ 
.................... BYTE* UDPPutString(BYTE *strData) 
.................... { 
....................    return strData + UDPPutArray(strData, strlen((char*)strData)); 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* UDPPutString(BYTE *strData) 
....................  
....................   Summary: 
....................    Writes null-terminated string from ROM to the currently active socket. 
....................     
....................   Description: 
....................    This function writes a null-terminated string from ROM to the currently 
....................    active UDP socket, while incrementing the buffer length.  UDPIsPutReady 
....................    should be used before calling this function to specify the currently 
....................    active socket. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - Pointer to the string to be written to the socket. 
....................     
....................   Returns: 
....................      A pointer to the byte following the last byte written.  Note that this 
....................      is different than the UDPPutArray functions.  If this pointer does not 
....................      dereference to a NULL byte, then the buffer became full and the input 
....................      data was truncated. 
....................    
....................   Remarks: 
....................    This function is aliased to UDPPutString on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... ROM BYTE* UDPPutROMString(ROM BYTE *strData) 
.................... { 
....................    return strData + UDPPutROMArray(strData, strlenpgm((ROM char*)strData)); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPFlush(void) 
....................  
....................   Summary: 
....................    Transmits all pending data in a UDP socket. 
....................     
....................   Description: 
....................    This function builds a UDP packet with the pending TX data and marks it  
....................    for transmission over the network interface.  Since UDP is a frame-based 
....................    protocol, this function must be called before returning to the main 
....................    stack loop whenever any data is written. 
....................  
....................   Precondition: 
....................    UDPIsPutReady() was previously called to specify the current socket, and 
....................    data has been written to the socket using the UDPPut family of functions. 
....................  
....................   Parameters: 
....................    None 
....................     
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................    Note that unlike TCPFlush, UDPFlush must be called before returning to  
....................    the main stack loop.  There is no auto transmit for UDP segments. 
....................   ***************************************************************************/ 
.................... void UDPFlush(void) 
.................... { 
....................     UDP_HEADER      h; 
....................     UDP_SOCKET_INFO *p; 
....................     WORD         wUDPLength; 
....................  
....................     p = &UDPSocketInfo[activeUDPSocket]; 
*
225E:  MOVF   55,W
2260:  MULLW  17
2262:  MOVF   FF3,W
2264:  CLRF   03
2266:  ADDLW  56
2268:  MOVWF  01
226A:  MOVLW  00
226C:  ADDWFC 03,F
226E:  MOVFF  01,3AB
2272:  MOVLB  3
2274:  MOVFF  03,3AC
....................  
....................    wUDPLength = UDPTxCount + sizeof(UDP_HEADER); 
2278:  MOVLW  08
227A:  MOVLB  0
227C:  ADDWF  xF7,W
227E:  MOVLB  3
2280:  MOVWF  xAD
2282:  MOVLW  00
2284:  MOVLB  0
2286:  ADDWFC xF8,W
2288:  MOVLB  3
228A:  MOVWF  xAE
....................  
....................    // Generate the correct UDP header 
....................     h.SourcePort        = swaps(p->localPort); 
228C:  MOVLW  0C
228E:  ADDWF  xAB,W
2290:  MOVWF  FE9
2292:  MOVLW  00
2294:  ADDWFC xAC,W
2296:  MOVWF  FEA
2298:  MOVFF  FEC,3B0
229C:  MOVF   FED,F
229E:  MOVFF  FEF,3AF
22A2:  MOVFF  3B0,430
22A6:  MOVFF  3AF,42F
22AA:  MOVLB  0
22AC:  RCALL  1C92
22AE:  MOVFF  02,3A4
22B2:  MOVFF  01,3A3
....................     h.DestinationPort   = swaps(p->remotePort); 
22B6:  MOVLW  0A
22B8:  MOVLB  3
22BA:  ADDWF  xAB,W
22BC:  MOVWF  FE9
22BE:  MOVLW  00
22C0:  ADDWFC xAC,W
22C2:  MOVWF  FEA
22C4:  MOVFF  FEC,3B0
22C8:  MOVF   FED,F
22CA:  MOVFF  FEF,3AF
22CE:  MOVFF  3B0,430
22D2:  MOVFF  3AF,42F
22D6:  MOVLB  0
22D8:  RCALL  1C92
22DA:  MOVFF  02,3A6
22DE:  MOVFF  01,3A5
....................     h.Length            = swaps(wUDPLength); 
22E2:  MOVFF  3AE,430
22E6:  MOVFF  3AD,42F
22EA:  RCALL  1C92
22EC:  MOVFF  02,3A8
22F0:  MOVFF  01,3A7
....................    h.Checksum          = 0x0000; 
22F4:  MOVLB  3
22F6:  CLRF   xAA
22F8:  CLRF   xA9
....................      
....................    // Calculate IP pseudoheader checksum if we are going to enable  
....................    // the checksum field 
....................    #if defined(UDP_USE_TX_CHECKSUM) 
....................    { 
....................       PSEUDO_HEADER   pseudoHeader; 
....................        
....................       pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
....................       pseudoHeader.DestAddress    = p->remote.remoteNode.IPAddr; 
....................       pseudoHeader.Zero           = 0x0; 
....................       pseudoHeader.Protocol       = IP_PROT_UDP; 
....................       pseudoHeader.Length         = wUDPLength; 
....................       SwapPseudoHeader(pseudoHeader); 
....................       h.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader)); 
....................    } 
....................    #endif 
....................  
....................    // Position the hardware write pointer where we will need to  
....................    // begin writing the IP header 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
22FA:  MOVLW  11
22FC:  MOVLB  4
22FE:  MOVWF  x20
2300:  MOVLW  E5
2302:  MOVWF  x1F
2304:  MOVLB  0
2306:  CALL   0AAE
....................     
....................    // Write IP header to packet 
....................    IPPutHeader(&p->remote.remoteNode, IP_PROT_UDP, wUDPLength); 
230A:  MOVFF  3AB,01
230E:  MOVFF  3AC,03
2312:  MOVFF  3AB,3AF
2316:  MOVFF  3AC,3B0
231A:  MOVFF  3AC,411
231E:  MOVFF  3AB,410
2322:  MOVLW  11
2324:  MOVLB  4
2326:  MOVWF  x12
2328:  MOVFF  3AE,414
232C:  MOVFF  3AD,413
2330:  MOVLB  0
2332:  RCALL  1F3C
....................  
....................     // Write UDP header to packet 
....................     MACPutArray((BYTE*)&h, sizeof(h)); 
2334:  MOVLW  03
2336:  MOVLB  3
2338:  MOVWF  xB0
233A:  MOVLW  A3
233C:  MOVWF  xAF
233E:  MOVFF  3B0,435
2342:  MOVFF  FE8,434
2346:  MOVLB  4
2348:  CLRF   x37
234A:  MOVLW  08
234C:  MOVWF  x36
234E:  MOVLB  0
2350:  CALL   0B1E
....................      
....................    // Calculate the final UDP checksum and write it in, if enabled 
....................    #if defined(UDP_USE_TX_CHECKSUM) 
....................    { 
....................         PTR_BASE   wReadPtrSave; 
....................         WORD      wChecksum; 
....................  
....................       wReadPtrSave = MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)); 
....................       wChecksum = CalcIPBufferChecksum(wUDPLength); 
....................       if(wChecksum == 0x0000u) 
....................          wChecksum = 0xFFFF; 
....................       MACSetReadPtr(wReadPtrSave); 
....................       MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 6);   // 6 is the offset to the Checksum field in UDP_HEADER 
....................       MACPutArray((BYTE*)&wChecksum, sizeof(wChecksum)); 
....................    } 
....................    #endif 
....................      
....................    // Transmit the packet 
....................     MACFlush(); 
2354:  RCALL  2026
....................  
....................    // Reset packet size counter for the next TX operation 
....................     UDPTxCount = 0; 
2356:  CLRF   xF8
2358:  CLRF   xF7
....................    LastPutSocket = INVALID_UDP_SOCKET; 
235A:  MOVLB  1
235C:  SETF   x30
235E:  MOVLB  0
2360:  GOTO   2646 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Receive Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPIsGetReady(UDP_SOCKET s) 
....................  
....................   Summary: 
....................    Determines how many bytes can be read from the UDP socket. 
....................     
....................   Description: 
....................    This function determines if bytes can be read from the specified UDP 
....................    socket.  It also prepares the UDP module for reading by setting the  
....................    indicated socket as the currently active connection. 
....................  
....................   Precondition: 
....................    UDPInit() must have been previously called. 
....................  
....................   Parameters: 
....................    s - The socket to be made active (which has already been opened or is 
....................       listening) 
....................  
....................   Returns: 
....................      The number of bytes that can be read from this socket. 
....................   ***************************************************************************/ 
.................... WORD UDPIsGetReady(UDP_SOCKET s) 
.................... { 
....................     activeUDPSocket = s; 
*
2750:  MOVFF  39C,55
....................    if(SocketWithRxData != s) 
2754:  MOVLB  3
2756:  MOVF   x9C,W
2758:  MOVLB  1
275A:  SUBWF  x36,W
275C:  BZ    2766
....................       return 0; 
275E:  MOVLW  00
2760:  MOVWF  01
2762:  MOVWF  02
2764:  BRA    2792
....................  
....................     // If this is the very first time we are accessing this packet,  
....................     // move the read point to the begining of the packet. 
....................     if(Flags.bFirstRead) 
2766:  BTFSS  x35.0
2768:  BRA    2778
....................     { 
....................         Flags.bFirstRead = 0; 
276A:  BCF    x35.0
....................         UDPSetRxBuffer(0); 
276C:  MOVLB  3
276E:  CLRF   xAA
2770:  CLRF   xA9
2772:  MOVLB  0
2774:  RCALL  272E
2776:  MOVLB  1
....................     } 
....................  
....................     return UDPRxCount - wGetOffset; 
2778:  MOVF   x33,W
277A:  MOVLB  0
277C:  SUBWF  xF9,W
277E:  MOVWF  00
2780:  MOVLB  1
2782:  MOVF   x34,W
2784:  MOVLB  0
2786:  SUBWFB xFA,W
2788:  MOVWF  03
278A:  MOVFF  00,01
278E:  MOVWF  02
2790:  MOVLB  1
2792:  MOVLB  0
2794:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL UDPGet(BYTE *v) 
....................  
....................   Summary: 
....................    Reads a byte from the currently active socket. 
....................     
....................   Description: 
....................    This function reads a single byte from the currently active UDP socket,  
....................    while decrementing the remaining buffer length.  UDPIsGetReady should be  
....................    used before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsGetReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    v - The buffer to receive the data being read. 
....................  
....................   Return Values: 
....................      TRUE - A byte was successfully read 
....................      FALSE - No data remained in the read buffer 
....................   ***************************************************************************/ 
.................... BOOL UDPGet(BYTE *v) 
.................... { 
....................    // Make sure that there is data to return 
....................     if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket)) 
2796:  MOVF   xFA,W
2798:  MOVLB  1
279A:  SUBWF  x34,W
279C:  BNC   27AA
279E:  BNZ   27B0
27A0:  MOVLB  0
27A2:  MOVF   xF9,W
27A4:  MOVLB  1
27A6:  SUBWF  x33,W
27A8:  BC    27B0
27AA:  MOVF   55,W
27AC:  SUBWF  x36,W
27AE:  BZ    27B6
....................         return FALSE; 
27B0:  MOVLW  00
27B2:  MOVWF  01
27B4:  BRA    27E0
....................  
....................     *v = MACGet(); 
27B6:  MOVFF  3AC,03
27BA:  MOVFF  3AB,3AD
27BE:  MOVFF  3AC,3AE
27C2:  MOVLB  0
27C4:  CALL   0C46
27C8:  MOVFF  3AE,FEA
27CC:  MOVFF  3AD,FE9
27D0:  MOVFF  01,FEF
....................     wGetOffset++; 
27D4:  MOVLB  1
27D6:  INCF   x33,F
27D8:  BTFSC  FD8.2
27DA:  INCF   x34,F
....................  
....................     return TRUE; 
27DC:  MOVLW  01
27DE:  MOVWF  01
27E0:  MOVLB  0
27E2:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD UDPGetArray(BYTE *cData, WORD wDataLen) 
....................  
....................   Summary: 
....................    Reads an array of bytes from the currently active socket. 
....................     
....................   Description: 
....................    This function reads an array of bytes from the currently active UDP socket,  
....................    while decrementing the remaining bytes available. UDPIsGetReady should be  
....................    used before calling this function to specify the currently active socket. 
....................  
....................   Precondition: 
....................    UDPIsGetReady() was previously called to specify the current socket. 
....................  
....................   Parameters: 
....................    cData - The buffer to receive the bytes being read.  If NULL, the bytes are  
....................          simply discarded without being written anywhere (effectively skips  
....................          over the bytes in the RX buffer, although if you need to skip a lot  
....................          of data, seeking using the UDPSetRxBuffer() will be more efficient). 
....................    wDateLen - Number of bytes to be read from the socket. 
....................     
....................   Returns: 
....................      The number of bytes successfully read from the UDP buffer.  If this 
....................      value is less than wDataLen, then the buffer was emptied and no more  
....................      data is available. 
....................   ***************************************************************************/ 
.................... WORD UDPGetArray(BYTE *cData, WORD wDataLen) 
.................... { 
....................    WORD wBytesAvailable; 
....................     
....................    // Make sure that there is data to return 
....................     if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket)) 
27E4:  MOVF   xFA,W
27E6:  MOVLB  1
27E8:  SUBWF  x34,W
27EA:  BNC   27F8
27EC:  BNZ   27FE
27EE:  MOVLB  0
27F0:  MOVF   xF9,W
27F2:  MOVLB  1
27F4:  SUBWF  x33,W
27F6:  BC    27FE
27F8:  MOVF   55,W
27FA:  SUBWF  x36,W
27FC:  BZ    2806
....................       return 0; 
27FE:  MOVLW  00
2800:  MOVWF  01
2802:  MOVWF  02
2804:  BRA    286C
....................  
....................    // Make sure we don't try to read more data than exists 
....................    wBytesAvailable = UDPRxCount - wGetOffset; 
2806:  MOVF   x33,W
2808:  MOVLB  0
280A:  SUBWF  xF9,W
280C:  MOVLB  3
280E:  MOVWF  xAF
2810:  MOVLB  1
2812:  MOVF   x34,W
2814:  MOVLB  0
2816:  SUBWFB xFA,W
2818:  MOVLB  3
281A:  MOVWF  xB0
....................    if(wBytesAvailable < wDataLen) 
281C:  MOVF   xB0,W
281E:  SUBWF  xAE,W
2820:  BNC   2832
2822:  BNZ   282A
2824:  MOVF   xAD,W
2826:  SUBWF  xAF,W
2828:  BC    2832
....................       wDataLen = wBytesAvailable; 
282A:  MOVFF  3B0,3AE
282E:  MOVFF  3AF,3AD
....................  
....................    wDataLen = MACGetArray(cData, wDataLen); 
2832:  MOVFF  3AC,433
2836:  MOVFF  3AB,432
283A:  MOVFF  3AE,435
283E:  MOVFF  3AD,434
2842:  MOVLB  0
2844:  CALL   0BD0
2848:  MOVFF  02,3AE
284C:  MOVFF  01,3AD
....................     wGetOffset += wDataLen; 
2850:  MOVLB  3
2852:  MOVF   xAD,W
2854:  MOVLB  1
2856:  ADDWF  x33,F
2858:  MOVLB  3
285A:  MOVF   xAE,W
285C:  MOVLB  1
285E:  ADDWFC x34,F
....................  
....................     return wDataLen; 
2860:  MOVLB  3
2862:  MOVFF  3AD,01
2866:  MOVFF  3AE,02
286A:  MOVLB  1
286C:  MOVLB  0
286E:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void UDPDiscard(void) 
....................  
....................   Summary: 
....................    Discards any remaining RX data from a UDP socket. 
....................     
....................   Description: 
....................    This function discards any remaining received data in the currently  
....................    active UDP socket. 
....................  
....................   Precondition: 
....................    UDPIsGetReady() was previously called to select the currently active 
....................    socket. 
....................  
....................   Parameters: 
....................    None 
....................     
....................   Returns: 
....................      None 
....................  
....................   Remarks: 
....................    It is safe to call this function more than is necessary.  If no data is 
....................    available, this function does nothing. 
....................   ***************************************************************************/ 
.................... void UDPDiscard(void) 
.................... { 
....................    if(!Flags.bWasDiscarded) 
*
28DA:  MOVLB  1
28DC:  BTFSC  x35.1
28DE:  BRA    28EE
....................    { 
....................       MACDiscardRx(); 
28E0:  MOVLB  0
28E2:  RCALL  2870
....................       UDPRxCount = 0; 
28E4:  CLRF   xFA
28E6:  CLRF   xF9
....................       SocketWithRxData = INVALID_UDP_SOCKET; 
28E8:  MOVLB  1
28EA:  SETF   x36
....................       Flags.bWasDiscarded = 1; 
28EC:  BSF    x35.1
....................    } 
28EE:  MOVLB  0
28F0:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Data Processing Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len) 
....................  
....................   Summary: 
....................    Handles an incoming UDP segment. 
....................     
....................   Description: 
....................    This function handles an incoming UDP segment to determine if it is  
....................    acceptable and should be handed to one of the stack applications for 
....................    processing. 
....................  
....................   Precondition: 
....................    UDPInit() has been called an a UDP segment is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    remoteNode - The remote node that sent this segment. 
....................    localIP - The destination IP address for this segment. 
....................    len - Total length of the UDP segment. 
....................     
....................   Return Values: 
....................      TRUE - A valid packet is waiting and the stack applications should be 
....................         called to handle it. 
....................      FALSE - The packet was discarded. 
....................   ***************************************************************************/ 
.................... BOOL UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, WORD len) 
.................... { 
....................     UDP_HEADER      h; 
....................     UDP_SOCKET      s; 
....................     PSEUDO_HEADER   pseudoHeader; 
....................     DWORD_VAL      checksums; 
....................  
....................    UDPRxCount = 0; 
*
6B92:  CLRF   xFA
6B94:  CLRF   xF9
....................  
....................     // Retrieve UDP header. 
....................     MACGetArray((BYTE*)&h, sizeof(h)); 
6B96:  MOVLW  03
6B98:  MOVLB  3
6B9A:  MOVWF  xBB
6B9C:  MOVLW  A1
6B9E:  MOVWF  xBA
6BA0:  MOVFF  3BB,433
6BA4:  MOVFF  FE8,432
6BA8:  MOVLB  4
6BAA:  CLRF   x35
6BAC:  MOVLW  08
6BAE:  MOVWF  x34
6BB0:  MOVLB  0
6BB2:  CALL   0BD0
....................  
....................     h.SourcePort        = swaps(h.SourcePort); 
6BB6:  MOVFF  3A2,430
6BBA:  MOVFF  3A1,42F
6BBE:  CALL   1C92
6BC2:  MOVFF  02,3A2
6BC6:  MOVFF  01,3A1
....................     h.DestinationPort   = swaps(h.DestinationPort); 
6BCA:  MOVFF  3A4,430
6BCE:  MOVFF  3A3,42F
6BD2:  CALL   1C92
6BD6:  MOVFF  02,3A4
6BDA:  MOVFF  01,3A3
....................     h.Length            = swaps(h.Length) - sizeof(UDP_HEADER); 
6BDE:  MOVFF  3A6,430
6BE2:  MOVFF  3A5,42F
6BE6:  CALL   1C92
6BEA:  MOVLW  08
6BEC:  MOVLB  3
6BEE:  SUBWF  01,W
6BF0:  MOVWF  xA5
6BF2:  MOVLW  00
6BF4:  SUBWFB 02,W
6BF6:  MOVWF  xA6
....................  
....................    // See if we need to validate the checksum field (0x0000 is disabled) 
....................    if(h.Checksum) 
6BF8:  MOVF   xA7,W
6BFA:  IORWF  xA8,W
6BFC:  BZ    6CCA
....................    { 
....................        // Calculate IP pseudoheader checksum. 
....................        pseudoHeader.SourceAddress      = remoteNode->IPAddr; 
6BFE:  MOVFF  39B,FE9
6C02:  MOVFF  39C,FEA
6C06:  MOVFF  FEF,00
6C0A:  MOVFF  FEC,01
6C0E:  MOVFF  FEC,02
6C12:  MOVFF  FEC,03
6C16:  MOVFF  00,3AA
6C1A:  MOVFF  01,3AB
6C1E:  MOVFF  02,3AC
6C22:  MOVFF  03,3AD
....................        pseudoHeader.DestAddress.Val   = localIP->Val; 
6C26:  MOVFF  39D,FE9
6C2A:  MOVFF  39E,FEA
6C2E:  MOVFF  FEF,3AE
6C32:  MOVFF  FEC,3AF
6C36:  MOVFF  FEC,3B0
6C3A:  MOVFF  FEC,3B1
....................        pseudoHeader.Zero            = 0x0; 
6C3E:  CLRF   xB2
....................        pseudoHeader.Protocol         = IP_PROT_UDP; 
6C40:  MOVLW  11
6C42:  MOVWF  xB3
....................        pseudoHeader.Length            = len; 
6C44:  MOVFF  3A0,3B5
6C48:  MOVFF  39F,3B4
....................  
....................        SwapPseudoHeader(pseudoHeader); 
6C4C:  MOVFF  3B5,430
6C50:  MOVFF  3B4,42F
6C54:  MOVLB  0
6C56:  CALL   1C92
6C5A:  MOVFF  02,3B5
6C5E:  MOVFF  01,3B4
....................     
....................        checksums.w[0] = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................                                        sizeof(pseudoHeader)); 
6C62:  MOVLW  03
6C64:  MOVLB  3
6C66:  MOVWF  xBB
6C68:  MOVLW  AA
6C6A:  MOVWF  xBA
6C6C:  MOVFF  3BB,42C
6C70:  MOVFF  FE8,42B
6C74:  MOVLB  4
6C76:  CLRF   x2E
6C78:  MOVLW  0C
6C7A:  MOVWF  x2D
6C7C:  MOVLB  0
6C7E:  CALL   1D8E
6C82:  MOVFF  01,3B6
6C86:  MOVLB  3
6C88:  COMF   xB6,F
6C8A:  MOVFF  02,3B7
6C8E:  COMF   xB7,F
....................     
....................     
....................        // Now calculate UDP packet checksum in NIC RAM -- should match pseudoHeader 
....................        IPSetRxBuffer(0); 
6C90:  CLRF   xEB
6C92:  CLRF   xEA
6C94:  MOVLB  0
6C96:  CALL   2712
....................        checksums.w[1] = CalcIPBufferChecksum(len); 
6C9A:  MOVFF  3A0,411
6C9E:  MOVFF  39F,410
6CA2:  CALL   3728
6CA6:  MOVFF  02,3B9
6CAA:  MOVFF  01,3B8
....................     
....................        if(checksums.w[0] != checksums.w[1]) 
6CAE:  MOVLB  3
6CB0:  MOVF   xB8,W
6CB2:  SUBWF  xB6,W
6CB4:  BNZ   6CBC
6CB6:  MOVF   xB9,W
6CB8:  SUBWF  xB7,W
6CBA:  BZ    6CCA
....................        { 
....................            MACDiscardRx(); 
6CBC:  MOVLB  0
6CBE:  CALL   2870
....................            return FALSE; 
6CC2:  MOVLW  00
6CC4:  MOVWF  01
6CC6:  BRA    6D18
6CC8:  MOVLB  3
....................        } 
....................    } 
....................  
....................     s = FindMatchingUDPSocket(&h, remoteNode, localIP); 
6CCA:  MOVLW  03
6CCC:  MOVWF  xBB
6CCE:  MOVLW  A1
6CD0:  MOVWF  xBA
6CD2:  MOVFF  39C,3BD
6CD6:  MOVFF  39B,3BC
6CDA:  MOVFF  39E,3BF
6CDE:  MOVFF  39D,3BE
6CE2:  MOVLB  0
6CE4:  BRA    6A0C
6CE6:  MOVFF  01,3A9
....................     if(s == INVALID_UDP_SOCKET) 
6CEA:  MOVLB  3
6CEC:  INCFSZ xA9,W
6CEE:  BRA    6D00
....................     { 
....................         // If there is no matching socket, There is no one to handle 
....................         // this data.  Discard it. 
....................         MACDiscardRx(); 
6CF0:  MOVLB  0
6CF2:  CALL   2870
....................       return FALSE; 
6CF6:  MOVLW  00
6CF8:  MOVWF  01
6CFA:  BRA    6D18
....................     } 
6CFC:  BRA    6D14
6CFE:  MOVLB  3
....................     else 
....................     { 
....................       SocketWithRxData = s; 
6D00:  MOVFF  3A9,136
....................         UDPRxCount = h.Length; 
6D04:  MOVFF  3A6,FA
6D08:  MOVFF  3A5,F9
....................         Flags.bFirstRead = 1; 
6D0C:  MOVLB  1
6D0E:  BSF    x35.0
....................       Flags.bWasDiscarded = 0; 
6D10:  BCF    x35.1
6D12:  MOVLB  0
....................     } 
....................  
....................  
....................     return TRUE; 
6D14:  MOVLW  01
6D16:  MOVWF  01
6D18:  GOTO   6EF0 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static UDP_SOCKET FindMatchingUDPSocket(UDP_HEADER *h, NODE_INFO *remoteNode, 
....................                                            IP_ADDR *localIP) 
....................  
....................   Summary: 
....................    Matches an incoming UDP segment to a currently active socket. 
....................     
....................   Description: 
....................    This function attempts to match an incoming UDP segment to a currently 
....................    active socket for processing. 
....................  
....................   Precondition: 
....................    UDP segment header and IP header have both been retrieved. 
....................  
....................   Parameters: 
....................    h - The UDP header that was received. 
....................    remoteNode - IP and MAC of the remote node that sent this segment. 
....................    localIP - IP address that this segment was destined for. 
....................     
....................   Returns: 
....................      A UDP_SOCKET handle of a matching socket, or INVALID_UDP_SOCKET when no 
....................      match could be made. 
....................   ***************************************************************************/ 
.................... static UDP_SOCKET FindMatchingUDPSocket(UDP_HEADER *h, 
....................                                      NODE_INFO *remoteNode, 
....................                                      IP_ADDR *localIP) 
.................... { 
....................    UDP_SOCKET s; 
....................    UDP_SOCKET partialMatch; 
....................    UDP_SOCKET_INFO *p; 
....................  
.................... // This is commented out because most applications don't need this type of filtering.  It comes at a performance cost. 
.................... //   // Filter out unicast packets that aren't for our IP address, but accept  
.................... //   // all multicast and broadcast traffic 
.................... //   if(!((localIP->Val == AppConfig.MyIPAddr.Val) || (localIP->v[0] & 0x80) || (localIP->Val == (AppConfig.MyIPAddr.Val | (~AppConfig.MyMask.Val))))) 
.................... //      return INVALID_UDP_SOCKET; 
....................  
....................    // Discard any packets received that were generated by ourself.  In  
....................    // structured Wi-Fi networks, the Access Point rebroadcasts our broadcast  
....................    // and multicast packets, causing self-reception to occur unless filtered  
....................    // out. 
....................    if(remoteNode->IPAddr.Val == AppConfig.MyIPAddr.Val) 
*
6A0C:  MOVLB  3
6A0E:  MOVFF  3BC,FE9
6A12:  MOVFF  3BD,FEA
6A16:  MOVFF  FEF,3C4
6A1A:  MOVFF  FEC,3C5
6A1E:  MOVFF  FEC,3C6
6A22:  MOVFF  FEC,3C7
6A26:  MOVF   22,W
6A28:  SUBWF  xC4,W
6A2A:  BNZ   6A44
6A2C:  MOVF   23,W
6A2E:  SUBWF  xC5,W
6A30:  BNZ   6A44
6A32:  MOVF   24,W
6A34:  SUBWF  xC6,W
6A36:  BNZ   6A44
6A38:  MOVF   25,W
6A3A:  SUBWF  xC7,W
6A3C:  BNZ   6A44
....................       return INVALID_UDP_SOCKET; 
6A3E:  MOVLW  FF
6A40:  MOVWF  01
6A42:  BRA    6B8C
....................  
....................    partialMatch = INVALID_UDP_SOCKET; 
6A44:  SETF   xC1
....................  
....................    p = UDPSocketInfo; 
6A46:  CLRF   xC3
6A48:  MOVLW  56
6A4A:  MOVWF  xC2
....................     for(s = 0; s < MAX_UDP_SOCKETS; s++) 
6A4C:  CLRF   xC0
6A4E:  MOVF   xC0,W
6A50:  SUBLW  06
6A52:  BNC   6B16
....................    { 
....................       // This packet is said to be matching with current socket: 
....................       // 1. If its destination port matches with our local port and 
....................       // 2. Packet source IP address matches with previously saved socket remote IP address and 
....................       // 3. Packet source port number matches with previously saved socket remote port number 
....................       if(p->localPort == h->DestinationPort) 
6A54:  MOVLW  0C
6A56:  ADDWF  xC2,W
6A58:  MOVWF  FE9
6A5A:  MOVLW  00
6A5C:  ADDWFC xC3,W
6A5E:  MOVWF  FEA
6A60:  MOVFF  FEC,3C5
6A64:  MOVF   FED,F
6A66:  MOVFF  FEF,3C4
6A6A:  MOVLW  02
6A6C:  ADDWF  xBA,W
6A6E:  MOVWF  FE9
6A70:  MOVLW  00
6A72:  ADDWFC xBB,W
6A74:  MOVWF  FEA
6A76:  MOVFF  FEC,03
6A7A:  MOVF   FED,F
6A7C:  MOVF   FEF,W
6A7E:  SUBWF  xC4,W
6A80:  BNZ   6B0A
6A82:  MOVF   03,W
6A84:  SUBWF  xC5,W
6A86:  BNZ   6B0A
....................       { 
....................          if(p->remotePort == h->SourcePort) 
6A88:  MOVLW  0A
6A8A:  ADDWF  xC2,W
6A8C:  MOVWF  FE9
6A8E:  MOVLW  00
6A90:  ADDWFC xC3,W
6A92:  MOVWF  FEA
6A94:  MOVFF  FEC,3C5
6A98:  MOVF   FED,F
6A9A:  MOVFF  FEF,3C4
6A9E:  MOVFF  3BA,FE9
6AA2:  MOVFF  3BB,FEA
6AA6:  MOVFF  FEC,03
6AAA:  MOVF   FED,F
6AAC:  MOVF   FEF,W
6AAE:  SUBWF  xC4,W
6AB0:  BNZ   6B06
6AB2:  MOVF   03,W
6AB4:  SUBWF  xC5,W
6AB6:  BNZ   6B06
....................          { 
....................             if(p->remote.remoteNode.IPAddr.Val == remoteNode->IPAddr.Val) 
6AB8:  MOVFF  3C2,FE9
6ABC:  MOVFF  3C3,FEA
6AC0:  MOVFF  FEF,3C4
6AC4:  MOVFF  FEC,3C5
6AC8:  MOVFF  FEC,3C6
6ACC:  MOVFF  FEC,3C7
6AD0:  MOVFF  3BC,FE9
6AD4:  MOVFF  3BD,FEA
6AD8:  MOVFF  FEF,00
6ADC:  MOVFF  FEC,01
6AE0:  MOVFF  FEC,02
6AE4:  MOVFF  FEC,03
6AE8:  MOVF   00,W
6AEA:  SUBWF  xC4,W
6AEC:  BNZ   6B06
6AEE:  MOVF   01,W
6AF0:  SUBWF  xC5,W
6AF2:  BNZ   6B06
6AF4:  MOVF   02,W
6AF6:  SUBWF  xC6,W
6AF8:  BNZ   6B06
6AFA:  MOVF   03,W
6AFC:  SUBWF  xC7,W
6AFE:  BNZ   6B06
....................             { 
....................                return s; 
6B00:  MOVFF  3C0,01
6B04:  BRA    6B8C
....................             } 
....................          } 
....................  
....................          partialMatch = s; 
6B06:  MOVFF  3C0,3C1
....................       } 
....................       p++; 
6B0A:  MOVLW  17
6B0C:  ADDWF  xC2,F
6B0E:  BTFSC  FD8.0
6B10:  INCF   xC3,F
6B12:  INCF   xC0,F
6B14:  BRA    6A4E
....................    } 
....................  
....................    if(partialMatch != INVALID_UDP_SOCKET) 
6B16:  INCFSZ xC1,W
6B18:  BRA    6B1C
6B1A:  BRA    6B88
....................    { 
....................       p = &UDPSocketInfo[partialMatch]; 
6B1C:  MOVF   xC1,W
6B1E:  MULLW  17
6B20:  MOVF   FF3,W
6B22:  CLRF   03
6B24:  ADDLW  56
6B26:  MOVWF  01
6B28:  MOVLW  00
6B2A:  ADDWFC 03,F
6B2C:  MOVFF  01,3C2
6B30:  MOVFF  03,3C3
....................  
....................       memcpy((void*)&p->remote.remoteNode, 
....................             (const void*)remoteNode, sizeof(p->remote.remoteNode) ); 
6B34:  MOVFF  3C3,03
6B38:  MOVFF  3C2,3C4
6B3C:  MOVFF  3C3,3C5
6B40:  MOVFF  3C3,FEA
6B44:  MOVFF  3C2,FE9
6B48:  MOVFF  3BD,FE2
6B4C:  MOVFF  3BC,FE1
6B50:  MOVLW  0A
6B52:  MOVWF  01
6B54:  MOVFF  FE6,FEE
6B58:  DECFSZ 01,F
6B5A:  BRA    6B54
....................  
....................       p->remotePort = h->SourcePort; 
6B5C:  MOVLW  0A
6B5E:  ADDWF  xC2,W
6B60:  MOVWF  01
6B62:  MOVLW  00
6B64:  ADDWFC xC3,W
6B66:  MOVFF  3BA,FE9
6B6A:  MOVFF  3BB,FEA
6B6E:  MOVFF  FEC,03
6B72:  MOVF   FED,F
6B74:  MOVFF  FEF,3C6
6B78:  MOVWF  FEA
6B7A:  MOVFF  01,FE9
6B7E:  MOVFF  03,FEC
6B82:  MOVF   FED,F
6B84:  MOVFF  3C6,FEF
....................    } 
....................  
....................    return partialMatch; 
6B88:  MOVFF  3C1,01
6B8C:  MOVLB  0
6B8E:  GOTO   6CE6 (RETURN)
.................... } 
....................  
....................  
.................... #endif //#if defined(STACK_USE_UDP) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................    #include "DHCP.c" 
.................... /********************************************************************* 
.................... * 
.................... *	Dynamic Host Configuration Protocol (DHCP) Client 
.................... *	Module for Microchip TCP/IP Stack 
.................... *	 -Provides automatic IP address, subnet mask, gateway address,  
.................... *	  DNS server address, and other configuration parameters on DHCP  
.................... *	  enabled networks. 
.................... *	 -Reference: RFC 2131, 2132 
.................... * 
.................... ********************************************************************* 
.................... * FileName:		DHCP.c 
.................... * Dependencies:	UDP 
.................... * Processor:	PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
.................... * Compiler:		Microchip C32 v1.05 or higher 
.................... *				Microchip C30 v3.12 or higher 
.................... *				Microchip C18 v3.30 or higher 
.................... *				HI-TECH PICC-18 PRO 9.63PL2 or higher 
.................... * Company:		Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
.................... * reserved. 
.................... * 
.................... * Microchip licenses to you the right to use, modify, copy, and 
.................... * distribute: 
.................... * (i)  the Software when embedded on a Microchip microcontroller or 
.................... *      digital signal controller product ("Device") which is 
.................... *      integrated into Licensee's product; or 
.................... * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
.................... *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
.................... *		used in conjunction with a Microchip ethernet controller for 
.................... *		the sole purpose of interfacing with the ethernet controller. 
.................... * 
.................... * You should refer to the license agreement accompanying this 
.................... * Software for additional information regarding your rights and 
.................... * obligations. 
.................... * 
.................... * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
.................... * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
.................... * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
.................... * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
.................... * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
.................... * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
.................... * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
.................... * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
.................... * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
.................... * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
.................... * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
.................... * 
.................... * 
.................... * Author               Date    Comment 
.................... *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... * Nilesh Rajbharti     3/21/01  Original        (Rev 1.0) 
.................... * Nilesh Rajbharti     7/10/02  Explicitly initialized tempIPAddress 
.................... *                                               (Rev 2.11) 
.................... * Nilesh Rajbharti     5/16/03 Increased DHCP_TIMEOUT to 2 seconds. 
.................... * Nilesh Rajbharti     5/16/03 Fixed SM_DHCP_BROADCAST logic 
.................... *                              where UDPPut was called before setting 
.................... *                              active socket. 
.................... * Robert Sloan         5/29/03 Improved DHCP State machine to handle 
.................... *                              NAK and renew existing IP address. 
.................... * Nilesh Rajbharti     8/15/03 Modified _DHCPRecieve() to check for 
.................... *                              chaddr field before accpting the packet. 
.................... *                              Fixed DHCPTask() where it would not 
.................... *                              reply to first OFFER. 
.................... * Nilesh Rajbharti     3/1/04  Used tickDiff in DHCPTask() "bind" 
.................... *                              state to adjust for irregular TICK_SECOND 
.................... *                              Without this logic, actual lease time count 
.................... *                              down may be incorrect. 
.................... * Howard Schlunder		5/11/06	Fixed tickDiff usage, reducing  
.................... *								accumulated timing error.  Fixed DHCP  
.................... *								state machine requesting IP 0.0.0.0  
.................... *								after lease expiration. 
.................... * Howard Schlunder		6/01/06	Added DHCPFlags.bits.bOfferReceived flag to  
.................... *								allow operation on networks with multiple 
.................... *								DHCP servers offering multiple addresses 
.................... * Howard Schlunder		8/01/06 Added DNS server option to DHCP request,  
.................... *								untested Host Name option to DHCP request 
.................... * Howard Schlunder		1/09/06	Fixed a DHCP renewal not renewing lease time bug 
.................... * Howard Schlunder		3/16/07 Rewrote DHCP state machine 
.................... * Darren Rook/CCS       04/11/11 Changed default time from 2s to 5s. 
.................... * Darren Rook/CCS       04/11/11 Added MY_UNIT_HOSTNAME support. 
.................... * Darren Rook  (CCS)    01/06/12 Random XID (g_DNSTransactionID) 
.................... ********************************************************************/ 
.................... #define __DHCP_C 
....................  
.................... #include "TCPIPConfig.h" 
.................... #ifndef __TCPIPCONFIG_H 
.................... #define __TCPIPCONFIG_H 
....................  
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
....................  
.................... #define STACK_USE_ICMP_SERVER    1 
.................... #define STACK_USE_TCP            1 
.................... #define STACK_USE_DHCP_CLIENT    1 
....................  
.................... #define STACK_CCS_SMTP_TX_SIZE    0 
.................... #define STACK_CCS_SMTP_RX_SIZE    0 
....................  
.................... #define STACK_USE_CCS_HTTP2_SERVER 
.................... #define STACK_CCS_HTTP2_SERVER_TX_SIZE    1500 
.................... #define STACK_CCS_HTTP2_SERVER_RX_SIZE    500 
.................... #define HTTP_NUM_SOCKETS                  1 
.................... #define HTTP_PORT                         (80u) 
.................... #define HTTP_USE_DOUBLE_ESCAPE            1 
.................... #import(RAW, file="mpfs/mpfsimg.bin", location=MPFS_Start) 
....................  
.................... #define STACK_MY_TELNET_SERVER_TX_SIZE    0 
.................... #define STACK_MY_TELNET_SERVER_RX_SIZE    0 
....................  
.................... #define MY_DEFAULT_HOST_NAME      "CCS_EXAMPLES" 
....................  
.................... #define MY_DEFAULT_MAC_BYTE1      (0x0) 
.................... #define MY_DEFAULT_MAC_BYTE2      (0x20) 
.................... #define MY_DEFAULT_MAC_BYTE3      (0x30) 
.................... #define MY_DEFAULT_MAC_BYTE4      (0x40) 
.................... #define MY_DEFAULT_MAC_BYTE5      (0x50) 
.................... #define MY_DEFAULT_MAC_BYTE6      (0x60) 
....................  
.................... #define TCP_CONFIGURATION      1 
....................  
.................... #define TCP_ETH_RAM_SIZE (STACK_CCS_SMTP_TX_SIZE + \ 
....................                           STACK_CCS_SMTP_RX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_TX_SIZE + \ 
....................                           STACK_CCS_HTTP2_SERVER_RX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_TX_SIZE + \ 
....................                           STACK_MY_TELNET_SERVER_RX_SIZE + \ 
....................                           100*TCP_CONFIGURATION) 
....................  
.................... // Define names of socket types 
.................... #define TCP_PURPOSE_GENERIC_TCP_CLIENT 0 
.................... #define TCP_PURPOSE_GENERIC_TCP_SERVER 1 
.................... #define TCP_PURPOSE_TELNET             2 
.................... #define TCP_PURPOSE_FTP_COMMAND        3 
.................... #define TCP_PURPOSE_FTP_DATA           4 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_TX 5 
.................... #define TCP_PURPOSE_TCP_PERFORMANCE_RX 6 
.................... #define TCP_PURPOSE_UART_2_TCP_BRIDGE  7 
.................... #define TCP_PURPOSE_HTTP_SERVER        8 
.................... #define TCP_PURPOSE_DEFAULT            9 
.................... #define TCP_PURPOSE_BERKELEY_SERVER    10 
.................... #define TCP_PURPOSE_BERKELEY_CLIENT    11 
.................... #define TCP_PURPOSE_CCS_SMTP           0x40 
....................  
.................... typedef struct 
.................... { 
....................    BYTE vSocketPurpose; 
....................    BYTE vMemoryMedium; 
....................    WORD wTXBufferSize; 
....................    WORD wRXBufferSize; 
.................... } TCPSocketInitializer_t; 
....................  
.................... #if TCP_CONFIGURATION > 0 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................          {TCP_PURPOSE_HTTP_SERVER, TCP_ETH_RAM, STACK_CCS_HTTP2_SERVER_TX_SIZE, STACK_CCS_HTTP2_SERVER_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_SMTP_CLIENT) 
....................          {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, STACK_CCS_SMTP_TX_SIZE, STACK_CCS_SMTP_RX_SIZE}, 
....................       #endif 
....................       #if defined(STACK_USE_MY_TELNET_SERVER) 
....................          {TCP_PURPOSE_TELNET, TCP_ETH_RAM, STACK_MY_TELNET_SERVER_TX_SIZE, STACK_MY_TELNET_SERVER_RX_SIZE}, 
....................       #endif 
....................    }; 
.................... #else 
....................    #undef TCP_CONFIGURATION 
....................    #define TCP_CONFIGURATION 1 
....................    TCPSocketInitializer_t TCPSocketInitializer[TCP_CONFIGURATION] = 
....................    { 
....................       {TCP_PURPOSE_DEFAULT, TCP_ETH_RAM, 250, 250} 
....................    }; 
.................... #endif 
....................  
.................... #ifndef MAX_HTTP_CONNECTIONS 
....................    #define  MAX_HTTP_CONNECTIONS 1 
.................... #endif 
.................... #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS 7 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... // Defines how long to wait before a DHCP request times out 
.................... #define DHCP_TIMEOUT            (5ul*TICK_SECOND) //__CCS__ 
....................  
.................... unsigned int32 g_DNSTransactionID;  //__CCS__ 
....................  
.................... // Unique variables per interface 
.................... typedef struct 
.................... { 
.................... 	UDP_SOCKET			hDHCPSocket;	// Handle to DHCP client socket 
.................... 	SM_DHCP				smState;		// DHCP client state machine variable 
.................... 	union 
.................... 	{ 
.................... 	    struct 
.................... 	    { 
.................... 	        unsigned char bIsBound : 1;				// Whether or not DHCP is currently bound 
.................... 	        unsigned char bEvent : 1;				// Indicates to an external module that the DHCP client has been reset, has obtained new parameters via the DHCP client, or has refreshed a lease on existing ones 
.................... 	        unsigned char bOfferReceived : 1;		// Whether or not an offer has been received 
.................... 			unsigned char bDHCPServerDetected : 1;	// Indicates if a DCHP server has been detected 
.................... 			unsigned char bUseUnicastMode : 1;		// Indicates if the  
.................... 	    } bits; 
.................... 	    BYTE val; 
.................... 	} flags; 
.................... 	DWORD 				dwTimer;		// Tick timer value used for triggering future events after a certain wait period. 
.................... 	DWORD				dwLeaseTime;	// DHCP lease time remaining, in seconds 
.................... 	DWORD				dwServerID;		// DHCP Server ID cache 
.................... 	IP_ADDR				tempIPAddress;	// Temporary IP address to use when no DHCP lease 
.................... 	IP_ADDR				tempGateway;	// Temporary gateway to use when no DHCP lease 
.................... 	IP_ADDR				tempMask;		// Temporary mask to use when no DHCP lease 
.................... 	#if defined(STACK_USE_DNS) 
.................... 	IP_ADDR				tempDNS;		// Temporary primary DNS server 
.................... 	IP_ADDR				tempDNS2;		// Temporary secondary DNS server 
.................... 	#endif	 
.................... 	// Indicates which DHCP values are currently valid 
.................... 	union 
.................... 	{ 
.................... 		struct 
.................... 		{ 
.................... 			char IPAddress:1;	// Leased IP address is valid 
.................... 			char Gateway:1;		// Gateway address is valid 
.................... 			char Mask:1;		// Subnet mask is valid 
.................... 			char DNS:1;			// Primary DNS is valid 
.................... 			char DNS2:1;		// Secondary DNS is valid 
.................... 			char HostName:1;	// Host name is valid (not implemented) 
.................... 		} bits; 
.................... 		BYTE val; 
.................... 	} validValues; 
.................... } DHCP_CLIENT_VARS; 
....................  
.................... BOOL DHCPClientInitializedOnce = FALSE; 
....................  
.................... static BYTE _DHCPReceive(void); 
.................... static void _DHCPSend(BYTE messageType, BOOL bRenewing); 
....................  
.................... #if defined (WF_CS_IO) 
.................... extern void SignalDHCPSuccessful(void); 
.................... extern void SetDhcpProgressState(void); 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void LoadState(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Saves the DHCPClient state information structure to the appropriate  
.................... 	location and loads DHCPClient with the state information for the specified  
.................... 	interface. 
....................  
....................   Description: 
.................... 	Saves the DHCPClient state information structure to the appropriate  
.................... 	location and loads DHCPClient with the state information for the specified  
.................... 	interface. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
.................... 	None 
....................  
....................   Remarks: 
....................   	This function does nothing when you only have one physical interface. 
.................... ***************************************************************************/ 
.................... #if NETWORK_INTERFACES > 1 
....................  
.................... static DHCP_CLIENT_VARS	DHCPClients[NETWORK_INTERFACES]; 
.................... static DHCP_CLIENT_VARS	*SelectedDHCPClient; 
.................... #define DHCPClient		(*SelectedDHCPClient) 
.................... #define LoadState(v)	do(SelectedDHCPClient = &DHCPClients[v])while(0) 
....................  
.................... #else 
....................  
.................... static DHCP_CLIENT_VARS DHCPClient; 
.................... #define LoadState(v) 
....................  
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void DHCPInit(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Resets the DHCP client module for the specified interface. 
....................  
....................   Description: 
.................... 	Resets the DHCP client module, giving up any current lease, knowledge of  
.................... 	DHCP servers, etc. for the specified interface. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to initialize DHCP client state variables  
.................... 		for.   If you only have one interface, specify 0x00. 
....................  
....................   Returns: 
.................... 	None 
....................  
....................   Remarks: 
.................... 	This function may be called multiple times throughout the life of the  
.................... 	application, if desired.   
.................... ***************************************************************************/ 
.................... void DHCPInit(BYTE vInterface) 
.................... { 
.................... 	BYTE i; 
.................... 	 
.................... 	// Upon the first call after POR, we must reset all handles to invalid so  
.................... 	// that we don't inadvertently close someone else's handle. 
.................... 	if(!DHCPClientInitializedOnce) 
*
1352:  MOVLB  1
1354:  BTFSC  x0B.4
1356:  BRA    136E
.................... 	{ 
.................... 		DHCPClientInitializedOnce = TRUE; 
1358:  BSF    x0B.4
.................... 		for(i = 0; i < NETWORK_INTERFACES; i++) 
135A:  MOVLB  3
135C:  CLRF   x9C
135E:  MOVF   x9C,F
1360:  BNZ   136C
.................... 		{ 
.................... 			LoadState(i); 
.................... 			DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
1362:  MOVLB  1
1364:  SETF   x3D
1366:  MOVLB  3
1368:  INCF   x9C,F
136A:  BRA    135E
136C:  MOVLB  1
.................... 		}		 
.................... 	} 
.................... 	 
.................... 	 
.................... 	LoadState(vInterface); 
.................... 	 
.................... 	if(DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET) 
136E:  INCFSZ x3D,W
1370:  BRA    1374
1372:  BRA    1382
.................... 	{ 
.................... 		UDPClose(DHCPClient.hDHCPSocket); 
1374:  MOVFF  13D,39D
1378:  MOVLB  0
137A:  CALL   094C
.................... 		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
137E:  MOVLB  1
1380:  SETF   x3D
.................... 	} 
....................  
.................... 	// Reset state machine and flags to default values 
.................... 	DHCPClient.smState = SM_DHCP_GET_SOCKET; 
1382:  MOVLW  01
1384:  MOVWF  x3E
.................... 	DHCPClient.flags.val = 0; 
1386:  CLRF   x3F
.................... 	DHCPClient.flags.bits.bUseUnicastMode = TRUE;	// This flag toggles before use, so this statement actually means to start out using broadcast mode. 
1388:  BSF    x3F.4
.................... 	DHCPClient.flags.bits.bEvent = TRUE; 
138A:  BSF    x3F.1
138C:  MOVLB  0
138E:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void DHCPDisable(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Disables the DHCP Client for the specified interface. 
....................  
....................   Description: 
.................... 	Disables the DHCP client for the specified interface by sending the state  
.................... 	machine to "SM_DHCP_DISABLED".  If the interface was previously configured  
.................... 	by DHCP, the configuration will continue to be used but the module will no  
.................... 	longer preform any renewals. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to disable the DHCP client on.   If you only  
.................... 		have one interface, specify 0x00. 
....................  
....................   Returns: 
.................... 	None 
....................  
....................   Remarks: 
.................... 	Since the interface continues using its old configuration, it is possible  
.................... 	that the lease may expire and the DHCP server provide the IP to another 
.................... 	client.  The application should replace the current IP address and other 
.................... 	configuration with static information following a call to this function. 
.................... ***************************************************************************/ 
.................... void DHCPDisable(BYTE vInterface) 
.................... { 
.................... 	LoadState(vInterface); 
....................  
.................... 	if(DHCPClient.hDHCPSocket != INVALID_UDP_SOCKET) 
1390:  MOVLB  1
1392:  INCFSZ x3D,W
1394:  BRA    1398
1396:  BRA    13A6
.................... 	{ 
.................... 		UDPClose(DHCPClient.hDHCPSocket); 
1398:  MOVFF  13D,39D
139C:  MOVLB  0
139E:  CALL   094C
.................... 		DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
13A2:  MOVLB  1
13A4:  SETF   x3D
.................... 	} 
....................  
.................... 	DHCPClient.smState = SM_DHCP_DISABLED; 
13A6:  CLRF   x3E
13A8:  MOVLB  0
13AA:  GOTO   1506 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void DHCPEnable(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Enables the DHCP client for the specified interface. 
....................  
....................   Description: 
.................... 	Enables the DHCP client for the specified interface, if it is disabled.   
.................... 	If it is already enabled, nothing is done. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to enable the DHCP client on.   If you only  
.................... 		have one interface, specify 0x00. 
....................  
....................   Returns: 
.................... 	None 
.................... ***************************************************************************/ 
.................... void DHCPEnable(BYTE vInterface) 
.................... { 
.................... 	LoadState(vInterface); 
....................  
.................... 	if(DHCPClient.smState == SM_DHCP_DISABLED) 
*
0260:  MOVLB  1
0262:  MOVF   x3E,F
0264:  BNZ   026C
.................... 	{ 
.................... 		DHCPClient.smState = SM_DHCP_GET_SOCKET; 
0266:  MOVLW  01
0268:  MOVWF  x3E
.................... 		DHCPClient.flags.bits.bIsBound = FALSE; 
026A:  BCF    x3F.0
.................... 	} 
026C:  MOVLB  0
026E:  GOTO   027C (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	BOOL DHCPIsEnabled(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Determins if the DHCP client is enabled on the specified interface. 
....................  
....................   Description: 
.................... 	Determins if the DHCP client is enabled on the specified interface. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to query.   If you only have one interface,  
.................... 		specify 0x00. 
....................  
....................   Returns: 
.................... 	None 
.................... ***************************************************************************/ 
.................... BOOL DHCPIsEnabled(BYTE vInterface) 
.................... { 
.................... 	LoadState(vInterface); 
.................... 	return DHCPClient.smState != SM_DHCP_DISABLED; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	BOOL DHCPIsBound(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Determins if the DHCP client has an IP address lease on the specified  
.................... 	interface. 
....................  
....................   Description: 
.................... 	Determins if the DHCP client has an IP address lease on the specified  
.................... 	interface. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to query.   If you only have one interface,  
.................... 		specify 0x00. 
....................  
....................   Returns: 
.................... 	TRUE - DHCP client has obtained an IP address lease (and likely other  
.................... 		parameters) and these values are currently being used. 
.................... 	FALSE - No IP address is currently leased 
.................... ***************************************************************************/ 
.................... BOOL DHCPIsBound(BYTE vInterface) 
.................... { 
.................... 	LoadState(vInterface); 
.................... 	return DHCPClient.flags.bits.bIsBound; 
*
321C:  MOVLW  00
321E:  MOVLB  1
3220:  BTFSC  x3F.0
3222:  MOVLW  01
3224:  MOVWF  01
3226:  MOVLB  0
3228:  GOTO   6D8E (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	BOOL DHCPStateChanged(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Determins if the DHCP client on the specified interface has changed states  
.................... 	or refreshed its IP address lease. 
....................  
....................   Description: 
.................... 	Determins if the DHCP client on the specified interface has changed states  
.................... 	or refreshed its IP address lease.  This function can be used to determine 
.................... 	when to update an LCD or other display whenever the DHCP assigned IP  
.................... 	address has potentially changed. 
.................... 	 
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to query.   If you only have one interface,  
.................... 		specify 0x00. 
....................  
....................   Returns: 
.................... 	TRUE - The IP address lease have been reliquished (due to reinitilization),  
.................... 		obtained (first event), or renewed since the last call to  
.................... 		DHCPStateChanged(). 
.................... 	FALSE - The DHCP client has not detected any changes since the last call to  
.................... 		DHCPStateChanged(). 
.................... ***************************************************************************/ 
.................... BOOL DHCPStateChanged(BYTE vInterface) 
.................... { 
.................... 	LoadState(vInterface); 
.................... 	if(DHCPClient.flags.bits.bEvent) 
.................... 	{ 
.................... 		DHCPClient.flags.bits.bEvent = 0; 
.................... 		return TRUE; 
.................... 	} 
.................... 	return FALSE; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	BOOL DHCPIsServerDetected(BYTE vInterface) 
....................  
....................   Summary: 
.................... 	Determins if the DHCP client on the specified interface has seen a DHCP  
.................... 	server. 
....................  
....................   Description: 
.................... 	Determins if the DHCP client on the specified interface has seen a DHCP  
.................... 	server. 
.................... 	 
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	vInterface - Interface number to query.   If you only have one interface,  
.................... 		specify 0x00. 
....................  
....................   Returns: 
.................... 	TRUE - At least one DHCP server is attached to the specified network  
.................... 		interface. 
.................... 	FALSE - No DHCP servers are currently detected on the specified network  
.................... 		interface. 
.................... ***************************************************************************/ 
.................... BOOL DHCPIsServerDetected(BYTE vInterface) 
.................... { 
.................... 	LoadState(vInterface); 
.................... 	return DHCPClient.flags.bits.bDHCPServerDetected; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	void DHCPTask(void) 
....................  
....................   Summary: 
.................... 	Performs periodic DHCP tasks for all interfaces. 
....................  
....................   Description: 
.................... 	This function performs any periodic tasks requied by the DHCP module,  
.................... 	such as sending and receiving messages involved with obtaining and 
.................... 	maintaining a lease. 
....................  
....................   Precondition: 
.................... 	None 
....................  
....................   Parameters: 
.................... 	None 
....................  
....................   Returns: 
.................... 	None 
.................... ***************************************************************************/ 
.................... void DHCPTask(void) 
.................... { 
.................... 	BYTE i; 
.................... 	 
.................... 	for(i = 0; i < NETWORK_INTERFACES; i++) 
*
2CEE:  MOVLB  3
2CF0:  CLRF   x9B
2CF2:  MOVF   x9B,F
2CF4:  BTFSS  FD8.2
2CF6:  BRA    31D8
.................... 	{ 
.................... 		LoadState(i); 
.................... 		switch(DHCPClient.smState) 
2CF8:  MOVLB  1
2CFA:  MOVF   x3E,W
2CFC:  ADDLW  F3
2CFE:  BTFSC  FD8.0
2D00:  BRA    31D2
2D02:  ADDLW  0D
2D04:  MOVLB  0
2D06:  GOTO   31DE
.................... 		{ 
.................... 			case SM_DHCP_DISABLED: 
.................... 				// When the module is disabled, do absolutely nothing 
.................... 				break; 
2D0A:  MOVLB  1
2D0C:  BRA    31D2
.................... 			 
.................... 			case SM_DHCP_GET_SOCKET: 
.................... 				// Open a socket to send and receive broadcast messages on 
.................... 				//DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT); 
.................... 				 
.................... 				DHCPClient.hDHCPSocket = UDPOpenEx(0,UDP_OPEN_SERVER,DHCP_CLIENT_PORT, DHCP_SERVER_PORT); 
2D0E:  MOVLB  3
2D10:  CLRF   x9F
2D12:  CLRF   x9E
2D14:  CLRF   x9D
2D16:  CLRF   x9C
2D18:  CLRF   xA0
2D1A:  CLRF   xA2
2D1C:  MOVLW  44
2D1E:  MOVWF  xA1
2D20:  CLRF   xA4
2D22:  MOVLW  43
2D24:  MOVWF  xA3
2D26:  MOVLB  0
2D28:  CALL   1896
2D2C:  MOVFF  01,13D
.................... 				if(DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET) 
2D30:  MOVLB  1
2D32:  INCFSZ x3D,W
2D34:  BRA    2D38
.................... 					break; 
2D36:  BRA    31D2
.................... 	 
.................... 				DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
2D38:  MOVLW  02
2D3A:  MOVWF  x3E
2D3C:  MOVLB  0
.................... 				// No break 
.................... 	 
.................... 			case SM_DHCP_SEND_DISCOVERY: 
.................... 				// Assume default IP Lease time of 60 seconds. 
.................... 				// This should be minimum possible to make sure that if the 
.................... 				// server did not specify lease time, we try again after this  
.................... 				// minimum time. 
.................... 				DHCPClient.dwLeaseTime = 60; 
2D3E:  MOVLB  1
2D40:  CLRF   x47
2D42:  CLRF   x46
2D44:  CLRF   x45
2D46:  MOVLW  3C
2D48:  MOVWF  x44
.................... 				DHCPClient.validValues.val = 0x00; 
2D4A:  CLRF   x58
.................... 				DHCPClient.flags.bits.bIsBound = FALSE;	 
2D4C:  BCF    x3F.0
.................... 				DHCPClient.flags.bits.bOfferReceived = FALSE; 
2D4E:  BCF    x3F.2
.................... 	 
.................... 				// No point in wasting time transmitting a discovery if we are  
.................... 				// unlinked.  No one will see it.   
.................... 				if(!MACIsLinked()) 
2D50:  MOVLB  0
2D52:  CALL   187A
2D56:  MOVF   01,F
2D58:  BNZ   2D60
.................... 					break; 
2D5A:  MOVLB  1
2D5C:  BRA    31D2
2D5E:  MOVLB  0
.................... 	 
.................... 				// Ensure transmitter is ready to accept data 
.................... 				if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 300u) 
2D60:  MOVFF  13D,39C
2D64:  CALL   1A5A
2D68:  MOVFF  02,39D
2D6C:  MOVFF  01,39C
2D70:  MOVLB  3
2D72:  MOVF   02,W
2D74:  SUBLW  01
2D76:  BNC   2D86
2D78:  BNZ   2D80
2D7A:  MOVF   x9C,W
2D7C:  SUBLW  2B
2D7E:  BNC   2D86
.................... 					break; 
2D80:  MOVLB  1
2D82:  BRA    31D2
2D84:  MOVLB  3
....................  
.................... 				// Toggle the BOOTP Broadcast flag to ensure compatibility with  
.................... 				// bad DHCP servers that don't know how to handle broadcast  
.................... 				// responses.  This results in the next discovery attempt to be  
.................... 				// made using the opposite mode. 
.................... 				DHCPClient.flags.bits.bUseUnicastMode ^= 1; 
2D86:  CLRF   00
2D88:  MOVLB  1
2D8A:  BTFSC  x3F.4
2D8C:  INCF   00,F
2D8E:  MOVLW  01
2D90:  XORWF  00,F
2D92:  BCF    x3F.4
2D94:  BTFSC  00.0
2D96:  BSF    x3F.4
.................... 	 
.................... 				// Ensure that we transmit to the broadcast IP and MAC addresses 
.................... 				// The UDP Socket remembers who it was last talking to 
.................... 				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remote.remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remote.remoteNode)); 
2D98:  MOVF   x3D,W
2D9A:  MULLW  17
2D9C:  MOVF   FF3,W
2D9E:  MOVLB  3
2DA0:  CLRF   x9D
2DA2:  MOVWF  x9C
2DA4:  MOVLW  56
2DA6:  ADDWF  x9C,W
2DA8:  MOVWF  01
2DAA:  MOVLW  00
2DAC:  ADDWFC x9D,W
2DAE:  MOVWF  03
2DB0:  MOVFF  01,39E
2DB4:  MOVWF  x9F
2DB6:  MOVWF  FEA
2DB8:  MOVFF  01,FE9
2DBC:  SETF   00
2DBE:  CLRF   02
2DC0:  MOVLW  0A
2DC2:  MOVWF  01
2DC4:  MOVLB  0
2DC6:  CALL   09F2
.................... 	 
.................... 				// Send the DHCP Discover broadcast 
.................... 				_DHCPSend(DHCP_DISCOVER_MESSAGE, FALSE); 
2DCA:  MOVLW  01
2DCC:  MOVLB  3
2DCE:  MOVWF  x9C
2DD0:  CLRF   x9D
2DD2:  MOVLB  0
2DD4:  CALL   2364
.................... 	 
.................... 				// Start a timer and begin looking for a response 
.................... 				DHCPClient.dwTimer = TickGet(); 
2DD8:  RCALL  2692
2DDA:  MOVFF  03,143
2DDE:  MOVFF  02,142
2DE2:  MOVFF  01,141
2DE6:  MOVFF  00,140
.................... 				DHCPClient.smState = SM_DHCP_GET_OFFER; 
2DEA:  MOVLW  03
2DEC:  MOVLB  1
2DEE:  MOVWF  x3E
.................... 				break; 
2DF0:  BRA    31D2
.................... 	 
.................... 			case SM_DHCP_GET_OFFER: 
.................... 				// Check to see if a packet has arrived 
.................... 				if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u) 
2DF2:  MOVFF  13D,39C
2DF6:  RCALL  2750
2DF8:  MOVFF  02,39D
2DFC:  MOVFF  01,39C
2E00:  MOVLB  3
2E02:  MOVF   x9D,F
2E04:  BNZ   2E64
2E06:  MOVF   x9C,W
2E08:  SUBLW  F9
2E0A:  BNC   2E64
.................... 				{ 
.................... 					// Go back and transmit a new discovery if we didn't get an offer after 2 seconds 
.................... 					if(TickGet() - DHCPClient.dwTimer >= DHCP_TIMEOUT) 
2E0C:  MOVLB  0
2E0E:  RCALL  2692
2E10:  MOVFF  03,39F
2E14:  MOVFF  02,39E
2E18:  MOVFF  01,39D
2E1C:  MOVFF  00,39C
2E20:  MOVLB  1
2E22:  MOVF   x40,W
2E24:  MOVLB  3
2E26:  SUBWF  x9C,F
2E28:  MOVLB  1
2E2A:  MOVF   x41,W
2E2C:  MOVLB  3
2E2E:  SUBWFB x9D,F
2E30:  MOVLB  1
2E32:  MOVF   x42,W
2E34:  MOVLB  3
2E36:  SUBWFB x9E,F
2E38:  MOVLB  1
2E3A:  MOVF   x43,W
2E3C:  MOVLB  3
2E3E:  SUBWFB x9F,F
2E40:  BNZ   2E56
2E42:  MOVF   x9E,F
2E44:  BNZ   2E56
2E46:  MOVF   x9D,W
2E48:  SUBLW  97
2E4A:  BC    2E5E
2E4C:  XORLW  FF
2E4E:  BNZ   2E56
2E50:  MOVF   x9C,W
2E52:  SUBLW  98
2E54:  BC    2E5E
.................... 						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
2E56:  MOVLW  02
2E58:  MOVLB  1
2E5A:  MOVWF  x3E
2E5C:  MOVLB  3
.................... 					break; 
2E5E:  MOVLB  1
2E60:  BRA    31D2
2E62:  MOVLB  3
.................... 				} 
.................... 	 
.................... 				// Let the DHCP server module know that there is a DHCP server  
.................... 				// on this network 
.................... 				DHCPClient.flags.bits.bDHCPServerDetected = TRUE; 
2E64:  MOVLB  1
2E66:  BSF    x3F.3
.................... 	 
.................... 				// Check to see if we received an offer 
.................... 				if(_DHCPReceive() != DHCP_OFFER_MESSAGE) 
2E68:  MOVLB  0
2E6A:  RCALL  28F2
2E6C:  MOVF   01,W
2E6E:  SUBLW  02
2E70:  BZ    2E78
.................... 					break; 
2E72:  MOVLB  1
2E74:  BRA    31D2
2E76:  MOVLB  0
.................... 	 
.................... 				DHCPClient.smState = SM_DHCP_SEND_REQUEST; 
2E78:  MOVLW  04
2E7A:  MOVLB  1
2E7C:  MOVWF  x3E
2E7E:  MOVLB  0
.................... 				// No break 
.................... 	 
.................... 			case SM_DHCP_SEND_REQUEST: 
.................... 				if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u) 
2E80:  MOVFF  13D,39C
2E84:  CALL   1A5A
2E88:  MOVFF  02,39D
2E8C:  MOVFF  01,39C
2E90:  MOVLB  3
2E92:  MOVF   02,W
2E94:  SUBLW  01
2E96:  BNC   2EA6
2E98:  BNZ   2EA0
2E9A:  MOVF   x9C,W
2E9C:  SUBLW  01
2E9E:  BNC   2EA6
.................... 					break; 
2EA0:  MOVLB  1
2EA2:  BRA    31D2
2EA4:  MOVLB  3
....................  
.................... 				// Ensure that we transmit to the broadcast IP and MAC addresses 
.................... 				// The UDP Socket remembers who it was last talking to, so  
.................... 				// we must set this back to the broadcast address since the  
.................... 				// current socket values are the unicast addresses of the DHCP  
.................... 				// server. 
.................... 				memset((void*)&UDPSocketInfo[DHCPClient.hDHCPSocket].remote.remoteNode, 0xFF, sizeof(UDPSocketInfo[0].remote.remoteNode)); 
2EA6:  MOVLB  1
2EA8:  MOVF   x3D,W
2EAA:  MULLW  17
2EAC:  MOVF   FF3,W
2EAE:  MOVLB  3
2EB0:  CLRF   x9D
2EB2:  MOVWF  x9C
2EB4:  MOVLW  56
2EB6:  ADDWF  x9C,W
2EB8:  MOVWF  01
2EBA:  MOVLW  00
2EBC:  ADDWFC x9D,W
2EBE:  MOVWF  03
2EC0:  MOVFF  01,39E
2EC4:  MOVWF  x9F
2EC6:  MOVWF  FEA
2EC8:  MOVFF  01,FE9
2ECC:  SETF   00
2ECE:  CLRF   02
2ED0:  MOVLW  0A
2ED2:  MOVWF  01
2ED4:  MOVLB  0
2ED6:  CALL   09F2
.................... 	 
.................... 				// Send the DHCP request message 
.................... 				_DHCPSend(DHCP_REQUEST_MESSAGE, FALSE); 
2EDA:  MOVLW  03
2EDC:  MOVLB  3
2EDE:  MOVWF  x9C
2EE0:  CLRF   x9D
2EE2:  MOVLB  0
2EE4:  CALL   2364
.................... 	 
.................... 				// Start a timer and begin looking for a response 
.................... 				DHCPClient.dwTimer = TickGet(); 
2EE8:  CALL   2692
2EEC:  MOVFF  03,143
2EF0:  MOVFF  02,142
2EF4:  MOVFF  01,141
2EF8:  MOVFF  00,140
.................... 				DHCPClient.smState = SM_DHCP_GET_REQUEST_ACK; 
2EFC:  MOVLW  05
2EFE:  MOVLB  1
2F00:  MOVWF  x3E
.................... 				break; 
2F02:  BRA    31D2
.................... 	 
.................... 			case SM_DHCP_GET_REQUEST_ACK: 
.................... 				// Check to see if a packet has arrived 
.................... 				if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u) 
2F04:  MOVFF  13D,39C
2F08:  RCALL  2750
2F0A:  MOVFF  02,39D
2F0E:  MOVFF  01,39C
2F12:  MOVLB  3
2F14:  MOVF   x9D,F
2F16:  BNZ   2F78
2F18:  MOVF   x9C,W
2F1A:  SUBLW  F9
2F1C:  BNC   2F78
.................... 				{ 
.................... 					// Go back and transmit a new discovery if we didn't get an ACK after 2 seconds 
.................... 					if(TickGet() - DHCPClient.dwTimer >= DHCP_TIMEOUT) 
2F1E:  MOVLB  0
2F20:  CALL   2692
2F24:  MOVFF  03,39F
2F28:  MOVFF  02,39E
2F2C:  MOVFF  01,39D
2F30:  MOVFF  00,39C
2F34:  MOVLB  1
2F36:  MOVF   x40,W
2F38:  MOVLB  3
2F3A:  SUBWF  x9C,F
2F3C:  MOVLB  1
2F3E:  MOVF   x41,W
2F40:  MOVLB  3
2F42:  SUBWFB x9D,F
2F44:  MOVLB  1
2F46:  MOVF   x42,W
2F48:  MOVLB  3
2F4A:  SUBWFB x9E,F
2F4C:  MOVLB  1
2F4E:  MOVF   x43,W
2F50:  MOVLB  3
2F52:  SUBWFB x9F,F
2F54:  BNZ   2F6A
2F56:  MOVF   x9E,F
2F58:  BNZ   2F6A
2F5A:  MOVF   x9D,W
2F5C:  SUBLW  97
2F5E:  BC    2F72
2F60:  XORLW  FF
2F62:  BNZ   2F6A
2F64:  MOVF   x9C,W
2F66:  SUBLW  98
2F68:  BC    2F72
.................... 						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
2F6A:  MOVLW  02
2F6C:  MOVLB  1
2F6E:  MOVWF  x3E
2F70:  MOVLB  3
.................... 					break; 
2F72:  MOVLB  1
2F74:  BRA    31D2
2F76:  MOVLB  3
.................... 				} 
.................... 	 
.................... 				// Check to see if we received an offer 
.................... 				switch(_DHCPReceive()) 
2F78:  MOVLB  0
2F7A:  RCALL  28F2
2F7C:  MOVF   01,W
2F7E:  XORLW  05
2F80:  BZ    2F88
2F82:  XORLW  03
2F84:  BZ    2FF4
2F86:  BRA    2FFC
.................... 				{ 
.................... 					case DHCP_ACK_MESSAGE: 
.................... 						UDPClose(DHCPClient.hDHCPSocket); 
2F88:  MOVFF  13D,39D
2F8C:  CALL   094C
.................... 						DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
2F90:  MOVLB  1
2F92:  SETF   x3D
.................... 						DHCPClient.dwTimer = TickGet(); 
2F94:  MOVLB  0
2F96:  CALL   2692
2F9A:  MOVFF  03,143
2F9E:  MOVFF  02,142
2FA2:  MOVFF  01,141
2FA6:  MOVFF  00,140
.................... 						DHCPClient.smState = SM_DHCP_BOUND; 
2FAA:  MOVLW  06
2FAC:  MOVLB  1
2FAE:  MOVWF  x3E
.................... 						DHCPClient.flags.bits.bEvent = 1; 
2FB0:  BSF    x3F.1
.................... 						DHCPClient.flags.bits.bIsBound = TRUE;	 
2FB2:  BSF    x3F.0
....................  
.................... 						if(DHCPClient.validValues.bits.IPAddress) 
2FB4:  BTFSS  x58.0
2FB6:  BRA    2FC8
.................... 						{ 
.................... 							AppConfig.MyIPAddr = DHCPClient.tempIPAddress; 
2FB8:  MOVFF  14F,25
2FBC:  MOVFF  14E,24
2FC0:  MOVFF  14D,23
2FC4:  MOVFF  14C,22
.................... 							 
.................... 							#if defined(WF_CS_IO)  
.................... 							    #if defined(STACK_USE_UART ) 
.................... 							        putrsUART("DHCP client successful\r\n"); 
.................... 							    #endif 
....................     							SignalDHCPSuccessful(); 
.................... 							#endif 
.................... 							 
.................... 						}	 
.................... 						if(DHCPClient.validValues.bits.Mask) 
2FC8:  BTFSS  x58.2
2FCA:  BRA    2FDC
.................... 							AppConfig.MyMask = DHCPClient.tempMask; 
2FCC:  MOVFF  157,29
2FD0:  MOVFF  156,28
2FD4:  MOVFF  155,27
2FD8:  MOVFF  154,26
.................... 						if(DHCPClient.validValues.bits.Gateway) 
2FDC:  BTFSS  x58.1
2FDE:  BRA    2FF0
.................... 							AppConfig.MyGateway = DHCPClient.tempGateway; 
2FE0:  MOVFF  153,2D
2FE4:  MOVFF  152,2C
2FE8:  MOVFF  151,2B
2FEC:  MOVFF  150,2A
.................... 						#if defined(STACK_USE_DNS) 
.................... 							if(DHCPClient.validValues.bits.DNS) 
.................... 								AppConfig.PrimaryDNSServer.Val = DHCPClient.tempDNS.Val; 
.................... 							AppConfig.SecondaryDNSServer.Val = 0x00000000ul; 
.................... 							if(DHCPClient.validValues.bits.DNS2) 
.................... 								AppConfig.SecondaryDNSServer.Val = DHCPClient.tempDNS2.Val; 
.................... 						#endif 
.................... 						//if(DHCPClient.validValues.bits.HostName) 
.................... 						//	memcpy(AppConfig.NetBIOSName, (void*)DHCPClient.tempHostName, sizeof(AppConfig.NetBIOSName)); 
.................... 	 
.................... 						break; 
2FF0:  MOVLB  0
2FF2:  BRA    2FFC
.................... 	 
.................... 					case DHCP_NAK_MESSAGE: 
.................... 						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
2FF4:  MOVLW  02
2FF6:  MOVLB  1
2FF8:  MOVWF  x3E
.................... 						break; 
2FFA:  MOVLB  0
.................... 				} 
.................... 				break; 
2FFC:  MOVLB  1
2FFE:  BRA    31D2
.................... 	 
.................... 			case SM_DHCP_BOUND: 
.................... 				if(TickGet() - DHCPClient.dwTimer < TICK_SECOND) 
3000:  CALL   2692
3004:  MOVFF  03,39F
3008:  MOVFF  02,39E
300C:  MOVFF  01,39D
3010:  MOVFF  00,39C
3014:  MOVLB  1
3016:  MOVF   x40,W
3018:  MOVLB  3
301A:  SUBWF  x9C,F
301C:  MOVLB  1
301E:  MOVF   x41,W
3020:  MOVLB  3
3022:  SUBWFB x9D,F
3024:  MOVLB  1
3026:  MOVF   x42,W
3028:  MOVLB  3
302A:  SUBWFB x9E,F
302C:  MOVLB  1
302E:  MOVF   x43,W
3030:  MOVLB  3
3032:  SUBWFB x9F,F
3034:  BNZ   304E
3036:  MOVF   x9E,F
3038:  BNZ   304E
303A:  MOVF   x9D,W
303C:  SUBLW  1E
303E:  BNC   304E
3040:  BNZ   3048
3042:  MOVF   x9C,W
3044:  SUBLW  84
3046:  BNC   304E
.................... 					break; 
3048:  MOVLB  1
304A:  BRA    31D2
304C:  MOVLB  3
.................... 	 
.................... 				// Check to see if our lease is still valid, if so, decrement lease  
.................... 				// time 
.................... 				if(DHCPClient.dwLeaseTime >= 2ul) 
304E:  MOVLB  1
3050:  MOVF   x47,F
3052:  BNZ   3062
3054:  MOVF   x46,F
3056:  BNZ   3062
3058:  MOVF   x45,F
305A:  BNZ   3062
305C:  MOVF   x44,W
305E:  SUBLW  01
3060:  BC    3082
.................... 				{ 
.................... 					DHCPClient.dwTimer += TICK_SECOND; 
3062:  MOVLW  85
3064:  ADDWF  x40,F
3066:  MOVLW  1E
3068:  ADDWFC x41,F
306A:  MOVLW  00
306C:  ADDWFC x42,F
306E:  ADDWFC x43,F
.................... 					DHCPClient.dwLeaseTime--; 
3070:  MOVLW  FF
3072:  ADDWF  x44,F
3074:  BTFSS  FD8.0
3076:  ADDWF  x45,F
3078:  BTFSS  FD8.0
307A:  ADDWF  x46,F
307C:  BTFSS  FD8.0
307E:  ADDWF  x47,F
.................... 					break; 
3080:  BRA    31D2
.................... 				} 
.................... 	 
.................... 				// Open a socket to send and receive DHCP messages on 
.................... 				//DHCPClient.hDHCPSocket = UDPOpen(DHCP_CLIENT_PORT, NULL, DHCP_SERVER_PORT); 
.................... 				 
.................... 				DHCPClient.hDHCPSocket = UDPOpenEx(0,UDP_OPEN_SERVER,DHCP_CLIENT_PORT, DHCP_SERVER_PORT); 
3082:  MOVLB  3
3084:  CLRF   x9F
3086:  CLRF   x9E
3088:  CLRF   x9D
308A:  CLRF   x9C
308C:  CLRF   xA0
308E:  CLRF   xA2
3090:  MOVLW  44
3092:  MOVWF  xA1
3094:  CLRF   xA4
3096:  MOVLW  43
3098:  MOVWF  xA3
309A:  MOVLB  0
309C:  CALL   1896
30A0:  MOVFF  01,13D
.................... 				if(DHCPClient.hDHCPSocket == INVALID_UDP_SOCKET) 
30A4:  MOVLB  1
30A6:  INCFSZ x3D,W
30A8:  BRA    30AC
.................... 					break; 
30AA:  BRA    31D2
.................... 	 
.................... 				DHCPClient.smState = SM_DHCP_SEND_RENEW; 
30AC:  MOVLW  07
30AE:  MOVWF  x3E
30B0:  MOVLB  0
.................... 				// No break 
.................... 	 
.................... 			case SM_DHCP_SEND_RENEW: 
.................... 			case SM_DHCP_SEND_RENEW2: 
.................... 			case SM_DHCP_SEND_RENEW3: 
.................... 				if(UDPIsPutReady(DHCPClient.hDHCPSocket) < 258u) 
30B2:  MOVFF  13D,39C
30B6:  CALL   1A5A
30BA:  MOVFF  02,39D
30BE:  MOVFF  01,39C
30C2:  MOVLB  3
30C4:  MOVF   02,W
30C6:  SUBLW  01
30C8:  BNC   30D8
30CA:  BNZ   30D2
30CC:  MOVF   x9C,W
30CE:  SUBLW  01
30D0:  BNC   30D8
.................... 					break; 
30D2:  MOVLB  1
30D4:  BRA    31D2
30D6:  MOVLB  3
....................  
....................                                 #if defined(WF_CS_IO) 
....................                                     SetDhcpProgressState(); 
....................                                 #endif 
.................... 				// Send the DHCP request message 
.................... 				_DHCPSend(DHCP_REQUEST_MESSAGE, TRUE); 
30D8:  MOVLW  03
30DA:  MOVWF  x9C
30DC:  MOVLW  01
30DE:  MOVWF  x9D
30E0:  MOVLB  0
30E2:  CALL   2364
.................... 				DHCPClient.flags.bits.bOfferReceived = FALSE; 
30E6:  MOVLB  1
30E8:  BCF    x3F.2
.................... 	 
.................... 				// Start a timer and begin looking for a response 
.................... 				DHCPClient.dwTimer = TickGet(); 
30EA:  MOVLB  0
30EC:  CALL   2692
30F0:  MOVFF  03,143
30F4:  MOVFF  02,142
30F8:  MOVFF  01,141
30FC:  MOVFF  00,140
.................... 				DHCPClient.smState++; 
3100:  MOVLB  1
3102:  INCF   x3E,F
.................... 				break; 
3104:  BRA    31D2
.................... 	 
.................... 			case SM_DHCP_GET_RENEW_ACK: 
.................... 			case SM_DHCP_GET_RENEW_ACK2: 
.................... 			case SM_DHCP_GET_RENEW_ACK3: 
.................... 				// Check to see if a packet has arrived 
.................... 				if(UDPIsGetReady(DHCPClient.hDHCPSocket) < 250u) 
3106:  MOVFF  13D,39C
310A:  CALL   2750
310E:  MOVFF  02,39D
3112:  MOVFF  01,39C
3116:  MOVLB  3
3118:  MOVF   x9D,F
311A:  BNZ   3184
311C:  MOVF   x9C,W
311E:  SUBLW  F9
3120:  BNC   3184
.................... 				{ 
.................... 					// Go back and transmit a new discovery if we didn't get an ACK after 2 seconds 
.................... 					if(TickGet() - DHCPClient.dwTimer >=  DHCP_TIMEOUT) 
3122:  MOVLB  0
3124:  CALL   2692
3128:  MOVFF  03,39F
312C:  MOVFF  02,39E
3130:  MOVFF  01,39D
3134:  MOVFF  00,39C
3138:  MOVLB  1
313A:  MOVF   x40,W
313C:  MOVLB  3
313E:  SUBWF  x9C,F
3140:  MOVLB  1
3142:  MOVF   x41,W
3144:  MOVLB  3
3146:  SUBWFB x9D,F
3148:  MOVLB  1
314A:  MOVF   x42,W
314C:  MOVLB  3
314E:  SUBWFB x9E,F
3150:  MOVLB  1
3152:  MOVF   x43,W
3154:  MOVLB  3
3156:  SUBWFB x9F,F
3158:  BNZ   316E
315A:  MOVF   x9E,F
315C:  BNZ   316E
315E:  MOVF   x9D,W
3160:  SUBLW  97
3162:  BC    317E
3164:  XORLW  FF
3166:  BNZ   316E
3168:  MOVF   x9C,W
316A:  SUBLW  98
316C:  BC    317E
.................... 					{ 
.................... 						if(++DHCPClient.smState > SM_DHCP_GET_RENEW_ACK3) 
316E:  MOVLB  1
3170:  INCF   x3E,F
3172:  MOVF   x3E,W
3174:  SUBLW  0C
3176:  BC    317C
.................... 							DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
3178:  MOVLW  02
317A:  MOVWF  x3E
317C:  MOVLB  3
.................... 					} 
.................... 					break; 
317E:  MOVLB  1
3180:  BRA    31D2
3182:  MOVLB  3
.................... 				} 
.................... 	 
.................... 				// Check to see if we received an offer 
.................... 				switch(_DHCPReceive()) 
3184:  MOVLB  0
3186:  CALL   28F2
318A:  MOVF   01,W
318C:  XORLW  05
318E:  BZ    3196
3190:  XORLW  03
3192:  BZ    31C4
3194:  BRA    31CC
.................... 				{ 
.................... 					case DHCP_ACK_MESSAGE: 
.................... 						UDPClose(DHCPClient.hDHCPSocket); 
3196:  MOVFF  13D,39D
319A:  CALL   094C
.................... 						DHCPClient.hDHCPSocket = INVALID_UDP_SOCKET; 
319E:  MOVLB  1
31A0:  SETF   x3D
.................... 						DHCPClient.dwTimer = TickGet(); 
31A2:  MOVLB  0
31A4:  CALL   2692
31A8:  MOVFF  03,143
31AC:  MOVFF  02,142
31B0:  MOVFF  01,141
31B4:  MOVFF  00,140
.................... 						DHCPClient.smState = SM_DHCP_BOUND; 
31B8:  MOVLW  06
31BA:  MOVLB  1
31BC:  MOVWF  x3E
.................... 						DHCPClient.flags.bits.bEvent = 1; 
31BE:  BSF    x3F.1
.................... 						break; 
31C0:  MOVLB  0
31C2:  BRA    31CC
.................... 		 
.................... 					case DHCP_NAK_MESSAGE: 
.................... 						DHCPClient.smState = SM_DHCP_SEND_DISCOVERY; 
31C4:  MOVLW  02
31C6:  MOVLB  1
31C8:  MOVWF  x3E
.................... 						break; 
31CA:  MOVLB  0
.................... 				} 
.................... 				break; 
31CC:  MOVLB  1
31CE:  BRA    31D2
31D0:  MOVLB  1
.................... 		} 
31D2:  MOVLB  3
31D4:  INCF   x9B,F
31D6:  BRA    2CF2
.................... 	} 
31D8:  MOVLB  0
31DA:  GOTO   6D84 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
.................... Function: 
....................   void _DHCPReceive(void) 
....................  
.................... Description: 
....................   Receives and parses a DHCP message. 
....................  
.................... Precondition: 
....................   A DHCP message is waiting in the UDP buffer. 
....................  
.................... Parameters: 
....................   None 
....................  
.................... Returns: 
....................   One of the DCHP_TYPE* contants. 
.................... ***************************************************************************/ 
.................... static BYTE _DHCPReceive(void) 
.................... { 
.................... 	/********************************************************************* 
.................... 	DHCP PACKET FORMAT AS PER RFC 1541 
....................  
.................... 	0                   1                   2                   3 
.................... 	0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
.................... 	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
.................... 	|     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    | 
.................... 	+---------------+---------------+---------------+---------------+ 
.................... 	|                            xid (4)                            | 
.................... 	+-------------------------------+-------------------------------+ 
.................... 	|           secs (2)            |           flags (2)           | 
.................... 	+-------------------------------+-------------------------------+ 
.................... 	|                          ciaddr  (4)                          | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                          yiaddr  (4)                          | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                          siaddr  (4)                          | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                          giaddr  (4)                          | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                                                               | 
.................... 	|                          chaddr  (16)                         | 
.................... 	|                                                               | 
.................... 	|                                                               | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                                                               | 
.................... 	|                          sname   (64)                         | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                                                               | 
.................... 	|                          file    (128)                        | 
.................... 	+---------------------------------------------------------------+ 
.................... 	|                                                               | 
.................... 	|                          options (312)                        | 
.................... 	+---------------------------------------------------------------+ 
....................  
.................... 	********************************************************************/ 
.................... 	BYTE v; 
.................... 	BYTE i, j; 
.................... 	BYTE type; 
.................... 	BOOL lbDone; 
.................... 	DWORD tempServerID; 
....................    unsigned int32 xid;  // __CCS__ add g_DNSTransactionID 
....................  
....................  
.................... 	// Assume unknown message until proven otherwise. 
.................... 	type = DHCP_UNKNOWN_MESSAGE; 
*
28F2:  MOVLB  3
28F4:  CLRF   x9F
....................  
.................... 	UDPGet(&v);                             // op 
28F6:  MOVLW  03
28F8:  MOVWF  xAC
28FA:  MOVLW  9C
28FC:  MOVWF  xAB
28FE:  MOVLB  0
2900:  RCALL  2796
....................  
.................... 	// Make sure this is BOOT_REPLY. 
.................... 	if ( v == BOOT_REPLY ) 
2902:  MOVLB  3
2904:  MOVF   x9C,W
2906:  SUBLW  02
2908:  BTFSS  FD8.2
290A:  BRA    2C8A
.................... 	{ 
....................       // __CCS__ add g_DNSTransactionID 
....................       // get xid 
....................       UDPSetRxBuffer(4); 
290C:  CLRF   xAA
290E:  MOVLW  04
2910:  MOVWF  xA9
2912:  MOVLB  0
2914:  RCALL  272E
....................       UDPGetArray(&xid, 4); 
2916:  MOVLW  03
2918:  MOVLB  3
291A:  MOVWF  xAC
291C:  MOVLW  A5
291E:  MOVWF  xAB
2920:  CLRF   xAE
2922:  MOVLW  04
2924:  MOVWF  xAD
2926:  MOVLB  0
2928:  RCALL  27E4
....................       if (xid != g_DNSTransactionID) 
292A:  MOVLB  1
292C:  MOVF   x39,W
292E:  MOVLB  3
2930:  SUBWF  xA5,W
2932:  BNZ   2952
2934:  MOVLB  1
2936:  MOVF   x3A,W
2938:  MOVLB  3
293A:  SUBWF  xA6,W
293C:  BNZ   2952
293E:  MOVLB  1
2940:  MOVF   x3B,W
2942:  MOVLB  3
2944:  SUBWF  xA7,W
2946:  BNZ   2952
2948:  MOVLB  1
294A:  MOVF   x3C,W
294C:  MOVLB  3
294E:  SUBWF  xA8,W
2950:  BZ    2954
....................          goto UDPInvalid; 
2952:  BRA    2CE0
....................           
.................... 		// Jump to chaddr field (Client Hardware Address -- our MAC address for  
.................... 		// Ethernet and WiFi networks) and verify that this message is directed  
.................... 		// to us before doing any other processing. 
.................... 		UDPSetRxBuffer(28);		// chaddr field is at offset 28 in the UDP packet payload -- see DHCP packet format above 
2954:  CLRF   xAA
2956:  MOVLW  1C
2958:  MOVWF  xA9
295A:  MOVLB  0
295C:  RCALL  272E
.................... 		for ( i = 0; i < 6u; i++ ) 
295E:  MOVLB  3
2960:  CLRF   x9D
2962:  MOVF   x9D,W
2964:  SUBLW  05
2966:  BNC   2990
.................... 		{ 
.................... 			UDPGet(&v); 
2968:  MOVLW  03
296A:  MOVWF  xAC
296C:  MOVLW  9C
296E:  MOVWF  xAB
2970:  MOVLB  0
2972:  RCALL  2796
.................... 			if ( v != AppConfig.MyMACAddr.v[i]) 
2974:  CLRF   03
2976:  MOVLB  3
2978:  MOVF   x9D,W
297A:  ADDLW  4F
297C:  MOVWF  FE9
297E:  MOVLW  00
2980:  ADDWFC 03,W
2982:  MOVWF  FEA
2984:  MOVF   FEF,W
2986:  SUBWF  x9C,W
2988:  BZ    298C
.................... 				goto UDPInvalid; 
298A:  BRA    2CE0
298C:  INCF   x9D,F
298E:  BRA    2962
.................... 		} 
....................  
.................... 		// Check to see if this is the first offer.  If it is, record its  
.................... 		// yiaddr value ("Your (client) IP address") so that we can REQUEST to  
.................... 		// use it later. 
.................... 		if(!DHCPClient.flags.bits.bOfferReceived) 
2990:  MOVLB  1
2992:  BTFSC  x3F.2
2994:  BRA    29C0
.................... 		{ 
.................... 			UDPSetRxBuffer(16); 
2996:  MOVLB  3
2998:  CLRF   xAA
299A:  MOVLW  10
299C:  MOVWF  xA9
299E:  MOVLB  0
29A0:  RCALL  272E
.................... 			UDPGetArray((BYTE*)&DHCPClient.tempIPAddress, sizeof(DHCPClient.tempIPAddress)); 
29A2:  MOVLW  01
29A4:  MOVLB  3
29A6:  MOVWF  xAA
29A8:  MOVLW  4C
29AA:  MOVWF  xA9
29AC:  MOVFF  3AA,3AC
29B0:  MOVWF  xAB
29B2:  CLRF   xAE
29B4:  MOVLW  04
29B6:  MOVWF  xAD
29B8:  MOVLB  0
29BA:  RCALL  27E4
.................... 			DHCPClient.validValues.bits.IPAddress = 1; 
29BC:  MOVLB  1
29BE:  BSF    x58.0
.................... 		} 
....................  
.................... 		// Jump to DHCP options (ignore htype, hlen, hops, xid, secs, flags,  
.................... 		// ciaddr, siaddr, giaddr, padding part of chaddr, sname, file, magic  
.................... 		// cookie fields) 
.................... 		UDPSetRxBuffer(240); 
29C0:  MOVLB  3
29C2:  CLRF   xAA
29C4:  MOVLW  F0
29C6:  MOVWF  xA9
29C8:  MOVLB  0
29CA:  RCALL  272E
....................  
.................... 		lbDone = FALSE; 
29CC:  MOVLB  3
29CE:  BCF    xA0.0
.................... 		do 
.................... 		{ 
.................... 			// Get the Option number 
.................... 			// Break out eventually in case if this is a malformed  
.................... 			// DHCP message, ie: missing DHCP_END_OPTION marker 
.................... 			if(!UDPGet(&v)) 
29D0:  MOVLW  03
29D2:  MOVWF  xAC
29D4:  MOVLW  9C
29D6:  MOVWF  xAB
29D8:  MOVLB  0
29DA:  RCALL  2796
29DC:  MOVF   01,F
29DE:  BNZ   29E8
.................... 			{ 
.................... 				lbDone = TRUE; 
29E0:  MOVLB  3
29E2:  BSF    xA0.0
.................... 				break; 
29E4:  BRA    2C8A
29E6:  MOVLB  0
.................... 			} 
....................  
.................... 			switch(v) 
29E8:  MOVLB  3
29EA:  MOVF   x9C,W
29EC:  XORLW  35
29EE:  MOVLB  0
29F0:  BZ    2A0E
29F2:  XORLW  34
29F4:  BZ    2A50
29F6:  XORLW  02
29F8:  BZ    2AB4
29FA:  XORLW  35
29FC:  BTFSC  FD8.2
29FE:  BRA    2B34
2A00:  XORLW  C9
2A02:  BTFSC  FD8.2
2A04:  BRA    2B8C
2A06:  XORLW  CC
2A08:  BTFSC  FD8.2
2A0A:  BRA    2B94
2A0C:  BRA    2C5A
.................... 			{ 
.................... 				case DHCP_MESSAGE_TYPE: 
.................... 					UDPGet(&v);                         // Skip len 
2A0E:  MOVLW  03
2A10:  MOVLB  3
2A12:  MOVWF  xAC
2A14:  MOVLW  9C
2A16:  MOVWF  xAB
2A18:  MOVLB  0
2A1A:  RCALL  2796
.................... 					// Len must be 1. 
.................... 					if ( v == 1u ) 
2A1C:  MOVLB  3
2A1E:  DECFSZ x9C,W
2A20:  BRA    2A4A
.................... 					{ 
.................... 						UDPGet(&type);                  // Get type 
2A22:  MOVLW  03
2A24:  MOVWF  xAC
2A26:  MOVLW  9F
2A28:  MOVWF  xAB
2A2A:  MOVLB  0
2A2C:  RCALL  2796
....................  
.................... 						// Throw away the packet if we know we don't need it (ie: another offer when we already have one) 
.................... 						if(DHCPClient.flags.bits.bOfferReceived && (type == DHCP_OFFER_MESSAGE)) 
2A2E:  MOVLB  1
2A30:  BTFSS  x3F.2
2A32:  BRA    2A46
2A34:  MOVLB  3
2A36:  MOVF   x9F,W
2A38:  SUBLW  02
2A3A:  BTFSC  FD8.2
2A3C:  BRA    2A42
2A3E:  MOVLB  1
2A40:  BRA    2A46
.................... 						{ 
.................... 							goto UDPInvalid; 
2A42:  BRA    2CE0
2A44:  MOVLB  1
.................... 						} 
.................... 					} 
2A46:  BRA    2A4E
2A48:  MOVLB  3
.................... 					else 
.................... 						goto UDPInvalid; 
2A4A:  BRA    2CE0
2A4C:  MOVLB  1
.................... 					break; 
2A4E:  BRA    2C84
....................  
.................... 				case DHCP_SUBNET_MASK: 
.................... 					UDPGet(&v);                     // Skip len 
2A50:  MOVLW  03
2A52:  MOVLB  3
2A54:  MOVWF  xAC
2A56:  MOVLW  9C
2A58:  MOVWF  xAB
2A5A:  MOVLB  0
2A5C:  RCALL  2796
.................... 					// Len must be 4. 
.................... 					if ( v == 4u ) 
2A5E:  MOVLB  3
2A60:  MOVF   x9C,W
2A62:  SUBLW  04
2A64:  BNZ   2AAE
.................... 					{ 
.................... 						// Check to see if this is the first offer 
.................... 						if(DHCPClient.flags.bits.bOfferReceived) 
2A66:  MOVLB  1
2A68:  BTFSS  x3F.2
2A6A:  BRA    2A8C
.................... 						{ 
.................... 							// Discard offered IP mask, we already have an offer 
.................... 							for ( i = 0; i < 4u; i++ ) 
2A6C:  MOVLB  3
2A6E:  CLRF   x9D
2A70:  MOVF   x9D,W
2A72:  SUBLW  03
2A74:  BNC   2A88
.................... 								UDPGet(&v); 
2A76:  MOVLW  03
2A78:  MOVWF  xAC
2A7A:  MOVLW  9C
2A7C:  MOVWF  xAB
2A7E:  MOVLB  0
2A80:  RCALL  2796
2A82:  MOVLB  3
2A84:  INCF   x9D,F
2A86:  BRA    2A70
.................... 						} 
2A88:  BRA    2AAC
2A8A:  MOVLB  1
.................... 						else 
.................... 						{ 
.................... 							UDPGetArray((BYTE*)&DHCPClient.tempMask, sizeof(DHCPClient.tempMask)); 
2A8C:  MOVLW  01
2A8E:  MOVLB  3
2A90:  MOVWF  xAA
2A92:  MOVLW  54
2A94:  MOVWF  xA9
2A96:  MOVFF  3AA,3AC
2A9A:  MOVWF  xAB
2A9C:  CLRF   xAE
2A9E:  MOVLW  04
2AA0:  MOVWF  xAD
2AA2:  MOVLB  0
2AA4:  RCALL  27E4
.................... 							DHCPClient.validValues.bits.Mask = 1; 
2AA6:  MOVLB  1
2AA8:  BSF    x58.2
2AAA:  MOVLB  3
.................... 						} 
.................... 					} 
2AAC:  BRA    2AB0
.................... 					else 
.................... 						goto UDPInvalid; 
2AAE:  BRA    2CE0
.................... 					break; 
2AB0:  MOVLB  1
2AB2:  BRA    2C84
....................  
.................... 				case DHCP_ROUTER: 
.................... 					UDPGet(&j); 
2AB4:  MOVLW  03
2AB6:  MOVLB  3
2AB8:  MOVWF  xAC
2ABA:  MOVLW  9E
2ABC:  MOVWF  xAB
2ABE:  MOVLB  0
2AC0:  RCALL  2796
.................... 					// Len must be >= 4. 
.................... 					if ( j >= 4u ) 
2AC2:  MOVLB  3
2AC4:  MOVF   x9E,W
2AC6:  SUBLW  03
2AC8:  BC    2B12
.................... 					{ 
.................... 						// Check to see if this is the first offer 
.................... 						if(DHCPClient.flags.bits.bOfferReceived) 
2ACA:  MOVLB  1
2ACC:  BTFSS  x3F.2
2ACE:  BRA    2AF0
.................... 						{ 
.................... 							// Discard offered Gateway address, we already have an offer 
.................... 							for ( i = 0; i < 4u; i++ ) 
2AD0:  MOVLB  3
2AD2:  CLRF   x9D
2AD4:  MOVF   x9D,W
2AD6:  SUBLW  03
2AD8:  BNC   2AEC
.................... 								UDPGet(&v); 
2ADA:  MOVLW  03
2ADC:  MOVWF  xAC
2ADE:  MOVLW  9C
2AE0:  MOVWF  xAB
2AE2:  MOVLB  0
2AE4:  RCALL  2796
2AE6:  MOVLB  3
2AE8:  INCF   x9D,F
2AEA:  BRA    2AD4
.................... 						} 
2AEC:  BRA    2B10
2AEE:  MOVLB  1
.................... 						else 
.................... 						{ 
.................... 							UDPGetArray((BYTE*)&DHCPClient.tempGateway, sizeof(DHCPClient.tempGateway)); 
2AF0:  MOVLW  01
2AF2:  MOVLB  3
2AF4:  MOVWF  xAA
2AF6:  MOVLW  50
2AF8:  MOVWF  xA9
2AFA:  MOVFF  3AA,3AC
2AFE:  MOVWF  xAB
2B00:  CLRF   xAE
2B02:  MOVLW  04
2B04:  MOVWF  xAD
2B06:  MOVLB  0
2B08:  RCALL  27E4
.................... 							DHCPClient.validValues.bits.Gateway = 1; 
2B0A:  MOVLB  1
2B0C:  BSF    x58.1
2B0E:  MOVLB  3
.................... 						} 
.................... 					} 
2B10:  BRA    2B14
.................... 					else 
.................... 						goto UDPInvalid; 
2B12:  BRA    2CE0
....................  
.................... 					// Discard any other router addresses. 
.................... 					j -= 4; 
2B14:  MOVLW  04
2B16:  SUBWF  x9E,F
.................... 					while(j--) 
2B18:  MOVF   x9E,W
2B1A:  DECF   x9E,F
2B1C:  XORLW  00
2B1E:  BZ    2B30
.................... 						UDPGet(&v); 
2B20:  MOVLW  03
2B22:  MOVWF  xAC
2B24:  MOVLW  9C
2B26:  MOVWF  xAB
2B28:  MOVLB  0
2B2A:  RCALL  2796
2B2C:  MOVLB  3
2B2E:  BRA    2B18
.................... 					break; 
2B30:  MOVLB  1
2B32:  BRA    2C84
....................  
.................... 				#if defined(STACK_USE_DNS) 
.................... 				case DHCP_DNS: 
.................... 					UDPGet(&j); 
.................... 					// Len must be >= 4. 
.................... 					if(j < 4u) 
.................... 						goto UDPInvalid; 
....................  
.................... 					// Check to see if this is the first offer 
.................... 					if(!DHCPClient.flags.bits.bOfferReceived) 
.................... 					{ 
.................... 						UDPGetArray((BYTE*)&DHCPClient.tempDNS, sizeof(DHCPClient.tempDNS)); 
.................... 						DHCPClient.validValues.bits.DNS = 1; 
.................... 						j -= 4; 
.................... 					} 
....................  
.................... 					// Len must be >= 4 for a secondary DNS server address 
.................... 					if(j >= 4u) 
.................... 					{ 
.................... 						// Check to see if this is the first offer 
.................... 						if(!DHCPClient.flags.bits.bOfferReceived) 
.................... 						{ 
.................... 							UDPGetArray((BYTE*)&DHCPClient.tempDNS2, sizeof(DHCPClient.tempDNS2)); 
.................... 							DHCPClient.validValues.bits.DNS2 = 1; 
.................... 							j -= 4; 
.................... 						} 
.................... 					} 
....................  
.................... 					// Discard any other DNS server addresses 
.................... 					while(j--) 
.................... 						UDPGet(&v); 
.................... 					break; 
.................... 				#endif 
....................  
.................... 					//            case DHCP_HOST_NAME: 
.................... 					//                UDPGet(&j); 
.................... 					//                // Len must be >= 4. 
.................... 					//                if(j < 1u) 
.................... 					//					goto UDPInvalid; 
.................... 					// 
.................... 					//				// Check to see if this is the first offer 
.................... 					//				if(DHCPFlags.bits.bOfferReceived) 
.................... 					//				{ 
.................... 					//			        // Discard offered host name, we already have an offer 
.................... 					//	                while(j--) 
.................... 					//	                    UDPGet(&v); 
.................... 					//				} 
.................... 					//				else 
.................... 					//				{ 
.................... 					//					for(i = 0; j, i < sizeof(tempHostName); i++, j--) 
.................... 					//					{ 
.................... 					//						UDPGet(&tempHostName[i]); 
.................... 					//					} 
.................... 					//					while(j--) 
.................... 					//					{ 
.................... 					//						UDPGet(&v); 
.................... 					//					} 
.................... 					//					ValidValues.bits.HostName = 1; 
.................... 					//				} 
.................... 					// 
.................... 					//                break; 
....................  
.................... 				case DHCP_SERVER_IDENTIFIER: 
.................... 					UDPGet(&v);                         // Get len 
2B34:  MOVLW  03
2B36:  MOVLB  3
2B38:  MOVWF  xAC
2B3A:  MOVLW  9C
2B3C:  MOVWF  xAB
2B3E:  MOVLB  0
2B40:  RCALL  2796
.................... 					// Len must be 4. 
.................... 					if ( v == 4u ) 
2B42:  MOVLB  3
2B44:  MOVF   x9C,W
2B46:  SUBLW  04
2B48:  BNZ   2B84
.................... 					{ 
.................... 						UDPGet(&(((BYTE*)&tempServerID)[3]));   // Get the id 
2B4A:  MOVLW  03
2B4C:  MOVWF  xAC
2B4E:  MOVLW  A4
2B50:  MOVWF  xAB
2B52:  MOVLB  0
2B54:  RCALL  2796
.................... 						UDPGet(&(((BYTE*)&tempServerID)[2])); 
2B56:  MOVLW  03
2B58:  MOVLB  3
2B5A:  MOVWF  xAC
2B5C:  MOVLW  A3
2B5E:  MOVWF  xAB
2B60:  MOVLB  0
2B62:  RCALL  2796
.................... 						UDPGet(&(((BYTE*)&tempServerID)[1])); 
2B64:  MOVLW  03
2B66:  MOVLB  3
2B68:  MOVWF  xAC
2B6A:  MOVLW  A2
2B6C:  MOVWF  xAB
2B6E:  MOVLB  0
2B70:  RCALL  2796
.................... 						UDPGet(&(((BYTE*)&tempServerID)[0])); 
2B72:  MOVLW  03
2B74:  MOVLB  3
2B76:  MOVWF  xAC
2B78:  MOVLW  A1
2B7A:  MOVWF  xAB
2B7C:  MOVLB  0
2B7E:  RCALL  2796
....................                   #warning this wasn't working with old compilers 
.................... 					} 
2B80:  BRA    2B88
2B82:  MOVLB  3
.................... 					else 
.................... 						goto UDPInvalid; 
2B84:  BRA    2CE0
2B86:  MOVLB  0
.................... 					break; 
2B88:  MOVLB  1
2B8A:  BRA    2C84
....................  
.................... 				case DHCP_END_OPTION: 
.................... 					lbDone = TRUE; 
2B8C:  MOVLB  3
2B8E:  BSF    xA0.0
.................... 					break; 
2B90:  MOVLB  1
2B92:  BRA    2C84
....................  
.................... 				case DHCP_IP_LEASE_TIME: 
.................... 					UDPGet(&v);                         // Get len 
2B94:  MOVLW  03
2B96:  MOVLB  3
2B98:  MOVWF  xAC
2B9A:  MOVLW  9C
2B9C:  MOVWF  xAB
2B9E:  MOVLB  0
2BA0:  RCALL  2796
.................... 					// Len must be 4. 
.................... 					if ( v == 4u ) 
2BA2:  MOVLB  3
2BA4:  MOVF   x9C,W
2BA6:  SUBLW  04
2BA8:  BNZ   2C52
.................... 					{ 
.................... 						// Check to see if this is the first offer 
.................... 						if(DHCPClient.flags.bits.bOfferReceived) 
2BAA:  MOVLB  1
2BAC:  BTFSS  x3F.2
2BAE:  BRA    2BD0
.................... 						{ 
.................... 							// Discard offered lease time, we already have an offer 
.................... 							for ( i = 0; i < 4u; i++ ) 
2BB0:  MOVLB  3
2BB2:  CLRF   x9D
2BB4:  MOVF   x9D,W
2BB6:  SUBLW  03
2BB8:  BNC   2BCC
.................... 								UDPGet(&v); 
2BBA:  MOVLW  03
2BBC:  MOVWF  xAC
2BBE:  MOVLW  9C
2BC0:  MOVWF  xAB
2BC2:  MOVLB  0
2BC4:  RCALL  2796
2BC6:  MOVLB  3
2BC8:  INCF   x9D,F
2BCA:  BRA    2BB4
.................... 						} 
2BCC:  BRA    2C50
2BCE:  MOVLB  1
.................... 						else 
.................... 						{ 
.................... 							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[3])); 
2BD0:  MOVLW  01
2BD2:  MOVLB  3
2BD4:  MOVWF  xAC
2BD6:  MOVLW  47
2BD8:  MOVWF  xAB
2BDA:  MOVLB  0
2BDC:  RCALL  2796
.................... 							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[2])); 
2BDE:  MOVLW  01
2BE0:  MOVLB  3
2BE2:  MOVWF  xAC
2BE4:  MOVLW  46
2BE6:  MOVWF  xAB
2BE8:  MOVLB  0
2BEA:  RCALL  2796
.................... 							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[1])); 
2BEC:  MOVLW  01
2BEE:  MOVLB  3
2BF0:  MOVWF  xAC
2BF2:  MOVLW  45
2BF4:  MOVWF  xAB
2BF6:  MOVLB  0
2BF8:  RCALL  2796
.................... 							UDPGet(&(((BYTE*)(&DHCPClient.dwLeaseTime))[0])); 
2BFA:  MOVLW  01
2BFC:  MOVLB  3
2BFE:  MOVWF  xAC
2C00:  MOVLW  44
2C02:  MOVWF  xAB
2C04:  MOVLB  0
2C06:  RCALL  2796
....................                      #warning this wasn't working with old compilers 
....................  
.................... 							// In case if our clock is not as accurate as the remote  
.................... 							// DHCP server's clock, let's treat the lease time as only  
.................... 							// 96.875% of the value given 
.................... 							DHCPClient.dwLeaseTime -= DHCPClient.dwLeaseTime>>5; 
2C08:  MOVLB  1
2C0A:  RRCF   x47,W
2C0C:  MOVWF  03
2C0E:  RRCF   x46,W
2C10:  MOVWF  02
2C12:  RRCF   x45,W
2C14:  MOVWF  01
2C16:  RRCF   x44,W
2C18:  MOVWF  00
2C1A:  RRCF   03,F
2C1C:  RRCF   02,F
2C1E:  RRCF   01,F
2C20:  RRCF   00,F
2C22:  RRCF   03,F
2C24:  RRCF   02,F
2C26:  RRCF   01,F
2C28:  RRCF   00,F
2C2A:  RRCF   03,F
2C2C:  RRCF   02,F
2C2E:  RRCF   01,F
2C30:  RRCF   00,F
2C32:  RRCF   03,F
2C34:  RRCF   02,F
2C36:  RRCF   01,F
2C38:  RRCF   00,F
2C3A:  MOVLW  07
2C3C:  ANDWF  03,F
2C3E:  MOVF   00,W
2C40:  SUBWF  x44,F
2C42:  MOVF   01,W
2C44:  SUBWFB x45,F
2C46:  MOVF   02,W
2C48:  SUBWFB x46,F
2C4A:  MOVF   03,W
2C4C:  SUBWFB x47,F
2C4E:  MOVLB  3
.................... 						} 
.................... 					} 
2C50:  BRA    2C54
.................... 					else 
.................... 						goto UDPInvalid; 
2C52:  BRA    2CE0
.................... 					break; 
2C54:  MOVLB  1
2C56:  BRA    2C84
2C58:  MOVLB  0
....................  
.................... 				default: 
.................... 					// Ignore all unsupport tags. 
.................... 					UDPGet(&j);                     // Get option len 
2C5A:  MOVLW  03
2C5C:  MOVLB  3
2C5E:  MOVWF  xAC
2C60:  MOVLW  9E
2C62:  MOVWF  xAB
2C64:  MOVLB  0
2C66:  RCALL  2796
.................... 					while( j-- )                    // Ignore option values 
2C68:  MOVLB  3
2C6A:  MOVF   x9E,W
2C6C:  DECF   x9E,F
2C6E:  XORLW  00
2C70:  BZ    2C82
.................... 						UDPGet(&v); 
2C72:  MOVLW  03
2C74:  MOVWF  xAC
2C76:  MOVLW  9C
2C78:  MOVWF  xAB
2C7A:  MOVLB  0
2C7C:  RCALL  2796
2C7E:  BRA    2C68
2C80:  MOVLB  3
2C82:  MOVLB  1
.................... 			} 
.................... 		} while( !lbDone ); 
2C84:  MOVLB  3
2C86:  BTFSS  xA0.0
2C88:  BRA    29D0
.................... 	} 
....................  
.................... 	// If this is an OFFER message, remember current server id. 
.................... 	if ( type == DHCP_OFFER_MESSAGE ) 
2C8A:  MOVF   x9F,W
2C8C:  SUBLW  02
2C8E:  BNZ   2CA8
.................... 	{ 
.................... 		DHCPClient.dwServerID = tempServerID; 
2C90:  MOVFF  3A4,14B
2C94:  MOVFF  3A3,14A
2C98:  MOVFF  3A2,149
2C9C:  MOVFF  3A1,148
.................... 		DHCPClient.flags.bits.bOfferReceived = TRUE; 
2CA0:  MOVLB  1
2CA2:  BSF    x3F.2
.................... 	} 
2CA4:  BRA    2CD4
2CA6:  MOVLB  3
.................... 	else 
.................... 	{ 
.................... 		// For other types of messages, make sure that received 
.................... 		// server id matches with our previous one. 
.................... 		if ( DHCPClient.dwServerID != tempServerID ) 
2CA8:  MOVF   xA1,W
2CAA:  MOVLB  1
2CAC:  SUBWF  x48,W
2CAE:  BNZ   2CCE
2CB0:  MOVLB  3
2CB2:  MOVF   xA2,W
2CB4:  MOVLB  1
2CB6:  SUBWF  x49,W
2CB8:  BNZ   2CCE
2CBA:  MOVLB  3
2CBC:  MOVF   xA3,W
2CBE:  MOVLB  1
2CC0:  SUBWF  x4A,W
2CC2:  BNZ   2CCE
2CC4:  MOVLB  3
2CC6:  MOVF   xA4,W
2CC8:  MOVLB  1
2CCA:  SUBWF  x4B,W
2CCC:  BZ    2CD4
.................... 			type = DHCP_UNKNOWN_MESSAGE; 
2CCE:  MOVLB  3
2CD0:  CLRF   x9F
2CD2:  MOVLB  1
.................... 	} 
....................  
.................... 	UDPDiscard();                             // We are done with this packet 
2CD4:  MOVLB  0
2CD6:  RCALL  28DA
.................... 	return type; 
2CD8:  MOVLB  3
2CDA:  MOVFF  39F,01
2CDE:  BRA    2CEA
....................  
.................... UDPInvalid: 
.................... 	UDPDiscard(); 
2CE0:  MOVLB  0
2CE2:  RCALL  28DA
.................... 	return DHCP_UNKNOWN_MESSAGE; 
2CE4:  MOVLW  00
2CE6:  MOVWF  01
2CE8:  MOVLB  3
2CEA:  MOVLB  0
2CEC:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
.................... 	static void _DHCPSend(BYTE messageType, BOOL bRenewing) 
....................  
....................   Description: 
.................... 	Sends a DHCP message. 
....................  
....................   Precondition: 
.................... 	UDP is ready to write a DHCP packet. 
....................  
....................   Parameters: 
.................... 	messageType - One of the DHCP_TYPE constants 
.................... 	bRenewing - Whether or not this is a renewal request 
....................  
....................   Returns: 
.................... 	None 
.................... ***************************************************************************/ 
.................... static void _DHCPSend(BYTE messageType, BOOL bRenewing) 
.................... { 
.................... 	BYTE i; 
.................... 	IP_ADDR	MyIP; 
....................  
....................             // __CCS__ add g_DNSTransactionID 
....................    if (messageType == DHCP_DISCOVER_MESSAGE) 
*
2364:  MOVLB  3
2366:  DECFSZ x9C,W
2368:  BRA    238E
....................    { 
....................       g_DNSTransactionID = make32((int16)rand(), (int16)rand()); 
236A:  MOVLB  0
236C:  CALL   1B4A
2370:  MOVFF  02,3A4
2374:  MOVFF  01,3A3
2378:  CALL   1B4A
237C:  MOVFF  3A3,13B
2380:  MOVFF  3A4,13C
2384:  MOVFF  01,139
2388:  MOVFF  02,13A
238C:  MOVLB  3
....................    } 
....................  
.................... 	UDPPut(BOOT_REQUEST);                       // op 
238E:  MOVLW  01
2390:  MOVWF  xA5
2392:  MOVLB  0
2394:  RCALL  1BBA
.................... 	UDPPut(BOOT_HW_TYPE);                       // htype 
2396:  MOVLW  01
2398:  MOVLB  3
239A:  MOVWF  xA5
239C:  MOVLB  0
239E:  RCALL  1BBA
.................... 	UDPPut(BOOT_LEN_OF_HW_TYPE);                // hlen 
23A0:  MOVLW  06
23A2:  MOVLB  3
23A4:  MOVWF  xA5
23A6:  MOVLB  0
23A8:  RCALL  1BBA
.................... 	UDPPut(0);                                  // hops 
23AA:  MOVLB  3
23AC:  CLRF   xA5
23AE:  MOVLB  0
23B0:  RCALL  1BBA
....................    UDPPut(make8(g_DNSTransactionID,0));                               // xid[0] 
23B2:  MOVFF  139,3A3
23B6:  MOVFF  139,3A5
23BA:  CALL   1BBA
....................    UDPPut(make8(g_DNSTransactionID,1));                               // xid[1] 
23BE:  MOVFF  13A,3A3
23C2:  MOVFF  13A,3A5
23C6:  CALL   1BBA
....................    UDPPut(make8(g_DNSTransactionID,2));                               // xid[2] 
23CA:  MOVFF  13B,3A3
23CE:  MOVFF  13B,3A5
23D2:  CALL   1BBA
....................    UDPPut(make8(g_DNSTransactionID,3));                               // xid[3] 
23D6:  MOVFF  13C,3A3
23DA:  MOVFF  13C,3A5
23DE:  CALL   1BBA
.................... 	UDPPut(0);                                  // secs[0] 
23E2:  MOVLB  3
23E4:  CLRF   xA5
23E6:  MOVLB  0
23E8:  CALL   1BBA
.................... 	UDPPut(0);                                  // secs[1] 
23EC:  MOVLB  3
23EE:  CLRF   xA5
23F0:  MOVLB  0
23F2:  CALL   1BBA
.................... 	UDPPut(DHCPClient.flags.bits.bUseUnicastMode ? 0x00: 0x80);// flags[0] with Broadcast flag clear/set to correspond to bUseUnicastMode 
23F6:  MOVLB  1
23F8:  BTFSS  x3F.4
23FA:  BRA    2400
23FC:  MOVLW  00
23FE:  BRA    2402
2400:  MOVLW  80
2402:  MOVLB  3
2404:  MOVWF  xA3
2406:  MOVWF  xA5
2408:  MOVLB  0
240A:  CALL   1BBA
.................... 	UDPPut(0);                                  // flags[1] 
240E:  MOVLB  3
2410:  CLRF   xA5
2412:  MOVLB  0
2414:  CALL   1BBA
....................  
.................... 	// If this is DHCP REQUEST message, use previously allocated IP address. 
.................... 	if((messageType == DHCP_REQUEST_MESSAGE) && bRenewing) 
2418:  MOVLB  3
241A:  MOVF   x9C,W
241C:  SUBLW  03
241E:  BNZ   2442
2420:  MOVF   x9D,F
2422:  BZ    2442
.................... 	{ 
.................... 		UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, sizeof(DHCPClient.tempIPAddress)); 
2424:  MOVLW  01
2426:  MOVWF  xA4
2428:  MOVLW  4C
242A:  MOVWF  xA3
242C:  MOVFF  3A4,3A6
2430:  MOVWF  xA5
2432:  CLRF   xA8
2434:  MOVLW  04
2436:  MOVWF  xA7
2438:  MOVLB  0
243A:  CALL   1C10
.................... 	} 
243E:  BRA    2468
2440:  MOVLB  3
.................... 	else 
.................... 	{ 
.................... 		UDPPut(0x00); 
2442:  CLRF   xA5
2444:  MOVLB  0
2446:  CALL   1BBA
.................... 		UDPPut(0x00); 
244A:  MOVLB  3
244C:  CLRF   xA5
244E:  MOVLB  0
2450:  CALL   1BBA
.................... 		UDPPut(0x00); 
2454:  MOVLB  3
2456:  CLRF   xA5
2458:  MOVLB  0
245A:  CALL   1BBA
.................... 		UDPPut(0x00); 
245E:  MOVLB  3
2460:  CLRF   xA5
2462:  MOVLB  0
2464:  CALL   1BBA
.................... 	} 
....................  
.................... 	// Set yiaddr, siaddr, giaddr as zeros, 
.................... 	for ( i = 0; i < 12u; i++ ) 
2468:  MOVLB  3
246A:  CLRF   x9E
246C:  MOVF   x9E,W
246E:  SUBLW  0B
2470:  BNC   2480
.................... 		UDPPut(0x00); 
2472:  CLRF   xA5
2474:  MOVLB  0
2476:  CALL   1BBA
247A:  MOVLB  3
247C:  INCF   x9E,F
247E:  BRA    246C
....................  
.................... 	// Load chaddr - Client hardware address. 
.................... 	UDPPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
2480:  CLRF   xA4
2482:  MOVLW  4F
2484:  MOVWF  xA3
2486:  MOVFF  3A4,3A6
248A:  MOVWF  xA5
248C:  CLRF   xA8
248E:  MOVLW  06
2490:  MOVWF  xA7
2492:  MOVLB  0
2494:  CALL   1C10
....................  
.................... 	// Set chaddr[6..15], sname and file as zeros. 
.................... 	for ( i = 0; i < 202u; i++ ) 
2498:  MOVLB  3
249A:  CLRF   x9E
249C:  MOVF   x9E,W
249E:  SUBLW  C9
24A0:  BNC   24B0
.................... 		UDPPut(0); 
24A2:  CLRF   xA5
24A4:  MOVLB  0
24A6:  CALL   1BBA
24AA:  MOVLB  3
24AC:  INCF   x9E,F
24AE:  BRA    249C
....................  
.................... 	// Load magic cookie as per RFC 1533. 
.................... 	UDPPut(99); 
24B0:  MOVLW  63
24B2:  MOVWF  xA5
24B4:  MOVLB  0
24B6:  CALL   1BBA
.................... 	UDPPut(130); 
24BA:  MOVLW  82
24BC:  MOVLB  3
24BE:  MOVWF  xA5
24C0:  MOVLB  0
24C2:  CALL   1BBA
.................... 	UDPPut(83); 
24C6:  MOVLW  53
24C8:  MOVLB  3
24CA:  MOVWF  xA5
24CC:  MOVLB  0
24CE:  CALL   1BBA
.................... 	UDPPut(99); 
24D2:  MOVLW  63
24D4:  MOVLB  3
24D6:  MOVWF  xA5
24D8:  MOVLB  0
24DA:  CALL   1BBA
....................  
.................... 	// Load message type. 
.................... 	UDPPut(DHCP_MESSAGE_TYPE); 
24DE:  MOVLW  35
24E0:  MOVLB  3
24E2:  MOVWF  xA5
24E4:  MOVLB  0
24E6:  CALL   1BBA
.................... 	UDPPut(DHCP_MESSAGE_TYPE_LEN); 
24EA:  MOVLW  01
24EC:  MOVLB  3
24EE:  MOVWF  xA5
24F0:  MOVLB  0
24F2:  CALL   1BBA
.................... 	UDPPut(messageType); 
24F6:  MOVFF  39C,3A5
24FA:  CALL   1BBA
....................  
.................... 	if(messageType == DHCP_DISCOVER_MESSAGE) 
24FE:  MOVLB  3
2500:  DECFSZ x9C,W
2502:  BRA    250A
.................... 	{ 
.................... 		// Reset offered flag so we know to act upon the next valid offer 
.................... 		DHCPClient.flags.bits.bOfferReceived = FALSE; 
2504:  MOVLB  1
2506:  BCF    x3F.2
2508:  MOVLB  3
.................... 	} 
....................  
....................  
.................... 	if((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing) 
250A:  MOVF   x9C,W
250C:  SUBLW  03
250E:  BNZ   254C
2510:  MOVF   x9D,F
2512:  BNZ   254C
.................... 	{ 
.................... 		// DHCP REQUEST message must include server identifier the first time 
.................... 		// to identify the server we are talking to. 
.................... 		// _DHCPReceive() would populate "serverID" when it 
.................... 		// receives DHCP OFFER message. We will simply use that 
.................... 		// when we are replying to server. 
.................... 		// If this is a renwal request, we must not include server id. 
.................... 		UDPPut(DHCP_SERVER_IDENTIFIER); 
2514:  MOVLW  36
2516:  MOVWF  xA5
2518:  MOVLB  0
251A:  CALL   1BBA
.................... 		UDPPut(DHCP_SERVER_IDENTIFIER_LEN); 
251E:  MOVLW  04
2520:  MOVLB  3
2522:  MOVWF  xA5
2524:  MOVLB  0
2526:  CALL   1BBA
.................... 		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[3]); 
252A:  MOVFF  14B,3A5
252E:  CALL   1BBA
.................... 		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[2]); 
2532:  MOVFF  14A,3A5
2536:  CALL   1BBA
.................... 		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[1]); 
253A:  MOVFF  149,3A5
253E:  CALL   1BBA
.................... 		UDPPut(((BYTE*)(&DHCPClient.dwServerID))[0]); 
2542:  MOVFF  148,3A5
2546:  CALL   1BBA
254A:  MOVLB  3
....................       #warning not working in old compilers 
.................... 	} 
....................  
....................     //Set Host Name = ID String 
....................     //__CCS__ addition 
....................    #if defined(MY_UNIT_HOSTNAME) 
....................     UDPPut(12); 
....................     UDPPut(strlen(MY_UNIT_HOSTNAME)); 
....................     printf(UDPPut, "%s", MY_UNIT_HOSTNAME); 
....................    #endif    
....................     
.................... 	// Load our interested parameters 
.................... 	// This is hardcoded list.  If any new parameters are desired, 
.................... 	// new lines must be added here. 
.................... 	UDPPut(DHCP_PARAM_REQUEST_LIST); 
254C:  MOVLW  37
254E:  MOVWF  xA5
2550:  MOVLB  0
2552:  CALL   1BBA
.................... 	UDPPut(DHCP_PARAM_REQUEST_LIST_LEN); 
2556:  MOVLW  04
2558:  MOVLB  3
255A:  MOVWF  xA5
255C:  MOVLB  0
255E:  CALL   1BBA
.................... 	UDPPut(DHCP_SUBNET_MASK); 
2562:  MOVLW  01
2564:  MOVLB  3
2566:  MOVWF  xA5
2568:  MOVLB  0
256A:  CALL   1BBA
.................... 	UDPPut(DHCP_ROUTER); 
256E:  MOVLW  03
2570:  MOVLB  3
2572:  MOVWF  xA5
2574:  MOVLB  0
2576:  CALL   1BBA
.................... 	UDPPut(DHCP_DNS); 
257A:  MOVLW  06
257C:  MOVLB  3
257E:  MOVWF  xA5
2580:  MOVLB  0
2582:  CALL   1BBA
.................... 	UDPPut(DHCP_HOST_NAME); 
2586:  MOVLW  0C
2588:  MOVLB  3
258A:  MOVWF  xA5
258C:  MOVLB  0
258E:  CALL   1BBA
....................  
.................... 	// Add requested IP address to DHCP Request Message 
.................... 	if( ((messageType == DHCP_REQUEST_MESSAGE) && !bRenewing) ||  
.................... 		((messageType == DHCP_DISCOVER_MESSAGE) && DHCPClient.tempIPAddress.Val)) 
2592:  MOVLB  3
2594:  MOVF   x9C,W
2596:  SUBLW  03
2598:  BNZ   259E
259A:  MOVF   x9D,F
259C:  BZ    25CE
259E:  DECFSZ x9C,W
25A0:  BRA    2602
25A2:  MOVLB  1
25A4:  MOVF   x4C,F
25A6:  BTFSC  FD8.2
25A8:  BRA    25AE
25AA:  MOVLB  3
25AC:  BRA    25CE
25AE:  MOVF   x4D,F
25B0:  BTFSC  FD8.2
25B2:  BRA    25B8
25B4:  MOVLB  3
25B6:  BRA    25CE
25B8:  MOVF   x4E,F
25BA:  BTFSC  FD8.2
25BC:  BRA    25C2
25BE:  MOVLB  3
25C0:  BRA    25CE
25C2:  MOVF   x4F,F
25C4:  BTFSS  FD8.2
25C6:  BRA    25CC
25C8:  MOVLB  3
25CA:  BRA    2602
25CC:  MOVLB  3
.................... 	{ 
.................... 		UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS); 
25CE:  MOVLW  32
25D0:  MOVWF  xA5
25D2:  MOVLB  0
25D4:  CALL   1BBA
.................... 		UDPPut(DHCP_PARAM_REQUEST_IP_ADDRESS_LEN); 
25D8:  MOVLW  04
25DA:  MOVLB  3
25DC:  MOVWF  xA5
25DE:  MOVLB  0
25E0:  CALL   1BBA
.................... 		UDPPutArray((BYTE*)&DHCPClient.tempIPAddress, DHCP_PARAM_REQUEST_IP_ADDRESS_LEN); 
25E4:  MOVLW  01
25E6:  MOVLB  3
25E8:  MOVWF  xA4
25EA:  MOVLW  4C
25EC:  MOVWF  xA3
25EE:  MOVFF  3A4,3A6
25F2:  MOVWF  xA5
25F4:  CLRF   xA8
25F6:  MOVLW  04
25F8:  MOVWF  xA7
25FA:  MOVLB  0
25FC:  CALL   1C10
2600:  MOVLB  3
.................... 	} 
....................  
.................... 	// Add any new paramter request here. 
....................  
.................... 	// End of Options. 
.................... 	UDPPut(DHCP_END_OPTION); 
2602:  SETF   xA5
2604:  MOVLB  0
2606:  CALL   1BBA
....................  
.................... 	// Add zero padding to ensure compatibility with old BOOTP relays that discard small packets (<300 UDP octets) 
.................... 	while(UDPTxCount < 300u) 
260A:  MOVF   xF8,W
260C:  SUBLW  01
260E:  BNC   2624
2610:  BNZ   2618
2612:  MOVF   xF7,W
2614:  SUBLW  2B
2616:  BNC   2624
.................... 		UDPPut(0);  
2618:  MOVLB  3
261A:  CLRF   xA5
261C:  MOVLB  0
261E:  CALL   1BBA
2622:  BRA    260A
....................  
.................... 	// Make sure we advertise a 0.0.0.0 IP address so all DHCP servers will respond.  If we have a static IP outside the DHCP server's scope, it may simply ignore discover messages. 
.................... 	MyIP.Val = AppConfig.MyIPAddr.Val; 
2624:  MOVFF  25,3A2
2628:  MOVFF  24,3A1
262C:  MOVFF  23,3A0
2630:  MOVFF  22,39F
.................... 	if(!bRenewing) 
2634:  MOVLB  3
2636:  MOVF   x9D,F
2638:  BNZ   2642
.................... 		AppConfig.MyIPAddr.Val = 0x00000000; 
263A:  CLRF   25
263C:  CLRF   24
263E:  CLRF   23
2640:  CLRF   22
.................... 	UDPFlush(); 
2642:  MOVLB  0
2644:  BRA    225E
.................... 	AppConfig.MyIPAddr.Val = MyIP.Val; 
2646:  MOVFF  3A2,25
264A:  MOVFF  3A1,24
264E:  MOVFF  3A0,23
2652:  MOVFF  39F,22
2656:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... #endif	//#if defined(STACK_USE_DHCP_CLIENT) 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_SERVER) 
....................    #include "DHCPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS_SERVER) 
....................    #include "DNSs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
....................    #include "TCP.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Transmission Control Protocol (TCP) Communications Layer 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides reliable, handshaked transport of application stream  
....................  *    oriented data with flow control 
....................  *    -Reference: RFC 793 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.c 
....................  * Dependencies:    IP, Tick, Ethernet/WiFi (ENC28J60.c, ETH97J60.c,  
....................  *               ENCX24J600.c, or WFMac.c), ARP (optional),  
....................  *               DNS (optional) 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date       Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01     Original        (Rev 1.0) 
....................  * Howard Schlunder      12/11/06   Changed almost everything to  
....................  *                           better meet RFC 793. 
....................  * Darren Rook          04/14/11 Changed TCP_SOCKET_COUNT to use TCP_CONFIGURATION. 
....................  ********************************************************************/ 
.................... #define __TCP_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_TCP) 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Configuration Parameters 
....................   ***************************************************************************/ 
....................  
.................... // Starting port for client sockets 
.................... #define LOCAL_PORT_START_NUMBER (1024u) 
.................... // End port for client sockets 
.................... #define LOCAL_PORT_END_NUMBER   (5000u) 
....................  
.................... // For debugging only.  Normal applications should never enable these 
.................... //#define DEBUG_GENERATE_TX_LOSS      62257 
.................... //#define DEBUG_GENERATE_RX_LOSS      64225 
....................  
.................... // A lot of pointer dereference code can be removed if you  
.................... // locally copy TCBStubs to an absolute memory location. 
.................... // If you define TCP_OPTIMIZE_FOR_SIZE, local caching will  
.................... // occur and will substantially decrease the entire TCP ROM  
.................... // footprint (up to 35%).  If you leave TCP_OPTIMIZE_FOR_SIZE  
.................... // undefined, the local caching will be disabled.  On PIC18  
.................... // products, this will improve TCP performance/throughput by  
.................... // approximately 15%. 
.................... #define TCP_OPTIMIZE_FOR_SIZE 
....................  
.................... // For smallest size and best throughput, TCP_OPTIMIZE_FOR_SIZE  
.................... // should always be enabled on PIC24/dsPIC products.  On PIC32  
.................... // products there is very little difference and depnds on compiler  
.................... // optimization level 
.................... #if defined(__C30__) && !defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #define TCP_OPTIMIZE_FOR_SIZE 
.................... #elif defined(__C32__) && defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    #undef TCP_OPTIMIZE_FOR_SIZE 
.................... #endif 
....................  
.................... // TCP Maximum Segment Size for TX.  The TX maximum segment size is actually  
.................... // govered by the remote node's MSS option advirtised during connection  
.................... // establishment.  However, if the remote node specifies an unhandlably large  
.................... // MSS (ex: > Ethernet MTU), this define sets a hard limit so that we don't  
.................... // cause any TX buffer overflows.  If the remote node does not advirtise a MSS  
.................... // option, all TX segments are fixed at 536 bytes maximum. 
.................... #define TCP_MAX_SEG_SIZE_TX         (1460u) 
....................  
.................... // TCP Maximum Segment Size for RX.  This value is advirtised during connection  
.................... // establishment and the remote node should obey it.  This should be set to 536  
.................... // to avoid IP layer fragmentation from causing packet loss.  However, raising  
.................... // its value can enhance performance at the (small) risk of introducing  
.................... // incompatibility with certain special remote nodes (ex: ones connected via a  
.................... // slow dial up modem). 
.................... #define TCP_MAX_SEG_SIZE_RX         (536u) 
....................  
.................... // TCP Timeout and retransmit numbers 
.................... #define TCP_START_TIMEOUT_VAL      ((DWORD)TICK_SECOND*1)   // Timeout to retransmit unacked data 
.................... #define TCP_DELAYED_ACK_TIMEOUT      ((DWORD)TICK_SECOND/10)   // Timeout for delayed-acknowledgement algorithm 
.................... #define TCP_FIN_WAIT_2_TIMEOUT      ((DWORD)TICK_SECOND*5)   // Timeout for FIN WAIT 2 state 
.................... #define TCP_KEEP_ALIVE_TIMEOUT      ((DWORD)TICK_SECOND*10)   // Timeout for keep-alive messages when no traffic is sent 
.................... #define TCP_CLOSE_WAIT_TIMEOUT      ((DWORD)TICK_SECOND/5)   // Timeout for the CLOSE_WAIT state 
.................... #define TCP_MAX_RETRIES             (5u)               // Maximum number of retransmission attempts 
.................... #define TCP_MAX_UNACKED_KEEP_ALIVES   (6u)               // Maximum number of keep-alive messages that can be sent without receiving a response before automatically closing the connection 
.................... #define TCP_MAX_SYN_RETRIES         (2u)   // Smaller than all other retries to reduce SYN flood DoS duration 
....................  
.................... #define TCP_AUTO_TRANSMIT_TIMEOUT_VAL   (TICK_SECOND/25ull)   // Timeout before automatically transmitting unflushed data 
.................... #define TCP_WINDOW_UPDATE_TIMEOUT_VAL   (TICK_SECOND/5ull)   // Timeout before automatically transmitting a window update due to a TCPGet() or TCPGetArray() function call 
....................  
.................... #define TCP_SYN_QUEUE_MAX_ENTRIES   (3u)                // Number of TCP RX SYN packets to save if they cannot be serviced immediately 
.................... #define TCP_SYN_QUEUE_TIMEOUT      ((DWORD)TICK_SECOND*3)   // Timeout for when SYN queue entries are deleted if unserviceable 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCP Header Data Types 
....................   ***************************************************************************/ 
....................  
.................... #define FIN     (0x01)      // FIN Flag as defined in RFC 
.................... #define SYN     (0x02)      // SYN Flag as defined in RFC 
.................... #define RST     (0x04)      // Reset Flag as defined in RFC 
.................... #define PSH     (0x08)      // Push Flag as defined in RFC 
.................... #define ACK     (0x10)      // Acknowledge Flag as defined in RFC 
.................... #define URG     (0x20)      // Urgent Flag as defined in RFC 
....................  
.................... // TCP Header Data Structure 
.................... typedef struct 
.................... { 
....................    WORD    SourcePort;      // Local port number 
....................    WORD    DestPort;      // Remote port number 
....................    DWORD   SeqNumber;      // Local sequence number 
....................    DWORD   AckNumber;      // Acknowledging remote sequence number 
....................  
....................    struct 
....................    { 
....................       unsigned char Reserved3      : 4; 
....................       unsigned char Val            : 4; 
....................    } DataOffset;         // Data offset flags nibble 
....................  
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned char flagFIN    : 1; 
....................          unsigned char flagSYN    : 1; 
....................          unsigned char flagRST    : 1; 
....................          unsigned char flagPSH    : 1; 
....................          unsigned char flagACK    : 1; 
....................          unsigned char flagURG    : 1; 
....................          unsigned char Reserved2  : 2; 
....................       } bits; 
....................       BYTE byte; 
....................    } Flags;            // TCP Flags as defined in RFC 
....................  
....................    WORD    Window;         // Local free RX buffer window 
....................    WORD    Checksum;      // Data payload checksum 
....................    WORD    UrgentPointer;   // Urgent pointer 
.................... } TCP_HEADER; 
....................  
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00u)      // End of List TCP Option Flag 
.................... #define TCP_OPTIONS_NO_OP           (0x01u)      // No Op TCP Option 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02u)      // Maximum segment size TCP flag 
.................... typedef struct 
.................... { 
....................    BYTE        Kind;                     // Type of option 
....................    BYTE        Length;                     // Length 
....................    WORD_VAL    MaxSegSize;                  // Maximum segment size 
.................... } TCP_OPTIONS;                           // TCP Options data structure                      
....................  
.................... // Structure containing all the important elements of an incomming  
.................... // SYN packet in order to establish a connection at a future time  
.................... // if all sockets on the listening port are already connected to  
.................... // someone 
.................... typedef struct  
.................... { 
....................    NODE_INFO   niSourceAddress;// Remote IP address and MAC address 
....................    WORD      wSourcePort;   // Remote TCP port number that the response SYN needs to be sent to 
....................    DWORD      dwSourceSEQ;   // Remote TCP SEQuence number that must be ACKnowledged when we send our response SYN 
....................    WORD      wDestPort;      // Local TCP port which the original SYN was destined for 
....................    WORD      wTimestamp;      // Timer to expire old SYN packets that can't be serviced at all 
.................... } TCP_SYN_QUEUE; 
....................  
....................  
.................... #if defined(STACK_CLIENT_MODE) 
.................... static WORD NextPort __attribute__((persistent));   // Tracking variable for next local client port number 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Definitions 
....................   ***************************************************************************/ 
....................  
.................... // Determines the number of defined TCP sockets 
.................... //#define TCP_SOCKET_COUNT   (sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0])) 
.................... #define TCP_SOCKET_COUNT   TCP_CONFIGURATION    //ccs changed 
....................  
.................... #if defined(HI_TECH_C) 
....................    // The initializer forces this large array out of the bss section  
....................    // so we can link correctly. 
....................    #pragma psect bigdata=TCB_uRAM_BIG 
....................    #pragma psect data=TCB_uRAM 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT] = {'\0'};    
....................    #pragma psect data=ordinary_data_sect 
....................    #pragma psect bigdata=ordinary_data_sect_big 
.................... #else 
....................    // The TCB array is very large.  With the C18 compiler, one must  
....................    // modify the linker script to make an array that spans more than  
....................    // one memory bank.  To do this, make the necessary changes to your  
....................    // processor's linker script (.lkr).  Here is an example showing  
....................    // gpr11 and 128 bytes of gpr12 being combined into one 384 byte  
....................    // block used exclusively by the TCB_uRAM data section: 
....................    // ... 
....................    // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
....................    // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
....................    // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
....................    // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
....................    // ... 
....................    // SECTION    NAME=TCB_uRAM    RAM=gpr11b 
....................    // ... 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata TCB_uRAM 
....................    #endif 
....................    static TCB_STUB TCBStubs[TCP_SOCKET_COUNT]; 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata               // Return to any other RAM section 
....................    #endif 
.................... #endif 
....................  
.................... static TCB MyTCB;                           // Currently loaded TCB 
.................... static TCP_SOCKET hCurrentTCP = INVALID_SOCKET;      // Current TCP socket 
.................... #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata SYN_QUEUE_RAM_SECT 
....................    #endif 
....................    static TCP_SYN_QUEUE SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES];   // Array of saved incoming SYN requests that need to be serviced later 
....................    #if defined(__18CXX) && !defined(HI_TECH_C)    
....................       #pragma udata 
....................    #endif 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Function Prototypes 
....................   ***************************************************************************/ 
....................  
.................... static void TCPRAMCopy(PTR_BASE wDest, BYTE vDestType, PTR_BASE wSource, BYTE vSourceType, WORD wLength); 
....................  
.................... #if defined(__18CXX) 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength); 
.................... #else 
....................    #define TCPRAMCopyROM(a,b,c,d)   TCPRAMCopy(a,b,c,TCP_PIC_RAM,d) 
.................... #endif 
....................  
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags); 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len); 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote); 
.................... static void SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(void); 
.................... static void SyncTCB(void); 
....................  
.................... #if defined(WF_CS_TRIS) 
.................... UINT16 WFGetTCBSize(void); 
.................... #endif 
....................  
.................... // Indicates if this packet is a retransmission (no reset) or a new packet (reset required) 
.................... #define SENDTCP_RESET_TIMERS   0x01 
.................... // Instead of transmitting normal data, a garbage octet is transmitted according to RFC 1122 section 4.2.3.6 
.................... #define SENDTCP_KEEP_ALIVE      0x02 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    TCB Optimization Configuration 
....................   ***************************************************************************/ 
....................  
.................... #if defined(TCP_OPTIMIZE_FOR_SIZE) 
....................    static TCB_STUB MyTCBStub; 
....................     
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    static void SyncTCBStub(TCP_SOCKET hTCP) 
....................    { 
....................       if(hCurrentTCP == hTCP) 
*
0A0C:  MOVLB  3
0A0E:  MOVF   xD0,W
0A10:  MOVLB  1
0A12:  SUBWF  x9C,W
0A14:  BNZ   0A18
....................          return; 
0A16:  BRA    0AAA
....................     
....................       if(hCurrentTCP != INVALID_SOCKET) 
0A18:  MOVF   x9C,W
0A1A:  SUBLW  FE
0A1C:  BZ    0A5A
....................       { 
....................          // Save the current TCB stub 
....................          memcpy((void*)&TCBStubs[hCurrentTCP], (void*)&MyTCBStub, sizeof(MyTCBStub)); 
0A1E:  MOVF   x9C,W
0A20:  MULLW  1C
0A22:  MOVF   FF3,W
0A24:  CLRF   03
0A26:  ADDLW  59
0A28:  MOVWF  01
0A2A:  MOVLW  01
0A2C:  ADDWFC 03,F
0A2E:  MOVFF  01,3D1
0A32:  MOVLB  3
0A34:  MOVFF  03,3D2
0A38:  MOVLW  01
0A3A:  MOVWF  xD4
0A3C:  MOVLW  D9
0A3E:  MOVFF  03,FEA
0A42:  MOVFF  01,FE9
0A46:  MOVFF  3D4,FE2
0A4A:  MOVWF  FE1
0A4C:  MOVLW  1C
0A4E:  MOVWF  01
0A50:  MOVFF  FE6,FEE
0A54:  DECFSZ 01,F
0A56:  BRA    0A50
0A58:  MOVLB  1
....................       } 
....................     
....................       hCurrentTCP = hTCP; 
0A5A:  MOVFF  3D0,19C
....................     
....................       if(hTCP == INVALID_SOCKET) 
0A5E:  MOVLB  3
0A60:  MOVF   xD0,W
0A62:  SUBLW  FE
0A64:  BNZ   0A6C
....................          return; 
0A66:  MOVLB  1
0A68:  BRA    0AAA
0A6A:  MOVLB  3
....................     
....................       // Load up the new TCB stub 
....................       memcpy((void*)&MyTCBStub, (void*)&TCBStubs[hTCP], sizeof(MyTCBStub)); 
0A6C:  MOVLW  01
0A6E:  MOVWF  xD2
0A70:  MOVLW  D9
0A72:  MOVWF  xD1
0A74:  MOVF   xD0,W
0A76:  MULLW  1C
0A78:  MOVF   FF3,W
0A7A:  CLRF   03
0A7C:  ADDLW  59
0A7E:  MOVWF  01
0A80:  MOVLW  01
0A82:  ADDWFC 03,F
0A84:  MOVFF  01,3D3
0A88:  MOVFF  03,3D4
0A8C:  MOVFF  3D2,FEA
0A90:  MOVFF  3D1,FE9
0A94:  MOVFF  03,FE2
0A98:  MOVFF  01,FE1
0A9C:  MOVLW  1C
0A9E:  MOVWF  01
0AA0:  MOVFF  FE6,FEE
0AA4:  DECFSZ 01,F
0AA6:  BRA    0AA0
0AA8:  MOVLB  1
0AAA:  MOVLB  0
0AAC:  RETURN 0
....................    } 
.................... #else 
....................    // Flushes MyTCBStub cache and loads up the specified TCB_STUB. 
....................    // Does nothing on cache hit. 
....................    #define SyncTCBStub(a)   hCurrentTCP = (a) 
....................    // Alias to current TCP stub. 
....................    #define MyTCBStub      TCBStubs[hCurrentTCP] 
.................... #endif 
....................  
....................  
....................  
.................... // Flushes MyTCB cache and loads up the specified TCB. 
.................... // Does nothing on cache hit. 
.................... static void SyncTCB(void) 
.................... { 
....................    static TCP_SOCKET hLastTCB = INVALID_SOCKET; 
....................     
....................    if(hLastTCB == hCurrentTCP) 
*
100C:  MOVLB  1
100E:  MOVF   x9C,W
1010:  SUBWF  xF5,W
1012:  BNZ   1016
....................       return; 
1014:  BRA    10E0
....................  
....................    if(hLastTCB != INVALID_SOCKET) 
1016:  MOVF   xF5,W
1018:  SUBLW  FE
101A:  BZ    109A
....................    { 
....................       // Save the current TCB 
....................       TCPRAMCopy(TCBStubs[hLastTCB].bufferTxStart - sizeof(MyTCB), TCBStubs[hLastTCB].vMemoryMedium, (PTR_BASE)&MyTCB, TCP_PIC_RAM, sizeof(MyTCB)); 
101C:  MOVF   xF5,W
101E:  MULLW  1C
1020:  MOVF   FF3,W
1022:  MOVLB  4
1024:  CLRF   x11
1026:  MOVWF  x10
1028:  MOVLW  59
102A:  ADDWF  x10,W
102C:  MOVWF  FE9
102E:  MOVLW  01
1030:  ADDWFC x11,W
1032:  MOVWF  FEA
1034:  MOVFF  FEC,413
1038:  MOVF   FED,F
103A:  MOVFF  FEF,412
103E:  MOVLW  27
1040:  SUBWF  x12,F
1042:  MOVLW  00
1044:  SUBWFB x13,F
1046:  MOVLB  1
1048:  MOVF   xF5,W
104A:  MULLW  1C
104C:  MOVF   FF3,W
104E:  MOVLB  4
1050:  CLRF   x15
1052:  MOVWF  x14
1054:  MOVLW  1B
1056:  ADDWF  x14,W
1058:  MOVWF  01
105A:  MOVLW  00
105C:  ADDWFC x15,W
105E:  MOVWF  03
1060:  MOVF   01,W
1062:  ADDLW  59
1064:  MOVWF  FE9
1066:  MOVLW  01
1068:  ADDWFC 03,W
106A:  MOVWF  FEA
106C:  MOVFF  FEF,414
1070:  MOVLW  01
1072:  MOVWF  x16
1074:  MOVLW  75
1076:  MOVWF  x15
1078:  MOVFF  413,418
107C:  MOVFF  412,417
1080:  MOVFF  414,419
1084:  MOVFF  416,41B
1088:  MOVWF  x1A
108A:  MOVLW  01
108C:  MOVWF  x1C
108E:  CLRF   x1E
1090:  MOVLW  27
1092:  MOVWF  x1D
1094:  MOVLB  0
1096:  RCALL  0F26
1098:  MOVLB  1
....................    } 
....................  
....................    // Load up the new TCB 
....................    hLastTCB = hCurrentTCP; 
109A:  MOVFF  19C,1F5
....................    TCPRAMCopy((PTR_BASE)&MyTCB, TCP_PIC_RAM, MyTCBStub.bufferTxStart - sizeof(MyTCB), MyTCBStub.vMemoryMedium, sizeof(MyTCB)); 
109E:  MOVLW  01
10A0:  MOVLB  4
10A2:  MOVWF  x11
10A4:  MOVLW  75
10A6:  MOVWF  x10
10A8:  MOVLW  27
10AA:  MOVLB  1
10AC:  SUBWF  xD9,W
10AE:  MOVLB  4
10B0:  MOVWF  x12
10B2:  MOVLW  00
10B4:  MOVLB  1
10B6:  SUBWFB xDA,W
10B8:  MOVLB  4
10BA:  MOVWF  x13
10BC:  MOVFF  411,418
10C0:  MOVFF  410,417
10C4:  MOVLW  01
10C6:  MOVWF  x19
10C8:  MOVFF  413,41B
10CC:  MOVFF  412,41A
10D0:  MOVFF  1F4,41C
10D4:  CLRF   x1E
10D6:  MOVLW  27
10D8:  MOVWF  x1D
10DA:  MOVLB  0
10DC:  RCALL  0F26
10DE:  MOVLB  1
10E0:  MOVLB  0
10E2:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPInit(void) 
....................  
....................   Summary: 
....................    Initializes the TCP module. 
....................  
....................   Description: 
....................    Initializes the TCP module.  This function sets up the TCP buffers 
....................    in memory and initializes each socket to the CLOSED state.  If 
....................    insufficient memory was allocated for the TCP sockets, the function 
....................    will hang here to be captured by the debugger. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................      None 
....................       
....................   Remarks: 
....................    This function is called only one during lifetime of the application. 
....................   ***************************************************************************/ 
.................... void TCPInit(void) 
*
11B6:  MOVLW  17
11B8:  MOVLB  3
11BA:  MOVWF  x85
11BC:  MOVLW  C8
11BE:  MOVWF  x84
.................... { 
....................    BYTE i; 
....................    BYTE vSocketsAllocated; 
....................    WORD wTXSize, wRXSize; 
....................    PTR_BASE ptrBaseAddress; 
....................    BYTE vMedium; 
....................    #if TCP_ETH_RAM_SIZE > 0 
....................    WORD wCurrentETHAddress = TCP_ETH_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_PIC_RAM_SIZE > 0 
....................    PTR_BASE ptrCurrentPICAddress = TCP_PIC_RAM_BASE_ADDRESS; 
....................    #endif 
....................    #if TCP_SPI_RAM_SIZE > 0 
....................    WORD wCurrentSPIAddress = TCP_SPI_RAM_BASE_ADDRESS; 
....................    #endif 
....................  
....................    #if defined(STACK_CLIENT_MODE) 
....................       // Initialize NextPort to a random value if it is zero (such as after  
....................       // reset on a PIC32 or PIC18 when the static memory initializer is  
....................       // used).  By starting with a random number, we decrease the risk of  
....................       // reusing a port number that was previously used if the user power  
....................       // cycles the device. 
....................       if(NextPort == 0u) 
....................          NextPort = (((WORD)GenerateRandomDWORD()) & 0x07FFu) + LOCAL_PORT_START_NUMBER; 
....................    #endif 
....................  
....................  
....................    // Mark all SYN Queue entries as invalid by zeroing the memory 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................       memset((void*)SYNQueue, 0x00, sizeof(SYNQueue)); 
11C0:  MOVLW  01
11C2:  MOVWF  x87
11C4:  MOVLW  9D
11C6:  MOVWF  x86
11C8:  MOVFF  387,FEA
11CC:  MOVWF  FE9
11CE:  CLRF   00
11D0:  CLRF   02
11D2:  MOVLW  3C
11D4:  MOVWF  01
11D6:  MOVLB  0
11D8:  RCALL  09F2
....................    #endif 
....................     
....................    // Allocate all socket FIFO addresses 
....................    vSocketsAllocated = 0; 
11DA:  MOVLB  3
11DC:  CLRF   x7C
....................    for(i = 0; i < TCP_SOCKET_COUNT; i++) 
11DE:  CLRF   x7B
11E0:  MOVF   x7B,F
11E2:  BTFSS  FD8.2
11E4:  BRA    134C
....................    { 
....................       // Generate all needed sockets of each type (TCP_PURPOSE_*) 
....................       SyncTCBStub(i); 
11E6:  MOVFF  37B,3D0
11EA:  MOVLB  0
11EC:  RCALL  0A0C
....................     
....................       vMedium = TCPSocketInitializer[i].vMemoryMedium; 
11EE:  MOVLB  3
11F0:  MOVF   x7B,W
11F2:  MULLW  06
11F4:  MOVF   FF3,W
11F6:  CLRF   x87
11F8:  MOVWF  x86
11FA:  MOVLW  01
11FC:  ADDWF  x86,W
11FE:  MOVWF  01
1200:  MOVLW  00
1202:  ADDWFC x87,W
1204:  MOVWF  03
1206:  MOVF   01,W
1208:  ADDLW  1C
120A:  MOVWF  FE9
120C:  MOVLW  00
120E:  ADDWFC 03,W
1210:  MOVWF  FEA
1212:  MOVFF  FEF,383
....................       wTXSize = TCPSocketInitializer[i].wTXBufferSize; 
1216:  MOVF   x7B,W
1218:  MULLW  06
121A:  MOVF   FF3,W
121C:  CLRF   x87
121E:  MOVWF  x86
1220:  MOVLW  02
1222:  ADDWF  x86,W
1224:  MOVWF  01
1226:  MOVLW  00
1228:  ADDWFC x87,W
122A:  MOVWF  03
122C:  MOVF   01,W
122E:  ADDLW  1C
1230:  MOVWF  FE9
1232:  MOVLW  00
1234:  ADDWFC 03,W
1236:  MOVWF  FEA
1238:  MOVFF  FEC,37E
123C:  MOVF   FED,F
123E:  MOVFF  FEF,37D
....................       wRXSize = TCPSocketInitializer[i].wRXBufferSize; 
1242:  MOVF   x7B,W
1244:  MULLW  06
1246:  MOVF   FF3,W
1248:  CLRF   x87
124A:  MOVWF  x86
124C:  MOVLW  04
124E:  ADDWF  x86,W
1250:  MOVWF  01
1252:  MOVLW  00
1254:  ADDWFC x87,W
1256:  MOVWF  03
1258:  MOVF   01,W
125A:  ADDLW  1C
125C:  MOVWF  FE9
125E:  MOVLW  00
1260:  ADDWFC 03,W
1262:  MOVWF  FEA
1264:  MOVFF  FEC,380
1268:  MOVF   FED,F
126A:  MOVFF  FEF,37F
....................     
....................       switch(vMedium) 
126E:  MOVF   x83,W
1270:  XORLW  00
1272:  MOVLB  0
1274:  BZ    1278
1276:  BRA    12C6
....................       { 
....................          #if TCP_ETH_RAM_SIZE > 0 
....................          case TCP_ETH_RAM: 
....................             ptrBaseAddress = wCurrentETHAddress; 
1278:  MOVFF  385,382
127C:  MOVFF  384,381
....................             wCurrentETHAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
1280:  MOVLW  27
1282:  MOVLB  3
1284:  ADDWF  x7D,W
1286:  MOVWF  x86
1288:  MOVLW  00
128A:  ADDWFC x7E,W
128C:  MOVWF  x87
128E:  MOVLW  01
1290:  ADDWF  x86,F
1292:  MOVLW  00
1294:  ADDWFC x87,F
1296:  MOVF   x7F,W
1298:  ADDWF  x86,F
129A:  MOVF   x80,W
129C:  ADDWFC x87,F
129E:  MOVLW  01
12A0:  ADDWF  x86,W
12A2:  MOVWF  01
12A4:  MOVLW  00
12A6:  ADDWFC x87,W
12A8:  MOVWF  03
12AA:  MOVF   01,W
12AC:  ADDWF  x84,F
12AE:  MOVF   03,W
12B0:  ADDWFC x85,F
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
.................... #if defined(WF_CS_TRIS) 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + WFGetTCBSize()/*TCP_ETH_RAM_SIZE*/); 
.................... #else 
....................             while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + TCP_ETH_RAM_SIZE); 
12B2:  MOVF   x85,W
12B4:  SUBLW  1E
12B6:  BC    12C2
12B8:  XORLW  FF
12BA:  BNZ   12B2
12BC:  MOVF   x84,W
12BE:  SUBLW  FC
12C0:  BNC   12B2
.................... #endif 
....................             break; 
12C2:  BRA    12CA
12C4:  MOVLB  0
....................          #endif 
....................              
....................          #if TCP_PIC_RAM_SIZE > 0 
....................          case TCP_PIC_RAM: 
....................             ptrBaseAddress = ptrCurrentPICAddress; 
....................             ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(ptrCurrentPICAddress > TCP_PIC_RAM_BASE_ADDRESS + TCP_PIC_RAM_SIZE); 
....................             break; 
....................          #endif 
....................              
....................          #if TCP_SPI_RAM_SIZE > 0 
....................          case TCP_SPI_RAM: 
....................             ptrBaseAddress = wCurrentSPIAddress; 
....................             wCurrentSPIAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1; 
....................             // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us. 
....................             // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in TCPIPConfig.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken. 
....................             while(wCurrentSPIAddress > TCP_SPI_RAM_BASE_ADDRESS + TCP_SPI_RAM_SIZE); 
....................             break; 
....................          #endif 
....................           
....................          default: 
....................             while(1); // Undefined allocation medium.  Go fix your TCPIPConfig.h TCP memory allocations. 
12C6:  BRA    12C6
12C8:  MOVLB  3
....................       } 
....................     
....................       MyTCBStub.vMemoryMedium = vMedium; 
12CA:  MOVFF  383,1F4
....................       MyTCBStub.bufferTxStart   = ptrBaseAddress + sizeof(TCB); 
12CE:  MOVLW  27
12D0:  ADDWF  x81,W
12D2:  MOVLB  1
12D4:  MOVWF  xD9
12D6:  MOVLW  00
12D8:  MOVLB  3
12DA:  ADDWFC x82,W
12DC:  MOVLB  1
12DE:  MOVWF  xDA
....................       MyTCBStub.bufferRxStart   = MyTCBStub.bufferTxStart + wTXSize + 1; 
12E0:  MOVLB  3
12E2:  MOVF   x7D,W
12E4:  MOVLB  1
12E6:  ADDWF  xD9,W
12E8:  MOVLB  3
12EA:  MOVWF  x86
12EC:  MOVF   x7E,W
12EE:  MOVLB  1
12F0:  ADDWFC xDA,W
12F2:  MOVLB  3
12F4:  MOVWF  x87
12F6:  MOVLW  01
12F8:  ADDWF  x86,W
12FA:  MOVLB  1
12FC:  MOVWF  xDB
12FE:  MOVLW  00
1300:  MOVLB  3
1302:  ADDWFC x87,W
1304:  MOVLB  1
1306:  MOVWF  xDC
....................       MyTCBStub.bufferEnd      = MyTCBStub.bufferRxStart + wRXSize; 
1308:  MOVLB  3
130A:  MOVF   x7F,W
130C:  MOVLB  1
130E:  ADDWF  xDB,W
1310:  MOVWF  xDD
1312:  MOVLB  3
1314:  MOVF   x80,W
1316:  MOVLB  1
1318:  ADDWFC xDC,W
131A:  MOVWF  xDE
....................       MyTCBStub.smState      = TCP_CLOSED; 
131C:  MOVLW  0D
131E:  MOVWF  xEF
....................       MyTCBStub.Flags.bServer   = FALSE; 
1320:  BCF    xF0.3
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................       #endif       
....................  
....................       SyncTCB(); 
1322:  MOVLB  0
1324:  RCALL  100C
....................       MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose; 
1326:  MOVLB  3
1328:  MOVF   x7B,W
132A:  MULLW  06
132C:  MOVF   FF3,W
132E:  CLRF   x87
1330:  MOVWF  x86
1332:  MOVLW  1C
1334:  ADDWF  x86,W
1336:  MOVWF  FE9
1338:  MOVLW  00
133A:  ADDWFC x87,W
133C:  MOVWF  FEA
133E:  MOVFF  FEF,19B
....................       CloseSocket(); 
1342:  MOVLB  0
1344:  RCALL  10E4
1346:  MOVLB  3
1348:  INCF   x7B,F
134A:  BRA    11E0
....................    } 
134C:  MOVLB  0
134E:  GOTO   14F2 (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Connection Management Functions 
....................   ***************************************************************************/ 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
....................      
....................   Summary: 
....................     Opens a TCP socket for listening or as a client. 
....................  
....................   Description: 
....................     Provides a unified method for opening TCP sockets. This function can 
....................     open both client and server sockets. For client sockets, it can accept 
....................     a host name string to query in DNS, an IP address as a string, an IP 
....................     address in binary form, or a previously resolved NODE_INFO structure 
....................     containing the remote IP address and associated MAC address. When a 
....................     host name or IP address only is provided, the TCP module will 
....................     internally perform the necessary DNS and/or ARP resolution steps before 
....................     reporting that the TCP socket is connected (via a call to 
....................     TCPISConnected returning TRUE). Server sockets ignore this destination 
....................     parameter and listen only on the indicated port. 
....................      
....................     The vSocketPurpose field allows sockets to be opened with varying 
....................     buffer size parameters and memory storage mediums. This field 
....................     corresponds to pre-defined sockets allocated in the 
....................     TCPSocketInitializer[] array in TCPIPConfig.h. The TCPIPConfig.h file 
....................     can be edited using the TCP/IP Configuration Wizard. 
....................      
....................     Sockets are statically allocated on boot, but can be claimed with this 
....................     \function and freed using TCPDisconnect or TCPClose (for client 
....................     sockets). Server sockets can be freed using TCPClose only (calls to 
....................     TCPDisconnect will return server sockets to the listening state, 
....................     allowing reuse). 
....................  
....................   Conditions: 
....................     TCP is initialized. 
....................  
....................   Input: 
....................     dwRemoteHost -     For client sockets only. Provide a pointer to a 
....................                        null\-terminated string of the remote host name (ex\: 
....................                        "www.microchip.com" or "192.168.1.123"), a literal 
....................                        destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR 
....................                        data type), or a pointer to a NODE_INFO structure 
....................                        with the remote IP address and remote node or gateway 
....................                        MAC address specified. If a string is provided, note 
....................                        that it must be statically allocated in memory and 
....................                        cannot be modified or deallocated until 
....................                        TCPIsConnected returns TRUE.<p />This parameter is 
....................                        ignored for server sockets. 
....................     vRemoteHostType -  Any one of the following flags to identify the 
....................                        meaning of the dwRemoteHost parameter\: 
....................                        * TCP_OPEN_SERVER &#45; Open a server socket and 
....................                          ignore the dwRemoteHost parameter. 
....................                        * TCP_OPEN_RAM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a RAM array. Ex\: 
....................                          "www.microchip.com" or "192.168.0.123" (BYTE&#42; 
....................                          type) 
....................                        * TCP_OPEN_ROM_HOST &#45; Open a client socket and 
....................                          connect it to a remote host who's name is stored as a 
....................                          null terminated string in a literal string or ROM 
....................                          array. Ex\: "www.microchip.com" or "192.168.0.123" 
....................                          (ROM BYTE&#42; type) 
....................                        * TCP_OPEN_IP_ADDRESS &#45; Open a client socket and 
....................                          connect it to a remote IP address. Ex\: 0x7B01A8C0 
....................                          for 192.168.1.123 (DWORD type). Note that the byte 
....................                          ordering is big endian. 
....................                        * TCP_OPEN_NODE_INFO &#45; Open a client socket and 
....................                          connect it to a remote IP and MAC addresses pair 
....................                          stored in a NODE_INFO structure. dwRemoteHost must be 
....................                          a pointer to the NODE_INFO structure. This option is 
....................                          provided for backwards compatibility with 
....................                          applications built against prior stack versions that 
....................                          only implemented the TCPConnect() function. It can 
....................                          also be used to skip DNS and ARP resolution steps if 
....................                          connecting to a remote node which you've already 
....................                          connected to and have cached addresses for. 
....................     wPort -            TCP port to listen on or connect to\: 
....................                        * Client sockets &#45; the remote TCP port to which a 
....................                          connection should be made. The local port for client 
....................                          sockets will be automatically picked by the TCP 
....................                          module. 
....................                        * Server sockets &#45; the local TCP port on which to 
....................                          listen for connections. 
....................     vSocketPurpose -   Any of the TCP_PURPOSE_* constants defined in 
....................                        TCPIPConfig.h or the TCPIPConfig utility (see 
....................                        TCPSocketInitializer[] array). 
....................  
....................   Return Values: 
....................     INVALID_SOCKET -  No sockets of the specified type were available to be 
....................                       opened. 
....................     Otherwise -       A TCP_SOCKET handle. Save this handle and use it when 
....................                       calling all other TCP APIs. 
....................  
....................   Remarks: 
....................     This function replaces the old TCPConnect and TCPListen functions. 
....................      
....................     If TCP_OPEN_RAM_HOST or TCP_OPEN_ROM_HOST are used for the destination 
....................     type, the DNS client module must also be enabled (STACK_USE_DNS must be 
....................     defined in TCPIPConfig.h). 
....................  
....................   Example: 
....................     \ \  
....................     <code> 
....................     // Open a server socket 
....................     skt = TCPOpen(NULL, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER); 
....................      
....................     // Open a client socket to www.microchip.com 
....................     // The double cast here prevents compiler warnings 
....................     skt = TCPOpen((DWORD)(PTR_BASE)"www.microchip.com", 
....................                     TCP_OPEN_ROM_HOST, 80, TCP_PURPOSE_DEFAULT); 
....................      
....................     // Reopen a client socket without repeating DNS or ARP 
....................     SOCKET_INFO cache = TCPGetSocketInfo(skt);  // Call with the old socket 
....................     skt = TCPOpen((DWORD)(PTR_BASE)&amp;cache.remote, TCP_OPEN_NODE_INFO, 
....................                     cache.remotePort.Val, TCP_PURPOSE_DEFAULT); 
....................     </code>                                                     
....................   *****************************************************************************/ 
.................... TCP_SOCKET TCPOpen(DWORD dwRemoteHost, BYTE vRemoteHostType, WORD wPort, BYTE vSocketPurpose) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................  
....................    // Find an available socket that matches the specified socket type 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
13AE:  MOVLB  3
13B0:  CLRF   x86
13B2:  MOVF   x86,F
13B4:  BNZ   141C
....................    { 
....................       SyncTCBStub(hTCP); 
13B6:  MOVFF  386,3D0
13BA:  MOVLB  0
13BC:  CALL   0A0C
....................  
....................       // Sockets that are in use will be in a non-closed state 
....................       if(MyTCBStub.smState != TCP_CLOSED) 
13C0:  MOVLB  1
13C2:  MOVF   xEF,W
13C4:  SUBLW  0D
13C6:  BZ    13CA
....................          continue; 
13C8:  BRA    1416
....................  
....................       SyncTCB(); 
13CA:  MOVLB  0
13CC:  RCALL  100C
....................  
....................       // See if this socket matches the desired type 
....................       if(MyTCB.vSocketPurpose != vSocketPurpose) 
13CE:  MOVLB  3
13D0:  MOVF   x85,W
13D2:  MOVLB  1
13D4:  SUBWF  x9B,W
13D6:  BZ    13DA
....................          continue; 
13D8:  BRA    1416
....................  
....................       // Start out assuming worst case Maximum Segment Size (changes when MSS  
....................       // option is received from remote node) 
....................       MyTCB.wRemoteMSS = 536; 
13DA:  MOVLW  02
13DC:  MOVWF  x99
13DE:  MOVLW  18
13E0:  MOVWF  x98
....................  
....................       // See if this is a server socket 
....................       if(vRemoteHostType == TCP_OPEN_SERVER) 
13E2:  MOVLB  3
13E4:  MOVF   x82,F
13E6:  BNZ   1404
....................       { 
....................          MyTCB.localPort.Val = wPort; 
13E8:  MOVFF  384,186
13EC:  MOVFF  383,185
....................          MyTCBStub.Flags.bServer = TRUE; 
13F0:  MOVLB  1
13F2:  BSF    xF0.3
....................          MyTCBStub.smState = TCP_LISTEN; 
13F4:  MOVLW  04
13F6:  MOVWF  xEF
....................          MyTCBStub.remoteHash.Val = wPort; 
13F8:  MOVFF  384,1F3
13FC:  MOVFF  383,1F2
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          MyTCB.localSSLPort.Val = 0; 
....................          #endif 
....................       } 
1400:  BRA    140C
1402:  MOVLB  3
....................       // Handle all the client mode socket types 
....................       else 
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          { 
....................             // Each new socket that is opened by this node, gets the  
....................             // next sequential local port number. 
....................             if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER) 
....................                NextPort = LOCAL_PORT_START_NUMBER; 
....................              
....................             // Set the non-zero TCB fields 
....................             MyTCB.localPort.Val = NextPort++; 
....................             MyTCB.remotePort.Val = wPort; 
....................     
....................             // Flag to start the DNS, ARP, SYN processes 
....................             MyTCBStub.eventTime = TickGet(); 
....................             MyTCBStub.Flags.bTimerEnabled = 1; 
....................     
....................             switch(vRemoteHostType) 
....................             { 
....................                #if defined(STACK_USE_DNS) 
....................                case TCP_OPEN_RAM_HOST: 
....................                case TCP_OPEN_ROM_HOST: 
....................                   MyTCB.remote.dwRemoteHost = dwRemoteHost; 
....................                   MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST); 
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
....................                   break; 
....................                #endif 
....................        
....................                case TCP_OPEN_IP_ADDRESS: 
....................                   // dwRemoteHost is a literal IP address.  This  
....................                   // doesn't need DNS and can skip directly to the  
....................                   // Gateway ARPing step. 
....................                   MyTCBStub.remoteHash.Val = (((DWORD_VAL*)&dwRemoteHost)->w[1]+((DWORD_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val; 
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost; 
....................                   MyTCB.retryCount = 0; 
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
....................                   break; 
....................        
....................                case TCP_OPEN_NODE_INFO: 
....................                   MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val; 
....................                   memcpy((void*)(BYTE*)&MyTCB.remote, (void*)(BYTE*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO)); 
....................                   MyTCBStub.smState = TCP_SYN_SENT; 
....................                   SendTCP(SYN, SENDTCP_RESET_TIMERS); 
....................                   break; 
....................             } 
....................          }       
....................          #else 
....................          { 
....................             return INVALID_SOCKET; 
1404:  MOVLW  FE
1406:  MOVWF  01
1408:  BRA    1420
140A:  MOVLB  1
....................          }    
....................          #endif 
....................       } 
....................        
....................       return hTCP;       
140C:  MOVLB  3
140E:  MOVFF  386,01
1412:  BRA    1420
1414:  MOVLB  1
1416:  MOVLB  3
1418:  INCF   x86,F
141A:  BRA    13B2
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    return INVALID_SOCKET; 
141C:  MOVLW  FE
141E:  MOVWF  01
1420:  MOVLB  0
1422:  GOTO   1470 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPWasReset(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Self-clearing semaphore inidicating socket reset. 
....................  
....................   Description: 
....................    This function is a self-clearing semaphore indicating whether or not 
....................    a socket has been disconnected since the previous call.  This function 
....................    works for all possible disconnections: a call to TCPDisconnect, a FIN  
....................    from the remote node, or an acknowledgement timeout caused by the loss 
....................    of a network link.  It also returns TRUE after the first call to TCPInit. 
....................    Applications should use this function to reset their state machines. 
....................     
....................    This function was added due to the possibility of an error when relying 
....................    on TCPIsConnected returing FALSE to check for a condition requiring a 
....................    state machine reset.  If a socket is closed (due to a FIN ACK) and then 
....................    immediately reopened (due to a the arrival of a new SYN) in the same 
....................    cycle of the stack, calls to TCPIsConnected by the application will  
....................    never return FALSE even though the socket has been disconnected.  This  
....................    can cause errors for protocols such as HTTP in which a client will  
....................    immediately open a new connection upon closing of a prior one.  Relying 
....................    on this function instead allows applications to trap those conditions  
....................    and properly reset their internal state for the new connection. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has been disconnected since the previous call. 
....................      FALSE - The socket has not been disconnected since the previous call. 
....................   ***************************************************************************/ 
.................... BOOL TCPWasReset(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return TRUE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.Flags.bSocketReset) 
....................    { 
....................       MyTCBStub.Flags.bSocketReset = 0; 
....................       return TRUE; 
....................    }    
....................     
....................    return FALSE; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsConnected(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a socket has an established connection. 
....................  
....................   Description: 
....................    This function determines if a socket has an established connection to  
....................    a remote node.  Call this function after calling TCPOpen to determine  
....................    when the connection is set up and ready for use.  This function was  
....................    historically used to check for disconnections, but TCPWasReset is now a 
....................    more appropriate solution.  
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Return Values: 
....................      TRUE - The socket has an established connection to a remote node. 
....................      FALSE - The socket is not currently connected. 
....................  
....................   Remarks: 
....................    A socket is said to be connected only if it is in the TCP_ESTABLISHED 
....................    state.  Sockets in the process of opening or closing will return FALSE. 
....................   ***************************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
7138:  MOVLB  3
713A:  MOVF   x7B,W
713C:  SUBLW  00
713E:  BC    7146
....................     { 
....................         return FALSE; 
7140:  MOVLW  00
7142:  MOVWF  01
7144:  BRA    7162
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
7146:  MOVFF  37B,3D0
714A:  MOVLB  0
714C:  CALL   0A0C
....................    return (MyTCBStub.smState == TCP_ESTABLISHED); 
7150:  MOVLB  1
7152:  MOVF   xEF,W
7154:  SUBLW  07
7156:  BZ    715C
7158:  MOVLW  00
715A:  BRA    715E
715C:  MOVLW  01
715E:  MOVWF  01
7160:  MOVLB  3
7162:  MOVLB  0
7164:  GOTO   7C46 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDisconnect(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket. 
....................  
....................   Description: 
....................    This function closes a connection to a remote node by sending a FIN (if  
....................    currently connected). 
....................     
....................    The function can be called a second time to force a socket closed by  
....................    sending a RST packet.  This is useful when the application knows that  
....................    the remote node will not send an ACK (if it has crashed or lost its link), 
....................    or when the application needs to reuse the socket immediately regardless 
....................    of whether or not the remote node would like to transmit more data before 
....................    closing. 
....................     
....................    For client mode sockets, upon return, the hTCP handle is relinquished to  
....................    the TCP/IP stack and must no longer be used by the application (except for  
....................    an immediate subsequent call to TCPDisconnect() to force a RST  
....................    transmission, if needed).   
....................     
....................    For server mode sockets, upon return, the hTCP handle is NOT relinquished  
....................    to the TCP/IP stack.  After closing, the socket returns to the listening  
....................    state allowing future connection requests to be serviced.  This leaves the  
....................    hTCP handle in a valid state and must be retained for future operations on  
....................    the socket.  If you want to close the server and relinquish the socket back  
....................    to the TCP/IP stack, call the TCPClose() API instead of TCPDisconnect(). 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle of the socket to disconnect. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted 
....................    first to allow the SSL session to be resumed at a later time. 
....................   ***************************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
3EC6:  MOVLB  3
3EC8:  MOVF   xA0,W
3ECA:  SUBLW  00
3ECC:  BC    3ED0
....................     { 
....................         return; 
3ECE:  BRA    3FAC
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
3ED0:  MOVFF  3A0,3D0
3ED4:  MOVLB  0
3ED6:  CALL   0A0C
....................  
....................    // Delete all data in the RX FIFO 
....................    // In this stack's API, the application TCP handle is  
....................    // immediately invalid after calling this function, so there  
....................    // is no longer any way to receive data from the TCP RX FIFO,  
....................    // even though the data is still there.  Leaving the data there  
....................    // could interfere with the remote node sending us a FIN if our 
....................    // RX window is zero 
....................    MyTCBStub.rxTail = MyTCBStub.rxHead; 
3EDA:  MOVFF  1E4,1E6
3EDE:  MOVFF  1E3,1E5
....................  
....................    switch(MyTCBStub.smState) 
3EE2:  MOVLB  1
3EE4:  MOVF   xEF,W
3EE6:  XORLW  00
3EE8:  MOVLB  0
3EEA:  BZ    3F16
3EEC:  XORLW  02
3EEE:  BZ    3F16
3EF0:  XORLW  01
3EF2:  BZ    3F16
3EF4:  XORLW  06
3EF6:  BZ    3F16
3EF8:  XORLW  03
3EFA:  BZ    3F1C
3EFC:  XORLW  01
3EFE:  BZ    3F1C
3F00:  XORLW  0C
3F02:  BZ    3F56
3F04:  XORLW  05
3F06:  BZ    3F90
3F08:  XORLW  06
3F0A:  BZ    3F9A
3F0C:  XORLW  01
3F0E:  BZ    3F9A
3F10:  XORLW  05
3F12:  BZ    3F9A
3F14:  BRA    3F9A
....................    { 
....................       #if defined(STACK_CLIENT_MODE) && defined(STACK_USE_DNS) 
....................       case TCP_DNS_RESOLVE: 
....................          DNSEndUsage();   // Release the DNS module, since the user is aborting 
....................          CloseSocket(); 
....................          break; 
....................       #endif 
....................  
....................       case TCP_GET_DNS_MODULE: 
....................       case TCP_GATEWAY_SEND_ARP: 
....................       case TCP_GATEWAY_GET_ARP: 
....................       case TCP_SYN_SENT: 
....................          CloseSocket(); 
3F16:  CALL   10E4
....................          break; 
3F1A:  BRA    3FAA
....................  
....................       case TCP_SYN_RECEIVED: 
....................       case TCP_ESTABLISHED: 
....................          #if defined(STACK_USE_SSL) 
....................          // When disconnecting SSL sockets, send a close_notify so we can resume later 
....................          if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          { 
....................             // Flush pending data and send close_notify 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, SSL_ALERT_CLOSE_NOTIFY); 
....................          } 
....................          #endif 
....................  
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
3F1C:  MOVLW  11
3F1E:  MOVLB  3
3F20:  MOVWF  xE6
3F22:  MOVLW  01
3F24:  MOVWF  xE7
3F26:  MOVLB  0
3F28:  RCALL  3870
....................             if(MyTCB.remoteWindow == 0u) 
3F2A:  MOVLB  1
3F2C:  MOVF   x87,F
3F2E:  BNZ   3F36
3F30:  MOVF   x88,F
3F32:  BNZ   3F36
....................                break; 
3F34:  BRA    3F4E
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
3F36:  MOVF   x81,W
3F38:  SUBWF  xDF,W
3F3A:  BTFSC  FD8.2
3F3C:  BRA    3F42
3F3E:  MOVLB  0
3F40:  BRA    3F1C
3F42:  MOVF   x82,W
3F44:  SUBWF  xE0,W
3F46:  BTFSC  FD8.2
3F48:  BRA    3F4E
3F4A:  MOVLB  0
3F4C:  BRA    3F1C
....................           
....................          MyTCBStub.smState = TCP_FIN_WAIT_1; 
3F4E:  MOVLW  08
3F50:  MOVWF  xEF
....................          break; 
3F52:  MOVLB  0
3F54:  BRA    3FAA
....................  
....................       case TCP_CLOSE_WAIT: 
....................          // Send the FIN.  This is done in a loop to ensure that if we have  
....................          // more data wating in the TX FIFO than can be sent in a single  
....................          // packet (due to the remote Max Segment Size packet size limit),  
....................          // we will keep generating more packets until either all data gets  
....................          // transmitted or the remote node's receive window fills up. 
....................          do 
....................          { 
....................             SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
3F56:  MOVLW  11
3F58:  MOVLB  3
3F5A:  MOVWF  xE6
3F5C:  MOVLW  01
3F5E:  MOVWF  xE7
3F60:  MOVLB  0
3F62:  RCALL  3870
....................             if(MyTCB.remoteWindow == 0u) 
3F64:  MOVLB  1
3F66:  MOVF   x87,F
3F68:  BNZ   3F70
3F6A:  MOVF   x88,F
3F6C:  BNZ   3F70
....................                break; 
3F6E:  BRA    3F88
....................          } while(MyTCBStub.txHead != MyTCB.txUnackedTail); 
3F70:  MOVF   x81,W
3F72:  SUBWF  xDF,W
3F74:  BTFSC  FD8.2
3F76:  BRA    3F7C
3F78:  MOVLB  0
3F7A:  BRA    3F56
3F7C:  MOVF   x82,W
3F7E:  SUBWF  xE0,W
3F80:  BTFSC  FD8.2
3F82:  BRA    3F88
3F84:  MOVLB  0
3F86:  BRA    3F56
....................  
....................          MyTCBStub.smState = TCP_LAST_ACK; 
3F88:  MOVLW  0C
3F8A:  MOVWF  xEF
....................          break; 
3F8C:  MOVLB  0
3F8E:  BRA    3FAA
....................           
....................       // These states are all already closed or don't need explicit disconnecting -- they will disconnect by themselves after a while 
....................       //case TCP_CLOSED: 
....................       //case TCP_LISTEN: 
....................       //case TCP_CLOSING: 
....................       //case TCP_TIME_WAIT: 
....................       //   return; 
....................  
....................       case TCP_CLOSED_BUT_RESERVED: 
....................          MyTCBStub.smState = TCP_CLOSED; 
3F90:  MOVLW  0D
3F92:  MOVLB  1
3F94:  MOVWF  xEF
....................          break; 
3F96:  MOVLB  0
3F98:  BRA    3FAA
....................  
....................       // These states will close themselves after some delay, however,  
....................       // this is handled so that the user can call TCPDisconnect()  
....................       // twice to immediately close a socket (using an RST) without  
....................       // having to get an ACK back from the remote node.  This is  
....................       // great for instance when the application determines that  
....................       // the remote node has been physically disconnected and  
....................       // already knows that no ACK will be returned.  Alternatively,  
....................       // if the application needs to immediately reuse the socket  
....................       // regardless of what the other node's state is in (half open). 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_LAST_ACK: 
....................       default: 
....................          SendTCP(RST | ACK, 0); 
3F9A:  MOVLW  14
3F9C:  MOVLB  3
3F9E:  MOVWF  xE6
3FA0:  CLRF   xE7
3FA2:  MOVLB  0
3FA4:  RCALL  3870
....................          CloseSocket(); 
3FA6:  CALL   10E4
....................          break; 
3FAA:  MOVLB  3
....................    } 
3FAC:  MOVLB  0
3FAE:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPClose(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles. 
....................  
....................   Description: 
....................    Disconnects an open socket and destroys the socket handle, including server  
....................    mode socket handles.  This function performs identically to the  
....................    TCPDisconnect() function, except that both client and server mode socket  
....................    handles are relinquished to the TCP/IP stack upon return. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    hTCP - Handle to the socket to disconnect and close. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPClose(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
739E:  MOVLB  3
73A0:  MOVF   x7B,W
73A2:  SUBLW  00
73A4:  BC    73A8
....................     { 
....................         return; 
73A6:  BRA    73C2
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
73A8:  MOVFF  37B,3D0
73AC:  MOVLB  0
73AE:  CALL   0A0C
....................    MyTCBStub.Flags.bServer = FALSE; 
73B2:  MOVLB  1
73B4:  BCF    xF0.3
....................    TCPDisconnect(hTCP); 
73B6:  MOVFF  37B,3A0
73BA:  MOVLB  0
73BC:  CALL   3EC6
73C0:  MOVLB  3
73C2:  MOVLB  0
73C4:  GOTO   7CC0 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Obtains information about a currently open socket. 
....................  
....................   Description: 
....................    Returns the SOCKET_INFO structure associated with this socket.  This  
....................    contains the NODE_INFO structure with IP and MAC address (or gateway 
....................    MAC) and the remote port. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The SOCKET_INFO structure associated with this socket.  This structure is  
....................    allocated statically by the function and is valid only until the next  
....................    time TCPGetRemoteInfo() is called. 
....................   ***************************************************************************/ 
.................... SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP) 
.................... { 
....................    static SOCKET_INFO   RemoteInfo; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................    memcpy((void*)&RemoteInfo.remote, (void*)&MyTCB.remote, sizeof(NODE_INFO)); 
....................    RemoteInfo.remotePort.Val = MyTCB.remotePort.Val; 
....................  
....................    return &RemoteInfo; 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Transmit Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPFlush(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Immediately transmits all pending TX data. 
....................  
....................   Description: 
....................    This function immediately transmits all pending TX data with a PSH  
....................    flag.  If this function is not called, data will automatically be sent 
....................    when either a) the TX buffer is half full or b) the  
....................    TCP_AUTO_TRANSMIT_TIMEOUT_VAL (default: 40ms) has elapsed. 
....................  
....................   Precondition: 
....................    TCP is initialized and the socket is connected. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose data is to be transmitted. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    SSL application data is automatically flushed, so this function has  
....................    no effect for SSL sockets. 
....................   ***************************************************************************/ 
.................... void TCPFlush(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
77A0:  MOVLB  3
77A2:  MOVF   x85,W
77A4:  SUBLW  00
77A6:  BC    77AA
....................     { 
....................         return; 
77A8:  BRA    77DA
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
77AA:  MOVFF  385,3D0
77AE:  MOVLB  0
77B0:  CALL   0A0C
....................    SyncTCB(); 
77B4:  CALL   100C
....................  
....................    // NOTE: Pending SSL data will NOT be transferred here 
....................  
....................    if(MyTCBStub.txHead != MyTCB.txUnackedTail) 
77B8:  MOVLB  1
77BA:  MOVF   x81,W
77BC:  SUBWF  xDF,W
77BE:  BNZ   77C6
77C0:  MOVF   x82,W
77C2:  SUBWF  xE0,W
77C4:  BZ    77D8
....................    { 
....................       // Send the TCP segment with all unacked bytes 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
77C6:  MOVLW  10
77C8:  MOVLB  3
77CA:  MOVWF  xE6
77CC:  MOVLW  01
77CE:  MOVWF  xE7
77D0:  MOVLB  0
77D2:  CALL   3870
77D6:  MOVLB  1
77D8:  MOVLB  3
....................    } 
77DA:  MOVLB  0
77DC:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPIsPutReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how much free space is available in the TCP TX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be written to the  
....................    TCP TX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to transmit 
....................    more data. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be written in the TCP TX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsPutReady(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
76F0:  MOVLB  3
76F2:  MOVF   x85,W
76F4:  SUBLW  00
76F6:  BC    7700
....................     { 
....................         return 0; 
76F8:  MOVLW  00
76FA:  MOVWF  01
76FC:  MOVWF  02
76FE:  BRA    779A
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
7700:  MOVFF  385,3D0
7704:  MOVLB  0
7706:  CALL   0A0C
....................  
....................    i = MyTCBStub.smState; 
770A:  MOVFF  1EF,386
....................  
....................    // Unconnected sockets shouldn't be transmitting anything. 
....................    if(!( (i == (BYTE)TCP_ESTABLISHED) || (i == (BYTE)TCP_CLOSE_WAIT) )) 
770E:  MOVLB  3
7710:  MOVF   x86,W
7712:  SUBLW  07
7714:  BZ    7724
7716:  MOVF   x86,W
7718:  SUBLW  0B
771A:  BZ    7724
....................       return 0; 
771C:  MOVLW  00
771E:  MOVWF  01
7720:  MOVWF  02
7722:  BRA    779A
....................  
....................    // Calculate the free space in this socket's TX FIFO 
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    {// Use sslTxHead as the head pointer when SSL is active 
....................       WORD rem; 
....................        
....................       // Find out raw free space 
....................       if(MyTCBStub.sslTxHead >= MyTCBStub.txTail) 
....................          rem = (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.sslTxHead - MyTCBStub.txTail); 
....................       else 
....................          rem = MyTCBStub.txTail - MyTCBStub.sslTxHead - 1; 
....................           
....................       // Reserve space for a new MAC and header 
....................       if(rem > 22u) 
....................          return rem - 22; 
....................       else 
....................          return 0; 
....................    } 
....................    #endif 
....................     
....................    if(MyTCBStub.txHead >= MyTCBStub.txTail) 
7724:  MOVLB  1
7726:  MOVF   xE2,W
7728:  SUBWF  xE0,W
772A:  BNC   7776
772C:  BNZ   7734
772E:  MOVF   xE1,W
7730:  SUBWF  xDF,W
7732:  BNC   7776
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail); 
7734:  MOVF   xD9,W
7736:  SUBWF  xDB,W
7738:  MOVLB  3
773A:  MOVWF  x87
773C:  MOVLB  1
773E:  MOVF   xDA,W
7740:  SUBWFB xDC,W
7742:  MOVLB  3
7744:  MOVWF  x88
7746:  MOVLW  01
7748:  SUBWF  x87,F
774A:  MOVLW  00
774C:  SUBWFB x88,F
774E:  MOVLB  1
7750:  MOVF   xE1,W
7752:  SUBWF  xDF,W
7754:  MOVWF  00
7756:  MOVF   xE2,W
7758:  SUBWFB xE0,W
775A:  MOVWF  03
775C:  MOVF   00,W
775E:  MOVLB  3
7760:  SUBWF  x87,W
7762:  MOVWF  00
7764:  MOVF   03,W
7766:  SUBWFB x88,W
7768:  MOVWF  03
776A:  MOVFF  00,01
776E:  MOVWF  02
7770:  BRA    779A
7772:  BRA    779A
7774:  MOVLB  1
....................    else 
....................       return MyTCBStub.txTail - MyTCBStub.txHead - 1; 
7776:  MOVF   xDF,W
7778:  SUBWF  xE1,W
777A:  MOVLB  3
777C:  MOVWF  x87
777E:  MOVLB  1
7780:  MOVF   xE0,W
7782:  SUBWFB xE2,W
7784:  MOVLB  3
7786:  MOVWF  x88
7788:  MOVLW  01
778A:  SUBWF  x87,W
778C:  MOVWF  00
778E:  MOVLW  00
7790:  SUBWFB x88,W
7792:  MOVWF  03
7794:  MOVFF  00,01
7798:  MOVWF  02
779A:  MOVLB  0
779C:  GOTO   77FC (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
....................  
....................   Description: 
....................    Writes a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    byte - The byte to write. 
....................  
....................   Return Values: 
....................    TRUE - The byte was written to the transmit buffer. 
....................    FALSE - The transmit buffer was full, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET hTCP, BYTE byte) 
.................... { 
....................    WORD wFreeTXSpace; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
77DE:  MOVLB  3
77E0:  MOVF   x81,W
77E2:  SUBLW  00
77E4:  BC    77EC
....................     { 
....................         return 0; 
77E6:  MOVLW  00
77E8:  MOVWF  01
77EA:  BRA    78FC
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
77EC:  MOVFF  381,3D0
77F0:  MOVLB  0
77F2:  CALL   0A0C
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
77F6:  MOVFF  381,385
77FA:  BRA    76F0
77FC:  MOVFF  02,384
7800:  MOVFF  01,383
....................    if(wFreeTXSpace == 0u) 
7804:  MOVLB  3
7806:  MOVF   x83,F
7808:  BNZ   7816
780A:  MOVF   x84,F
780C:  BNZ   7816
....................       return FALSE; 
780E:  MOVLW  00
7810:  MOVWF  01
7812:  BRA    78FC
7814:  BRA    7828
....................    else if(wFreeTXSpace == 1u) // About to run out of space, lets transmit so the remote node might send an ACK back faster 
7816:  DECFSZ x83,W
7818:  BRA    7828
781A:  MOVF   x84,F
781C:  BNZ   7828
....................       TCPFlush(hTCP);    
781E:  MOVFF  381,385
7822:  MOVLB  0
7824:  RCALL  77A0
7826:  MOVLB  3
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
7828:  MOVLB  1
782A:  BTFSC  xF1.0
782C:  BRA    7872
782E:  MOVF   xD9,W
7830:  SUBWF  xDB,W
7832:  MOVLB  3
7834:  MOVWF  x85
7836:  MOVLB  1
7838:  MOVF   xDA,W
783A:  SUBWFB xDC,W
783C:  MOVLB  3
783E:  MOVWF  x86
7840:  BCF    FD8.0
7842:  RRCF   x86,W
7844:  MOVWF  03
7846:  RRCF   x85,W
7848:  MOVWF  02
784A:  MOVWF  01
784C:  MOVF   x84,W
784E:  SUBWF  03,W
7850:  BTFSC  FD8.0
7852:  BRA    7858
7854:  MOVLB  1
7856:  BRA    7872
7858:  BNZ   7866
785A:  MOVF   x83,W
785C:  SUBWF  01,W
785E:  BTFSC  FD8.0
7860:  BRA    7866
7862:  MOVLB  1
7864:  BRA    7872
....................    { 
....................       TCPFlush(hTCP);    
7866:  MOVFF  381,385
786A:  MOVLB  0
786C:  RCALL  77A0
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
786E:  MOVLB  1
7870:  BSF    xF1.0
....................    } 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    else 
....................    { 
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
....................       if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    #else 
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte)); 
7872:  MOVLW  03
7874:  MOVLB  3
7876:  MOVWF  x86
7878:  MOVLW  82
787A:  MOVWF  x85
787C:  MOVFF  1E0,418
7880:  MOVFF  1DF,417
7884:  MOVFF  1F4,419
7888:  MOVFF  386,41B
788C:  MOVFF  FE8,41A
7890:  MOVLW  01
7892:  MOVLB  4
7894:  MOVWF  x1C
7896:  CLRF   x1E
7898:  MOVWF  x1D
789A:  MOVLB  0
789C:  CALL   0F26
....................    if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
78A0:  MOVLB  1
78A2:  INCF   xDF,F
78A4:  BTFSC  FD8.2
78A6:  INCF   xE0,F
78A8:  MOVF   xDC,W
78AA:  SUBWF  xE0,W
78AC:  BNC   78BE
78AE:  BNZ   78B6
78B0:  MOVF   xDB,W
78B2:  SUBWF  xDF,W
78B4:  BNC   78BE
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
78B6:  MOVFF  1DA,1E0
78BA:  MOVFF  1D9,1DF
....................    #endif 
....................     
....................  
....................    // Send the last byte as a separate packet (likely will make the remote node send back ACK faster) 
....................    if(wFreeTXSpace == 1u) 
78BE:  MOVLB  3
78C0:  DECFSZ x83,W
78C2:  BRA    78D2
78C4:  MOVF   x84,F
78C6:  BNZ   78D2
....................    { 
....................       TCPFlush(hTCP); 
78C8:  MOVFF  381,385
78CC:  MOVLB  0
78CE:  RCALL  77A0
....................    } 
78D0:  BRA    78F6
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
78D2:  MOVLB  1
78D4:  BTFSC  xF0.5
78D6:  BRA    78F4
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
78D8:  BSF    xF0.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
78DA:  MOVLB  0
78DC:  CALL   322C
78E0:  MOVLW  01
78E2:  MOVLB  3
78E4:  ADDWF  00,W
78E6:  MOVLB  1
78E8:  MOVWF  xEB
78EA:  MOVLW  00
78EC:  MOVLB  3
78EE:  ADDWFC 01,W
78F0:  MOVLB  1
78F2:  MOVWF  xEC
78F4:  MOVLB  0
....................    } 
....................  
....................    return TRUE; 
78F6:  MOVLW  01
78F8:  MOVWF  01
78FA:  MOVLB  3
78FC:  MOVLB  0
78FE:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from RAM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET hTCP, BYTE* data, WORD len) 
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................    { 
....................       TCPFlush(hTCP); 
....................       return 0; 
....................    } 
....................  
....................    wActualLen = wFreeTXSpace; 
....................    if(wFreeTXSpace > len) 
....................       wActualLen = len; 
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................       TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen); 
....................       data += wRightLen; 
....................       wActualLen -= wRightLen; 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................  
....................    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen); 
....................    MyTCBStub.txHead += wActualLen; 
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return wActualLen + wRightLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
....................  
....................   Description: 
....................    Writes an array from ROM to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the array to be written. 
....................    len  - Number of bytes to be written. 
....................  
....................   Returns: 
....................    The number of bytes written to the socket.  If less than len, the 
....................    buffer became full or the socket is not conected. 
....................  
....................   Remarks: 
....................    This function is aliased to TCPPutArray on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPPutROMArray(TCP_SOCKET hTCP, ROM BYTE* data, WORD len) 
.................... { 
....................    WORD wActualLen; 
....................    WORD wFreeTXSpace; 
....................    WORD wRightLen = 0; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    wFreeTXSpace = TCPIsPutReady(hTCP); 
....................    if(wFreeTXSpace == 0u) 
....................    { 
....................       TCPFlush(hTCP); 
....................       return 0; 
....................    } 
....................  
....................    // Send all current bytes if we are crossing half full 
....................    // This is required to improve performance with the delayed  
....................    // acknowledgement algorithm 
....................    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1))) 
....................    { 
....................       TCPFlush(hTCP);    
....................       MyTCBStub.Flags.bHalfFullFlush = TRUE; 
....................    } 
....................     
....................    wActualLen = wFreeTXSpace; 
....................    if(wFreeTXSpace > len) 
....................       wActualLen = len; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................          TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.sslTxHead += wActualLen; 
....................    } 
....................    else 
....................    { 
....................       // See if we need a two part put 
....................       if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................       { 
....................          wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................          TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................          data += wRightLen; 
....................          wActualLen -= wRightLen; 
....................          MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................     
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................       MyTCBStub.txHead += wActualLen; 
....................    } 
....................    #else 
....................    // See if we need a two part put 
....................    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart) 
....................    { 
....................       wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead; 
....................       TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen); 
....................       data += wRightLen; 
....................       wActualLen -= wRightLen; 
....................       MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................    } 
....................  
....................    TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen); 
....................    MyTCBStub.txHead += wActualLen; 
....................    #endif 
....................  
....................    // Send these bytes right now if we are out of TX buffer space 
....................    if(wFreeTXSpace <= len) 
....................    { 
....................       TCPFlush(hTCP); 
....................    } 
....................    // If not already enabled, start a timer so this data will  
....................    // eventually get sent even if the application doens't call 
....................    // TCPFlush() 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................    return wActualLen + wRightLen; 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from RAM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................   ***************************************************************************/ 
.................... BYTE* TCPPutString(TCP_SOCKET hTCP, BYTE* data) 
.................... { 
....................    return data + TCPPutArray(hTCP, data, strlen((char*)data)); 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
....................  
....................   Description: 
....................    Writes a null-terminated string from ROM to a TCP socket.  The  
....................    null-terminator is not copied to the socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to which data is to be written. 
....................    data - Pointer to the string to be written. 
....................  
....................   Returns: 
....................    Pointer to the byte following the last byte written to the socket.  If 
....................    this pointer does not dereference to a NUL byte, the buffer became full 
....................    or the socket is not connected. 
....................  
....................   Remarks: 
....................    The return value of this function differs from that of TCPPutArray.  To 
....................    write long strings in a single state, initialize the *data pointer to the 
....................    first byte, then call this function repeatedly (breaking to the main  
....................    stack loop after each call) until the return value dereferences to a NUL 
....................    byte.  Save the return value as the new starting *data pointer otherwise. 
....................     
....................    This function is aliased to TCPPutString on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... ROM BYTE* TCPPutROMString(TCP_SOCKET hTCP, ROM BYTE* data) 
.................... { 
....................    return data + TCPPutROMArray(hTCP, data, strlenpgm((ROM char*)data)); 
.................... } 
.................... #endif 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are pending in the TCP TX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    Number of bytes pending to be flushed in the TCP TX FIFO. 
....................   ***************************************************************************/ 
.................... WORD TCPGetTxFIFOFull(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1; 
....................  
....................    // Find out how many data bytes are free in the TX FIFO 
....................    wDataLen = TCPIsPutReady(hTCP); 
....................  
....................    return wFIFOSize - wDataLen; 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Receive Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPDiscard(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Discards any pending data in the TCP RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket whose RX FIFO is to be cleared. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPDiscard(TCP_SOCKET hTCP) 
.................... { 
....................    if(TCPIsGetReady(hTCP)) 
....................    { 
....................       SyncTCBStub(hTCP); 
....................     
....................       // Delete all data in the RX buffer 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
....................     
....................       // Send a Window update message to the remote node 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
....................    } 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void WORD TCPIsGetReady(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes can be read from the TCP RX buffer. 
....................  
....................   Description: 
....................    Call this function to determine how many bytes can be read from the  
....................    TCP RX buffer.  If this function returns zero, the application must  
....................    return to the main stack loop before continuing in order to wait for 
....................    more data to arrive. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes available to be read from the TCP RX buffer. 
....................   ***************************************************************************/ 
.................... WORD TCPIsGetReady(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
*
7168:  MOVLB  3
716A:  MOVF   x9B,W
716C:  SUBLW  00
716E:  BC    7178
....................     { 
....................         return 0; 
7170:  MOVLW  00
7172:  MOVWF  01
7174:  MOVWF  02
7176:  BRA    71E4
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
7178:  MOVFF  39B,3D0
717C:  MOVLB  0
717E:  CALL   0A0C
....................        
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
7182:  MOVLB  1
7184:  MOVF   xE6,W
7186:  SUBWF  xE4,W
7188:  BNC   71AC
718A:  BNZ   7192
718C:  MOVF   xE5,W
718E:  SUBWF  xE3,W
7190:  BNC   71AC
....................       return MyTCBStub.rxHead - MyTCBStub.rxTail; 
7192:  MOVF   xE5,W
7194:  SUBWF  xE3,W
7196:  MOVWF  00
7198:  MOVF   xE6,W
719A:  SUBWFB xE4,W
719C:  MOVWF  03
719E:  MOVFF  00,01
71A2:  MOVWF  02
71A4:  MOVLB  3
71A6:  BRA    71E4
71A8:  BRA    71E4
71AA:  MOVLB  1
....................    else 
....................       return (MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1) + (MyTCBStub.rxHead - MyTCBStub.bufferRxStart); 
71AC:  MOVF   xE5,W
71AE:  SUBWF  xDD,W
71B0:  MOVLB  3
71B2:  MOVWF  x9C
71B4:  MOVLB  1
71B6:  MOVF   xE6,W
71B8:  SUBWFB xDE,W
71BA:  MOVLB  3
71BC:  MOVWF  x9D
71BE:  MOVLW  01
71C0:  ADDWF  x9C,F
71C2:  MOVLW  00
71C4:  ADDWFC x9D,F
71C6:  MOVLB  1
71C8:  MOVF   xDB,W
71CA:  SUBWF  xE3,W
71CC:  MOVWF  00
71CE:  MOVF   xDC,W
71D0:  SUBWFB xE4,W
71D2:  MOVWF  03
71D4:  MOVF   00,W
71D6:  MOVLB  3
71D8:  ADDWF  x9C,W
71DA:  MOVWF  01
71DC:  MOVF   x9D,W
71DE:  ADDWFC 03,F
71E0:  MOVFF  03,02
71E4:  MOVLB  0
71E6:  GOTO   71F8 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
....................  
....................   Description: 
....................    Retrieves a single byte to a TCP socket. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which to read. 
....................    byte - Pointer to location in which the read byte should be stored. 
....................  
....................   Return Values: 
....................    TRUE - A byte was read from the buffer. 
....................    FALSE - The buffer was empty, or the socket is not connected. 
....................   ***************************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET hTCP, BYTE* byte) 
.................... { 
....................    WORD wGetReadyCount; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
....................    if(wGetReadyCount == 0u) 
....................       return FALSE; 
....................  
....................    SyncTCBStub(hTCP); 
....................     
....................    if(byte) 
....................       TCPRAMCopy((PTR_BASE)byte, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, 1); 
....................    if(++MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
....................  
....................    // Send a window update if we've run out of data 
....................    if(wGetReadyCount == 1u) 
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
....................    } 
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
....................    } 
....................  
....................  
....................    return TRUE; 
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
....................  
....................   Description: 
....................    Reads an array of data bytes from a TCP socket's receive FIFO.  The data  
....................    is removed from the FIFO in the process. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket from which data is to be read. 
....................    buffer - Pointer to the array to store data that was read. 
....................    len  - Number of bytes to be read. 
....................  
....................   Returns: 
....................    The number of bytes read from the socket.  If less than len, the 
....................    RX FIFO buffer became empty or the socket is not conected. 
....................   ***************************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET hTCP, BYTE* buffer, WORD len) 
71EA:  MOVLB  3
71EC:  CLRF   x9A
71EE:  CLRF   x99
.................... { 
....................    WORD wGetReadyCount; 
....................    WORD RightLen = 0; 
....................  
....................    // See if there is any data which can be read 
....................    wGetReadyCount = TCPIsGetReady(hTCP); 
71F0:  MOVFF  392,39B
71F4:  MOVLB  0
71F6:  BRA    7168
71F8:  MOVFF  02,398
71FC:  MOVFF  01,397
....................    if(wGetReadyCount == 0u) 
7200:  MOVLB  3
7202:  MOVF   x97,F
7204:  BNZ   7212
7206:  MOVF   x98,F
7208:  BNZ   7212
....................       return 0x0000u; 
720A:  MOVLW  00
720C:  MOVWF  01
720E:  MOVWF  02
7210:  BRA    735E
....................  
....................    SyncTCBStub(hTCP); 
7212:  MOVFF  392,3D0
7216:  MOVLB  0
7218:  CALL   0A0C
....................  
....................    // Make sure we don't try to read more data than is available 
....................    if(len > wGetReadyCount) 
721C:  MOVLB  3
721E:  MOVF   x98,W
7220:  SUBWF  x96,W
7222:  BNC   7234
7224:  BNZ   722C
7226:  MOVF   x95,W
7228:  SUBWF  x97,W
722A:  BC    7234
....................       len = wGetReadyCount; 
722C:  MOVFF  398,396
7230:  MOVFF  397,395
....................  
....................    // See if we need a two part get 
....................    if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd) 
7234:  MOVF   x95,W
7236:  MOVLB  1
7238:  ADDWF  xE5,W
723A:  MOVLB  3
723C:  MOVWF  x9B
723E:  MOVF   x96,W
7240:  MOVLB  1
7242:  ADDWFC xE6,W
7244:  MOVLB  3
7246:  MOVWF  x9C
7248:  MOVLB  1
724A:  MOVF   xDE,W
724C:  MOVLB  3
724E:  SUBWF  x9C,W
7250:  BNC   72CC
7252:  BNZ   7264
7254:  MOVF   x9B,W
7256:  MOVLB  1
7258:  SUBWF  xDD,W
725A:  BTFSS  FD8.0
725C:  BRA    7262
725E:  MOVLB  3
7260:  BRA    72CC
7262:  MOVLB  3
....................    { 
....................       RightLen = MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1; 
7264:  MOVLB  1
7266:  MOVF   xE5,W
7268:  SUBWF  xDD,W
726A:  MOVLB  3
726C:  MOVWF  x9B
726E:  MOVLB  1
7270:  MOVF   xE6,W
7272:  SUBWFB xDE,W
7274:  MOVLB  3
7276:  MOVWF  x9C
7278:  MOVLW  01
727A:  ADDWF  x9B,W
727C:  MOVWF  x99
727E:  MOVLW  00
7280:  ADDWFC x9C,W
7282:  MOVWF  x9A
....................       if(buffer) 
7284:  MOVF   x93,W
7286:  IORWF  x94,W
7288:  BZ    72BC
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, RightLen); 
728A:  MOVFF  394,418
728E:  MOVFF  393,417
7292:  MOVLW  01
7294:  MOVLB  4
7296:  MOVWF  x19
7298:  MOVFF  1E6,41B
729C:  MOVFF  1E5,41A
72A0:  MOVFF  1F4,41C
72A4:  MOVFF  39A,41E
72A8:  MOVFF  399,41D
72AC:  MOVLB  0
72AE:  CALL   0F26
....................          buffer += RightLen; 
72B2:  MOVLB  3
72B4:  MOVF   x99,W
72B6:  ADDWF  x93,F
72B8:  MOVF   x9A,W
72BA:  ADDWFC x94,F
....................       } 
....................       len -= RightLen; 
72BC:  MOVF   x99,W
72BE:  SUBWF  x95,F
72C0:  MOVF   x9A,W
72C2:  SUBWFB x96,F
....................       MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
72C4:  MOVFF  1DC,1E6
72C8:  MOVFF  1DB,1E5
....................    } 
....................  
....................    if(buffer) 
72CC:  MOVF   x93,W
72CE:  IORWF  x94,W
72D0:  BZ    72FC
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len); 
72D2:  MOVFF  394,418
72D6:  MOVFF  393,417
72DA:  MOVLW  01
72DC:  MOVLB  4
72DE:  MOVWF  x19
72E0:  MOVFF  1E6,41B
72E4:  MOVFF  1E5,41A
72E8:  MOVFF  1F4,41C
72EC:  MOVFF  396,41E
72F0:  MOVFF  395,41D
72F4:  MOVLB  0
72F6:  CALL   0F26
72FA:  MOVLB  3
....................    MyTCBStub.rxTail += len; 
72FC:  MOVF   x95,W
72FE:  MOVLB  1
7300:  ADDWF  xE5,F
7302:  MOVLB  3
7304:  MOVF   x96,W
7306:  MOVLB  1
7308:  ADDWFC xE6,F
....................    len += RightLen; 
730A:  MOVLB  3
730C:  MOVF   x99,W
730E:  ADDWF  x95,F
7310:  MOVF   x9A,W
7312:  ADDWFC x96,F
....................  
....................    // Send a window update if we've run low on data 
....................    if(wGetReadyCount - len <= len) 
7314:  MOVF   x95,W
7316:  SUBWF  x97,W
7318:  MOVWF  x9B
731A:  MOVF   x96,W
731C:  SUBWFB x98,W
731E:  MOVWF  x9C
7320:  SUBWF  x96,W
7322:  BNC   7332
7324:  BNZ   732C
7326:  MOVF   x9B,W
7328:  SUBWF  x95,W
732A:  BNC   7332
....................    { 
....................       MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
732C:  MOVLB  1
732E:  BSF    xF1.2
....................    } 
7330:  BRA    7354
....................    else if(!MyTCBStub.Flags.bTimer2Enabled) 
7332:  MOVLB  1
7334:  BTFSC  xF0.5
7336:  BRA    7354
....................    // If not already enabled, start a timer so a window  
....................    // update will get sent to the remote node at some point 
....................    { 
....................       MyTCBStub.Flags.bTimer2Enabled = TRUE; 
7338:  BSF    xF0.5
....................       MyTCBStub.eventTime2 = (WORD)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull; 
733A:  MOVLB  0
733C:  CALL   322C
7340:  MOVLW  06
7342:  MOVLB  3
7344:  ADDWF  00,W
7346:  MOVLB  1
7348:  MOVWF  xEB
734A:  MOVLW  00
734C:  MOVLB  3
734E:  ADDWFC 01,W
7350:  MOVLB  1
7352:  MOVWF  xEC
....................    } 
....................  
....................    return len; 
7354:  MOVLB  3
7356:  MOVFF  395,01
735A:  MOVFF  396,02
735E:  MOVLB  0
7360:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
....................  
....................   Description: 
....................    Determines how many bytes are free in the RX FIFO. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to check. 
....................  
....................   Returns: 
....................    The number of bytes free in the TCP RX FIFO.  If zero, no additional  
....................    data can be received until the application removes some data using one 
....................    of the TCPGet family functions. 
....................   ***************************************************************************/ 
.................... WORD TCPGetRxFIFOFree(TCP_SOCKET hTCP) 
.................... { 
....................    WORD wDataLen; 
....................    WORD wFIFOSize; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Calculate total usable FIFO size 
....................    wFIFOSize = MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart; 
....................  
....................    #if defined(STACK_USE_SSL) 
....................    { 
....................       PTR_BASE SSLtemp = MyTCBStub.rxHead; 
....................  
....................       // Move SSL pointer to determine full buffer size 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................  
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................        
....................       // Move SSL pointer back to proper location (if we changed it) 
....................       MyTCBStub.rxHead = SSLtemp; 
....................    } 
....................    #else 
....................    { 
....................       // Find out how many data bytes are actually in the RX FIFO 
....................       wDataLen = TCPIsGetReady(hTCP); 
....................    } 
....................    #endif 
....................     
....................    // Perform the calculation    
....................    return wFIFOSize - wDataLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
....................  
....................   Summary: 
....................      Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer. 
....................  
....................   Description: 
....................    Reads a specified number of data bytes from the TCP RX FIFO without  
....................      removing them from the buffer.  No TCP control actions are taken as a  
....................      result of this function (ex: no window update is sent to the remote node). 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    vBuffer - Destination to write the peeked data bytes. 
....................    wLen - Length of bytes to peak from the RX FIFO and copy to vBuffer. 
....................    wStart - Zero-indexed starting position within the FIFO to start peeking  
....................       from. 
....................  
....................   Return Values: 
....................    Number of bytes actually peeked from the stream and copied to vBuffer.   
....................    This value can be less than wLen if wStart + wLen is greater than the  
....................    deepest possible character in the RX FIFO. 
....................  
....................   Remarks: 
....................      None 
....................   ***************************************************************************/ 
.................... WORD TCPPeekArray(TCP_SOCKET hTCP, BYTE *vBuffer, WORD wLen, WORD wStart) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD w; 
....................    WORD wBytesUntilWrap; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and decrease read length  
....................    // if the start offset + read length is beyond the end of the FIFO 
....................    w = TCPIsGetReady(hTCP); 
....................    if(wStart + wLen > w) 
....................       wLen = w - wStart; 
....................  
....................    // Find the read start location 
....................    ptrRead = MyTCBStub.rxTail + wStart; 
....................    if(ptrRead > MyTCBStub.bufferEnd) 
....................       ptrRead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................  
....................    // Calculate how many bytes can be read in a single go 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrRead + 1; 
....................    if(wLen <= wBytesUntilWrap) 
....................    { 
....................       // Read all at once 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wLen); 
....................    } 
....................    else 
....................    { 
....................       // Read all bytes up to the wrap position and then read remaining bytes  
....................       // at the start of the buffer 
....................       TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap); 
....................       TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap); 
....................    } 
....................     
....................    return wLen; 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
....................  
....................   Summary: 
....................      Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................  
....................   Description: 
....................    Peaks at one byte in the TCP RX FIFO without removing it from the buffer. 
....................       
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to peak from (read without removing from stream). 
....................    wStart - Zero-indexed starting position within the FIFO to peek from. 
....................  
....................   Return Values: 
....................    Byte peeked from the RX FIFO.  If there is no data in the buffer or an  
....................    illegal wStart starting offset is given, then an indeterminate value is  
....................    returned.  The caller must ensure that valid parameters are passed to avoid  
....................    (i.e ensure that TCPIsGetReady() returns a number that is less than wStart  
....................    before calling TCPPeek()). 
....................  
....................   Remarks: 
....................      Use the TCPPeekArray() function to read more than one byte.  It will  
....................      perform better than calling TCPPeek() in a loop. 
....................   ***************************************************************************/ 
.................... BYTE TCPPeek(TCP_SOCKET hTCP, WORD wStart) 
.................... { 
....................    BYTE i; 
....................     
....................    TCPPeekArray(hTCP, &i, 1, wStart); 
....................    return i; 
.................... } 
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Search Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, BYTE* cFindArray, WORD wLen,  
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a ROM string in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of an array of bytes in the 
....................    TCP RX buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the search 
....................    array is "love" with a length of 4, a value of 2 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFindArray - The array of bytes to find in the buffer. 
....................    wLen - Length of cFindArray. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................     
....................    This function is aliased to TCPFindArrayEx on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... WORD TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM BYTE* cFindArray, WORD wLen, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    PTR_BASE ptrRead; 
....................    WORD wDataLen; 
....................    WORD wBytesUntilWrap; 
....................    PTR_BASE ptrLocation; 
....................    WORD wLenStart; 
....................    ROM BYTE *cFindArrayStart; 
....................    BYTE i, j, k; 
....................    BOOL isFinding; 
....................    BYTE buffer[32]; 
....................  
....................    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Find out how many bytes are in the RX FIFO and return  
....................    // immediately if we won't possibly find a match 
....................    wDataLen = TCPIsGetReady(hTCP) - wStart; 
....................    if(wDataLen < wLen) 
....................       return 0xFFFFu; 
....................    if(wSearchLen && (wDataLen > wSearchLen)) 
....................       wDataLen = wSearchLen; 
....................  
....................    ptrLocation = MyTCBStub.rxTail + wStart; 
....................    if(ptrLocation > MyTCBStub.bufferEnd) 
....................       ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    ptrRead = ptrLocation; 
....................    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1; 
....................    ptrLocation = wStart; 
....................    wLenStart = wLen; 
....................    cFindArrayStart = cFindArray; 
....................    j = *cFindArray++; 
....................    isFinding = FALSE; 
....................    if(bTextCompare) 
....................    { 
....................       if(j >= 'a' && j <= 'z') 
....................          j += 'A'-'a'; 
....................    } 
....................  
....................    // Search for the array 
....................    while(1) 
....................    { 
....................       // Figure out how big of a chunk to read 
....................       k = sizeof(buffer); 
....................       if(k > wBytesUntilWrap) 
....................          k = wBytesUntilWrap; 
....................       if((WORD)k > wDataLen) 
....................          k = wDataLen; 
....................  
....................       // Read a chunk of data into the buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (WORD)k); 
....................       ptrRead += k; 
....................       wBytesUntilWrap -= k; 
....................  
....................       if(wBytesUntilWrap == 0u) 
....................       { 
....................          ptrRead = MyTCBStub.bufferRxStart; 
....................          wBytesUntilWrap = 0xFFFFu; 
....................       } 
....................  
....................       // Convert everything to uppercase 
....................       if(bTextCompare) 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(buffer[i] >= 'a' && buffer[i] <= 'z') 
....................                buffer[i] += 'A'-'a'; 
....................  
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................                if(j >= 'a' && j <= 'z') 
....................                   j += 'A'-'a'; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   if(j >= 'a' && j <= 'z') 
....................                      j += 'A'-'a'; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................       else   // Compare as is 
....................       { 
....................          for(i = 0; i < k; i++) 
....................          { 
....................             if(j == buffer[i]) 
....................             { 
....................                if(--wLen == 0u) 
....................                   return ptrLocation-wLenStart + i + 1; 
....................                j = *cFindArray++; 
....................                isFinding = TRUE; 
....................             } 
....................             else 
....................             { 
....................                wLen = wLenStart; 
....................                if(isFinding) 
....................                { 
....................                   cFindArray = cFindArrayStart; 
....................                   j = *cFindArray++; 
....................                   isFinding = FALSE; 
....................                } 
....................             } 
....................          } 
....................       } 
....................  
....................       // Check to see if it is impossible to find a match 
....................       wDataLen -= k; 
....................       if(wDataLen < wLen) 
....................          return 0xFFFFu; 
....................  
....................       ptrLocation += k; 
....................    } 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, 
....................                   WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
....................  
....................   Summary: 
....................      Searches for a byte in the TCP RX buffer. 
....................  
....................   Description: 
....................    This function finds the first occurrance of a byte in the TCP RX 
....................    buffer.  It can be used by an application to abstract searches  
....................    out of their own application code.  For increased efficiency, the  
....................    function is capable of limiting the scope of search to a specific 
....................    range of bytes.  It can also perform a case-insensitive search if 
....................    required. 
....................     
....................    For example, if the buffer contains "I love PIC MCUs!" and the cFind 
....................    byte is ' ', a value of 1 will be returned. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP - The socket to search within. 
....................    cFind - The byte to find in the buffer. 
....................    wStart - Zero-indexed starting position within the buffer. 
....................    wSearchLen - Length from wStart to search in the buffer. 
....................    bTextCompare - TRUE for case-insensitive text search, FALSE for binary search 
....................  
....................   Return Values: 
....................    0xFFFF - Search array not found 
....................    Otherwise - Zero-indexed position of the first occurrance 
....................  
....................   Remarks: 
....................    Since this function usually must transfer data from external storage 
....................    to internal RAM for comparison, its performance degrades significantly 
....................    when the buffer is full and the array is not found.  For better  
....................    performance, try to search for characters that are expected to exist or 
....................    limit the scope of the search as much as possible.  The HTTP2 module,  
....................    for example, uses this function to parse headers.  However, it searches  
....................    for newlines, then the separating colon, then reads the header name to  
....................    RAM for final comparison.  This has proven to be significantly faster   
....................    than searching for full header name strings outright. 
....................   ***************************************************************************/ 
.................... WORD TCPFindEx(TCP_SOCKET hTCP, BYTE cFind, WORD wStart, WORD wSearchLen, BOOL bTextCompare) 
.................... { 
....................    return TCPFindArrayEx(hTCP, &cFind, sizeof(cFind), wStart, wSearchLen, bTextCompare); 
.................... } 
....................  
....................  
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Data Processing Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPTick(void) 
....................  
....................   Summary: 
....................      Performs periodic TCP tasks. 
....................  
....................   Description: 
....................    This function performs any required periodic TCP tasks.  Each  
....................    socket's state machine is checked, and any elapsed timeout periods 
....................    are handled. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    BOOL bRetransmit; 
....................    BOOL bCloseSocket; 
....................    BYTE vFlags; 
....................    WORD w; 
....................  
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
*
3FB0:  MOVLB  3
3FB2:  CLRF   x9B
3FB4:  MOVF   x9B,F
3FB6:  BTFSS  FD8.2
3FB8:  BRA    466E
....................    { 
....................       SyncTCBStub(hTCP); 
3FBA:  MOVFF  39B,3D0
3FBE:  MOVLB  0
3FC0:  CALL   0A0C
....................        
....................       // Handle any SSL Processing and Message Transmission 
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Handle any periodic tasks, such as RSA operations 
....................          SSLPeriodic(hTCP, MyTCBStub.sslStubID); 
....................           
....................          // If unsent data is waiting, transmit it as an application record 
....................          if(MyTCBStub.sslTxHead != MyTCBStub.txHead && TCPSSLGetPendingTxSize(hTCP) != 0u) 
....................             SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION); 
....................           
....................          // If an SSL message is requested, send it now 
....................          if(MyTCBStub.sslReqMessage != SSL_NO_MESSAGE) 
....................             SSLTxMessage(hTCP, MyTCBStub.sslStubID, MyTCBStub.sslReqMessage); 
....................       } 
....................       #endif 
....................        
....................       vFlags = 0x00; 
3FC4:  MOVLB  3
3FC6:  CLRF   x9D
....................       bRetransmit = FALSE; 
3FC8:  BCF    x9C.0
....................       bCloseSocket = FALSE; 
3FCA:  BCF    x9C.1
....................  
....................       // Transmit ASAP data if the medium is available 
....................       if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset) 
3FCC:  MOVLB  1
3FCE:  BTFSC  xF1.1
3FD0:  BRA    3FD6
3FD2:  BTFSS  xF1.2
3FD4:  BRA    3FF4
....................       { 
....................          if(MACIsTxReady()) 
3FD6:  MOVLB  0
3FD8:  CALL   19F2
3FDC:  MOVF   01,F
3FDE:  BZ    3FF6
....................          { 
....................             vFlags = ACK; 
3FE0:  MOVLW  10
3FE2:  MOVLB  3
3FE4:  MOVWF  x9D
....................             bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset; 
3FE6:  BCF    x9C.0
3FE8:  MOVLB  1
3FEA:  BTFSS  xF1.2
3FEC:  BRA    3FF4
3FEE:  MOVLB  3
3FF0:  BSF    x9C.0
3FF2:  MOVLB  1
3FF4:  MOVLB  0
....................          } 
....................       } 
....................  
....................       // Perform any needed window updates and data transmissions 
....................       if(MyTCBStub.Flags.bTimer2Enabled) 
3FF6:  MOVLB  1
3FF8:  BTFSS  xF0.5
3FFA:  BRA    402C
....................       { 
....................          // See if the timeout has occured, and we need to send a new window update and pending data 
....................          if((SHORT)(MyTCBStub.eventTime2 - (WORD)TickGetDiv256()) <= (SHORT)0) 
3FFC:  MOVLB  0
3FFE:  CALL   322C
4002:  MOVF   00,W
4004:  MOVLB  1
4006:  SUBWF  xEB,W
4008:  MOVWF  00
400A:  MOVF   01,W
400C:  SUBWFB xEC,W
400E:  MOVWF  03
4010:  MOVFF  00,3A0
4014:  MOVLB  3
4016:  MOVWF  xA1
4018:  BTFSC  FE8.7
401A:  BRA    4026
401C:  MOVF   xA1,F
401E:  BNZ   402A
4020:  MOVF   xA0,W
4022:  SUBLW  00
4024:  BNC   402A
....................             vFlags = ACK; 
4026:  MOVLW  10
4028:  MOVWF  x9D
402A:  MOVLB  1
....................       } 
....................  
....................       // Process Delayed ACKnowledgement timer 
....................       if(MyTCBStub.Flags.bDelayedACKTimerEnabled) 
402C:  BTFSS  xF0.6
402E:  BRA    4060
....................       { 
....................          // See if the timeout has occured and delayed ACK needs to be sent 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.delayedACKTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
4030:  MOVLB  0
4032:  CALL   322C
4036:  MOVF   00,W
4038:  MOVLB  1
403A:  SUBWF  xED,W
403C:  MOVWF  00
403E:  MOVF   01,W
4040:  SUBWFB xEE,W
4042:  MOVWF  03
4044:  MOVFF  00,3A0
4048:  MOVLB  3
404A:  MOVWF  xA1
404C:  BTFSC  FE8.7
404E:  BRA    405A
4050:  MOVF   xA1,F
4052:  BNZ   405E
4054:  MOVF   xA0,W
4056:  SUBLW  00
4058:  BNC   405E
....................             vFlags = ACK; 
405A:  MOVLW  10
405C:  MOVWF  x9D
405E:  MOVLB  1
....................       } 
....................        
....................       // Process TCP_CLOSE_WAIT timer 
....................       if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
4060:  MOVF   xEF,W
4062:  SUBLW  0B
4064:  BNZ   409A
....................       { 
....................          // Automatically close the socket on our end if the application  
....................          // fails to call TCPDisconnect() is a reasonable amount of time. 
....................          if((SHORT)(MyTCBStub.OverlappedTimers.closeWaitTime - (WORD)TickGetDiv256()) <= (SHORT)0) 
4066:  MOVLB  0
4068:  CALL   322C
406C:  MOVF   00,W
406E:  MOVLB  1
4070:  SUBWF  xED,W
4072:  MOVWF  00
4074:  MOVF   01,W
4076:  SUBWFB xEE,W
4078:  MOVWF  03
407A:  MOVFF  00,3A0
407E:  MOVLB  3
4080:  MOVWF  xA1
4082:  BTFSC  FE8.7
4084:  BRA    4090
4086:  MOVF   xA1,F
4088:  BNZ   409C
408A:  MOVF   xA0,W
408C:  SUBLW  00
408E:  BNC   409C
....................          { 
....................             vFlags = FIN | ACK; 
4090:  MOVLW  11
4092:  MOVWF  x9D
....................             MyTCBStub.smState = TCP_LAST_ACK; 
4094:  MOVLW  0C
4096:  MOVLB  1
4098:  MOVWF  xEF
409A:  MOVLB  3
....................          } 
....................       } 
....................  
....................       // Process listening server sockets that might have a SYN waiting in the SYNQueue[] 
....................       #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................          if(MyTCBStub.smState == TCP_LISTEN) 
409C:  MOVLB  1
409E:  MOVF   xEF,W
40A0:  SUBLW  04
40A2:  BTFSS  FD8.2
40A4:  BRA    4358
....................          { 
....................             for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
40A6:  MOVLB  3
40A8:  CLRF   x9F
40AA:  CLRF   x9E
40AC:  MOVF   x9F,F
40AE:  BTFSS  FD8.2
40B0:  BRA    4356
40B2:  MOVF   x9E,W
40B4:  SUBLW  02
40B6:  BTFSS  FD8.0
40B8:  BRA    4356
....................             { 
....................                // Abort search if there are no more valid records 
....................                if(SYNQueue[w].wDestPort == 0u) 
40BA:  MOVFF  39F,3D1
40BE:  MOVFF  39E,3D0
40C2:  CLRF   xD3
40C4:  MOVLW  14
40C6:  MOVWF  xD2
40C8:  MOVLB  0
40CA:  CALL   3252
40CE:  MOVFF  01,3A0
40D2:  MOVLW  10
40D4:  MOVLB  3
40D6:  ADDWF  01,W
40D8:  MOVWF  01
40DA:  MOVLW  00
40DC:  ADDWFC 02,W
40DE:  MOVWF  03
40E0:  MOVF   01,W
40E2:  ADDLW  9D
40E4:  MOVWF  FE9
40E6:  MOVLW  01
40E8:  ADDWFC 03,W
40EA:  MOVWF  FEA
40EC:  MOVFF  FEC,3A1
40F0:  MOVF   FED,F
40F2:  MOVFF  FEF,3A0
40F6:  MOVF   xA0,F
40F8:  BNZ   4100
40FA:  MOVF   xA1,F
40FC:  BNZ   4100
....................                   break; 
40FE:  BRA    4356
....................                 
....................                // Stop searching if this SYN queue entry can be used by this socket 
....................                #if defined(STACK_USE_SSL_SERVER) 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val || SYNQueue[w].wDestPort == MyTCBStub.sslTxHead) 
....................                #else 
....................                if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val) 
4100:  MOVFF  39F,3D1
4104:  MOVFF  39E,3D0
4108:  CLRF   xD3
410A:  MOVLW  14
410C:  MOVWF  xD2
410E:  MOVLB  0
4110:  CALL   3252
4114:  MOVFF  01,3A0
4118:  MOVLW  10
411A:  MOVLB  3
411C:  ADDWF  01,W
411E:  MOVWF  01
4120:  MOVLW  00
4122:  ADDWFC 02,W
4124:  MOVWF  03
4126:  MOVF   01,W
4128:  ADDLW  9D
412A:  MOVWF  FE9
412C:  MOVLW  01
412E:  ADDWFC 03,W
4130:  MOVWF  FEA
4132:  MOVFF  FEC,3A1
4136:  MOVF   FED,F
4138:  MOVFF  FEF,3A0
413C:  MOVLB  1
413E:  MOVF   xF2,W
4140:  MOVLB  3
4142:  SUBWF  xA0,W
4144:  BTFSS  FD8.2
4146:  BRA    434E
4148:  MOVLB  1
414A:  MOVF   xF3,W
414C:  MOVLB  3
414E:  SUBWF  xA1,W
4150:  BTFSS  FD8.2
4152:  BRA    434E
....................                #endif 
....................                { 
....................                   // Set up our socket and generate a reponse SYN+ACK packet 
....................                   SyncTCB(); 
4154:  MOVLB  0
4156:  CALL   100C
....................                    
....................                   #if defined(STACK_USE_SSL_SERVER) 
....................                   // If this matches the SSL port, make sure that can be configured 
....................                   // before continuing.  If not, break and leave this in the queue 
....................                   if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP)) 
....................                      break; 
....................                   #endif 
....................                    
....................                   memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO)); 
415A:  MOVLW  01
415C:  MOVLB  3
415E:  MOVWF  xA1
4160:  MOVLW  8B
4162:  MOVWF  xA0
4164:  MOVFF  39F,3D1
4168:  MOVFF  39E,3D0
416C:  CLRF   xD3
416E:  MOVLW  14
4170:  MOVWF  xD2
4172:  MOVLB  0
4174:  CALL   3252
4178:  MOVFF  02,3A3
417C:  MOVFF  01,3A2
4180:  MOVLW  9D
4182:  MOVLB  3
4184:  ADDWF  01,W
4186:  MOVWF  01
4188:  MOVLW  01
418A:  ADDWFC 02,W
418C:  MOVWF  03
418E:  MOVFF  01,3A4
4192:  MOVWF  xA5
4194:  MOVFF  3A1,FEA
4198:  MOVFF  3A0,FE9
419C:  MOVWF  FE2
419E:  MOVFF  01,FE1
41A2:  MOVLW  0A
41A4:  MOVWF  01
41A6:  MOVFF  FE6,FEE
41AA:  DECFSZ 01,F
41AC:  BRA    41A6
....................                   MyTCB.remotePort.Val = SYNQueue[w].wSourcePort; 
41AE:  MOVFF  39F,3D1
41B2:  MOVFF  39E,3D0
41B6:  CLRF   xD3
41B8:  MOVLW  14
41BA:  MOVWF  xD2
41BC:  MOVLB  0
41BE:  CALL   3252
41C2:  MOVFF  01,3A0
41C6:  MOVLW  0A
41C8:  MOVLB  3
41CA:  ADDWF  01,W
41CC:  MOVWF  01
41CE:  MOVLW  00
41D0:  ADDWFC 02,W
41D2:  MOVWF  03
41D4:  MOVF   01,W
41D6:  ADDLW  9D
41D8:  MOVWF  FE9
41DA:  MOVLW  01
41DC:  ADDWFC 03,W
41DE:  MOVWF  FEA
41E0:  MOVFF  FEC,184
41E4:  MOVF   FED,F
41E6:  MOVFF  FEF,183
....................                   MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1; 
41EA:  MOVFF  39F,3D1
41EE:  MOVFF  39E,3D0
41F2:  CLRF   xD3
41F4:  MOVLW  14
41F6:  MOVWF  xD2
41F8:  MOVLB  0
41FA:  CALL   3252
41FE:  MOVFF  01,3A0
4202:  MOVLW  0C
4204:  MOVLB  3
4206:  ADDWF  01,W
4208:  MOVWF  01
420A:  MOVLW  00
420C:  ADDWFC 02,W
420E:  MOVWF  03
4210:  MOVF   01,W
4212:  ADDLW  9D
4214:  MOVWF  FE9
4216:  MOVLW  01
4218:  ADDWFC 03,W
421A:  MOVWF  FEA
421C:  MOVFF  FEF,3A0
4220:  MOVFF  FEC,3A1
4224:  MOVFF  FEC,3A2
4228:  MOVFF  FEC,3A3
422C:  MOVLW  01
422E:  ADDWF  xA0,W
4230:  MOVLB  1
4232:  MOVWF  x7D
4234:  MOVLW  00
4236:  MOVLB  3
4238:  ADDWFC xA1,W
423A:  MOVLB  1
423C:  MOVWF  x7E
423E:  MOVLW  00
4240:  MOVLB  3
4242:  ADDWFC xA2,W
4244:  MOVLB  1
4246:  MOVWF  x7F
4248:  MOVLW  00
424A:  MOVLB  3
424C:  ADDWFC xA3,W
424E:  MOVLB  1
4250:  MOVWF  x80
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
4252:  MOVF   x8B,W
4254:  ADDWF  x8D,W
4256:  MOVLB  3
4258:  MOVWF  xA0
425A:  MOVLB  1
425C:  MOVF   x8C,W
425E:  ADDWFC x8E,W
4260:  MOVLB  3
4262:  MOVWF  xA1
4264:  MOVLB  1
4266:  MOVF   x83,W
4268:  MOVLB  3
426A:  ADDWF  xA0,F
426C:  MOVLB  1
426E:  MOVF   x84,W
4270:  MOVLB  3
4272:  ADDWFC xA1,F
4274:  MOVF   xA0,W
4276:  MOVLB  1
4278:  XORWF  x85,W
427A:  MOVWF  xF2
427C:  MOVLB  3
427E:  MOVF   xA1,W
4280:  MOVLB  1
4282:  XORWF  x86,W
4284:  MOVWF  xF3
....................                   vFlags = SYN | ACK; 
4286:  MOVLW  12
4288:  MOVLB  3
428A:  MOVWF  x9D
....................                   MyTCBStub.smState = TCP_SYN_RECEIVED; 
428C:  MOVLW  06
428E:  MOVLB  1
4290:  MOVWF  xEF
....................                    
....................                   // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................                   TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
4292:  MOVFF  39F,3D1
4296:  MOVFF  39E,3D0
429A:  MOVLB  3
429C:  CLRF   xD3
429E:  MOVLW  14
42A0:  MOVWF  xD2
42A2:  MOVLB  0
42A4:  CALL   3252
42A8:  MOVFF  02,03
42AC:  MOVF   01,W
42AE:  ADDLW  9D
42B0:  MOVWF  01
42B2:  MOVLW  01
42B4:  ADDWFC 03,F
42B6:  MOVFF  01,3A0
42BA:  MOVLB  3
42BC:  MOVFF  03,3A1
42C0:  MOVLW  01
42C2:  ADDWF  x9E,W
42C4:  MOVWF  xA2
42C6:  MOVLW  00
42C8:  ADDWFC x9F,W
42CA:  MOVWF  xA3
42CC:  MOVWF  xD1
42CE:  MOVFF  3A2,3D0
42D2:  CLRF   xD3
42D4:  MOVLW  14
42D6:  MOVWF  xD2
42D8:  MOVLB  0
42DA:  CALL   3252
42DE:  MOVFF  02,03
42E2:  MOVF   01,W
42E4:  ADDLW  9D
42E6:  MOVWF  01
42E8:  MOVLW  01
42EA:  ADDWFC 03,F
42EC:  MOVFF  01,3A2
42F0:  MOVLB  3
42F2:  MOVFF  03,3A3
42F6:  MOVLW  02
42F8:  BSF    FD8.0
42FA:  SUBFWB x9E,W
42FC:  MOVWF  xA4
42FE:  MOVLW  00
4300:  SUBFWB x9F,W
4302:  MOVWF  xA5
4304:  MOVWF  xD1
4306:  MOVFF  3A4,3D0
430A:  CLRF   xD3
430C:  MOVLW  14
430E:  MOVWF  xD2
4310:  MOVLB  0
4312:  CALL   3252
4316:  MOVFF  02,3A5
431A:  MOVFF  01,3A4
431E:  MOVFF  3A1,418
4322:  MOVFF  3A0,417
4326:  MOVLW  01
4328:  MOVLB  4
432A:  MOVWF  x19
432C:  MOVFF  3A3,41B
4330:  MOVFF  3A2,41A
4334:  MOVWF  x1C
4336:  MOVFF  02,41E
433A:  MOVFF  01,41D
433E:  MOVLB  0
4340:  CALL   0F26
....................                   SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
4344:  MOVLB  1
4346:  CLRF   xD6
4348:  CLRF   xD5
....................     
....................                   break; 
434A:  MOVLB  3
434C:  BRA    4356
....................                } 
434E:  INCF   x9E,F
4350:  BTFSC  FD8.2
4352:  INCF   x9F,F
4354:  BRA    40AC
4356:  MOVLB  1
....................             } 
....................          } 
....................       #endif 
....................  
....................       if(vFlags) 
4358:  MOVLB  3
435A:  MOVF   x9D,F
435C:  BZ    4378
....................          SendTCP(vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS); 
435E:  BTFSS  x9C.0
4360:  BRA    4366
4362:  MOVLW  00
4364:  BRA    4368
4366:  MOVLW  01
4368:  MOVWF  xA0
436A:  MOVFF  39D,3E6
436E:  MOVWF  xE7
4370:  MOVLB  0
4372:  CALL   3870
4376:  MOVLB  3
....................  
....................       // The TCP_CLOSED, TCP_LISTEN, and sometimes the TCP_ESTABLISHED  
....................       // state don't need any timeout events, so see if the timer is enabled 
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
4378:  MOVLB  1
437A:  BTFSC  xF0.4
437C:  BRA    4458
....................       { 
....................          #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................             // Only the established state has any use for keep-alives 
....................             if(MyTCBStub.smState == TCP_ESTABLISHED) 
437E:  MOVF   xEF,W
4380:  SUBLW  07
4382:  BNZ   4452
....................             { 
....................                // If timeout has not occured, do not do anything. 
....................                if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
4384:  MOVLB  0
4386:  CALL   2692
438A:  MOVFF  03,3A3
438E:  MOVFF  02,3A2
4392:  MOVFF  01,3A1
4396:  MOVFF  00,3A0
439A:  MOVLB  1
439C:  MOVF   xE7,W
439E:  MOVLB  3
43A0:  SUBWF  00,W
43A2:  MOVWF  00
43A4:  MOVLB  1
43A6:  MOVF   xE8,W
43A8:  MOVLB  3
43AA:  SUBWFB 01,W
43AC:  MOVWF  01
43AE:  MOVLB  1
43B0:  MOVF   xE9,W
43B2:  MOVLB  3
43B4:  SUBWFB 02,W
43B6:  MOVWF  02
43B8:  MOVLB  1
43BA:  MOVF   xEA,W
43BC:  MOVLB  3
43BE:  SUBWFB 03,W
43C0:  MOVWF  03
43C2:  MOVWF  xA3
43C4:  MOVFF  02,3A2
43C8:  MOVFF  01,3A1
43CC:  MOVFF  00,3A0
43D0:  BTFSS  FE8.7
43D2:  BRA    43D6
....................                   continue; 
43D4:  BRA    466A
....................        
....................                // If timeout has occured and the connection appears to be dead (no  
....................                // responses from remote node at all), close the connection so the  
....................                // application doesn't sit around indefinitely with a useless socket  
....................                // that it thinks is still open 
....................                if(MyTCBStub.Flags.vUnackedKeepalives == TCP_MAX_UNACKED_KEEP_ALIVES) 
43D6:  MOVLB  1
43D8:  MOVF   xF0,W
43DA:  ANDLW  07
43DC:  SUBLW  06
43DE:  BNZ   4410
....................                { 
....................                   vFlags = MyTCBStub.Flags.bServer; 
43E0:  MOVLB  3
43E2:  CLRF   x9D
43E4:  MOVLB  1
43E6:  BTFSS  xF0.3
43E8:  BRA    43F0
43EA:  MOVLB  3
43EC:  INCF   x9D,F
43EE:  MOVLB  1
....................  
....................                   // Force an immediate FIN and RST transmission 
....................                   // Double calling TCPDisconnect() will also place us  
....................                   // back in the listening state immediately if a server socket. 
....................                   TCPDisconnect(hTCP); 
43F0:  MOVFF  39B,3A0
43F4:  MOVLB  0
43F6:  RCALL  3EC6
....................                   TCPDisconnect(hTCP); 
43F8:  MOVFF  39B,3A0
43FC:  RCALL  3EC6
....................                    
....................                   // Prevent client mode sockets from getting reused by other applications.   
....................                   // The application must call TCPDisconnect() with the handle to free this  
....................                   // socket (and the handle associated with it) 
....................                   if(!vFlags) 
43FE:  MOVLB  3
4400:  MOVF   x9D,F
4402:  BNZ   440C
....................                      MyTCBStub.smState = TCP_CLOSED_BUT_RESERVED; 
4404:  MOVLW  0E
4406:  MOVLB  1
4408:  MOVWF  xEF
440A:  MOVLB  3
....................                    
....................                   continue; 
440C:  BRA    466A
440E:  MOVLB  1
....................                } 
....................                 
....................                // Otherwise, if a timeout occured, simply send a keep-alive packet 
....................                SyncTCB(); 
4410:  MOVLB  0
4412:  CALL   100C
....................                SendTCP(ACK, SENDTCP_KEEP_ALIVE); 
4416:  MOVLW  10
4418:  MOVLB  3
441A:  MOVWF  xE6
441C:  MOVLW  02
441E:  MOVWF  xE7
4420:  MOVLB  0
4422:  CALL   3870
....................                MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
4426:  CALL   2692
442A:  MOVLW  32
442C:  MOVLB  3
442E:  ADDWF  00,W
4430:  MOVLB  1
4432:  MOVWF  xE7
4434:  MOVLW  31
4436:  MOVLB  3
4438:  ADDWFC 01,W
443A:  MOVLB  1
443C:  MOVWF  xE8
443E:  MOVLW  01
4440:  MOVLB  3
4442:  ADDWFC 02,W
4444:  MOVLB  1
4446:  MOVWF  xE9
4448:  MOVLW  00
444A:  MOVLB  3
444C:  ADDWFC 03,W
444E:  MOVLB  1
4450:  MOVWF  xEA
....................             } 
....................          #endif 
....................          continue; 
4452:  MOVLB  3
4454:  BRA    466A
4456:  MOVLB  1
....................       } 
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if((LONG)(TickGet() - MyTCBStub.eventTime) < (LONG)0) 
4458:  MOVLB  0
445A:  CALL   2692
445E:  MOVFF  03,3A3
4462:  MOVFF  02,3A2
4466:  MOVFF  01,3A1
446A:  MOVFF  00,3A0
446E:  MOVLB  1
4470:  MOVF   xE7,W
4472:  MOVLB  3
4474:  SUBWF  00,W
4476:  MOVWF  00
4478:  MOVLB  1
447A:  MOVF   xE8,W
447C:  MOVLB  3
447E:  SUBWFB 01,W
4480:  MOVWF  01
4482:  MOVLB  1
4484:  MOVF   xE9,W
4486:  MOVLB  3
4488:  SUBWFB 02,W
448A:  MOVWF  02
448C:  MOVLB  1
448E:  MOVF   xEA,W
4490:  MOVLB  3
4492:  SUBWFB 03,W
4494:  MOVWF  03
4496:  MOVWF  xA3
4498:  MOVFF  02,3A2
449C:  MOVFF  01,3A1
44A0:  MOVFF  00,3A0
44A4:  BTFSS  FE8.7
44A6:  BRA    44AA
....................          continue; 
44A8:  BRA    466A
....................  
....................       // Load up extended TCB information 
....................       SyncTCB(); 
44AA:  MOVLB  0
44AC:  CALL   100C
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(MyTCBStub.smState) 
44B0:  MOVLB  1
44B2:  MOVF   xEF,W
44B4:  XORLW  05
44B6:  MOVLB  0
44B8:  BZ    44D8
44BA:  XORLW  03
44BC:  BZ    44FC
44BE:  XORLW  01
44C0:  BZ    452A
44C2:  XORLW  0C
44C4:  BZ    452A
44C6:  XORLW  03
44C8:  BZ    454C
44CA:  XORLW  01
44CC:  BZ    456C
44CE:  XORLW  03
44D0:  BZ    4578
44D2:  XORLW  06
44D4:  BZ    4598
44D6:  BRA    45BA
....................       { 
....................          #if defined(STACK_CLIENT_MODE) 
....................          #if defined(STACK_USE_DNS) 
....................          case TCP_GET_DNS_MODULE: 
....................             if(DNSBeginUsage()) 
....................             { 
....................                MyTCBStub.smState = TCP_DNS_RESOLVE; 
....................                if(MyTCB.flags.bRemoteHostIsROM) 
....................                   DNSResolveROM((ROM BYTE*)(ROM_PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
....................                else 
....................                   DNSResolve((BYTE*)(PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A); 
....................             } 
....................             break; 
....................              
....................          case TCP_DNS_RESOLVE: 
....................          { 
....................             IP_ADDR ipResolvedDNSIP; 
....................  
....................             // See if DNS resolution has finished.  Note that if the DNS  
....................             // fails, the &ipResolvedDNSIP will be written with 0x00000000.  
....................             // MyTCB.remote.dwRemoteHost is unioned with  
....................             // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write  
....................             // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We  
....................             // must copy it over only if the DNS is resolution step was  
....................             // successful. 
....................             if(DNSIsResolved(&ipResolvedDNSIP)) 
....................             { 
....................                if(DNSEndUsage()) 
....................                { 
....................                   MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val; 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
....................                   MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val; 
....................                   MyTCB.retryCount = 0; 
....................                   MyTCB.retryInterval = (TICK_SECOND/4)/256; 
....................                } 
....................                else 
....................                { 
....................                   MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND; 
....................                   MyTCBStub.smState = TCP_GET_DNS_MODULE; 
....................                } 
....................             } 
....................             break; 
....................          } 
....................          #endif // #if defined(STACK_USE_DNS) 
....................              
....................          case TCP_GATEWAY_SEND_ARP: 
....................             // Obtain the MAC address associated with the server's IP address (either direct MAC address on same subnet, or the MAC address of the Gateway machine) 
....................             MyTCBStub.eventTime2 = (WORD)TickGetDiv256(); 
....................             ARPResolve(&MyTCB.remote.niRemoteMACIP.IPAddr); 
....................             MyTCBStub.smState = TCP_GATEWAY_GET_ARP; 
....................             break; 
....................  
....................          case TCP_GATEWAY_GET_ARP: 
....................             // Wait for the MAC address to finish being obtained 
....................             if(!ARPIsResolved(&MyTCB.remote.niRemoteMACIP.IPAddr, &MyTCB.remote.niRemoteMACIP.MACAddr)) 
....................             { 
....................                // Time out if too much time is spent in this state 
....................                // Note that this will continuously send out ARP  
....................                // requests for an infinite time if the Gateway  
....................                // never responds 
....................                if((WORD)TickGetDiv256() - MyTCBStub.eventTime2 > (WORD)MyTCB.retryInterval) 
....................                { 
....................                   // Exponentially increase timeout until we reach 6 attempts then stay constant 
....................                   if(MyTCB.retryCount < 6u) 
....................                   { 
....................                      MyTCB.retryCount++; 
....................                      MyTCB.retryInterval <<= 1; 
....................                   } 
....................  
....................                   // Retransmit ARP request 
....................                   MyTCBStub.smState = TCP_GATEWAY_SEND_ARP; 
....................                } 
....................                break; 
....................             } 
....................              
....................             // Send out SYN connection request to remote node 
....................             // This automatically disables the Timer from  
....................             // continuously firing for this socket 
....................             vFlags = SYN; 
....................             bRetransmit = FALSE; 
....................             MyTCBStub.smState = TCP_SYN_SENT; 
....................             break; 
....................          #endif // #if defined(STACK_CLIENT_MODE) 
....................           
....................          case TCP_SYN_SENT: 
....................             // Keep sending SYN until we hear from remote node. 
....................             // This may be for infinite time, in that case 
....................             // caller must detect it and do something. 
....................             vFlags = SYN; 
44D8:  MOVLW  02
44DA:  MOVLB  3
44DC:  MOVWF  x9D
....................             bRetransmit = TRUE; 
44DE:  BSF    x9C.0
....................  
....................             // Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant 
....................             if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1)) 
44E0:  MOVLB  1
44E2:  MOVF   x9A,W
44E4:  SUBLW  03
44E6:  BC    44FA
....................             { 
....................                MyTCB.retryCount = TCP_MAX_RETRIES - 1; 
44E8:  MOVLW  04
44EA:  MOVWF  x9A
....................                MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1); 
44EC:  CLRF   x78
44EE:  MOVLW  01
44F0:  MOVWF  x77
44F2:  MOVLW  E8
44F4:  MOVWF  x76
44F6:  MOVLW  50
44F8:  MOVWF  x75
....................             } 
....................             break; 
44FA:  BRA    45BC
....................     
....................          case TCP_SYN_RECEIVED: 
....................             // We must receive ACK before timeout expires. 
....................             // If not, resend SYN+ACK. 
....................             // Abort, if maximum attempts counts are reached. 
....................             if(MyTCB.retryCount < TCP_MAX_SYN_RETRIES) 
44FC:  MOVLB  1
44FE:  MOVF   x9A,W
4500:  SUBLW  01
4502:  BNC   4510
....................             { 
....................                vFlags = SYN | ACK; 
4504:  MOVLW  12
4506:  MOVLB  3
4508:  MOVWF  x9D
....................                bRetransmit = TRUE; 
450A:  BSF    x9C.0
....................             } 
450C:  BRA    4526
450E:  MOVLB  1
....................             else 
....................             { 
....................                if(MyTCBStub.Flags.bServer) 
4510:  BTFSS  xF0.3
4512:  BRA    4520
....................                { 
....................                   vFlags = RST | ACK; 
4514:  MOVLW  14
4516:  MOVLB  3
4518:  MOVWF  x9D
....................                   bCloseSocket = TRUE; 
451A:  BSF    x9C.1
....................                } 
451C:  BRA    4526
451E:  MOVLB  1
....................                else 
....................                { 
....................                   vFlags = SYN; 
4520:  MOVLW  02
4522:  MOVLB  3
4524:  MOVWF  x9D
....................                } 
....................             } 
....................             break; 
4526:  MOVLB  1
4528:  BRA    45BC
....................     
....................          case TCP_ESTABLISHED: 
....................          case TCP_CLOSE_WAIT: 
....................             // Retransmit any unacknowledged data 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
452A:  MOVLB  1
452C:  MOVF   x9A,W
452E:  SUBLW  04
4530:  BNC   453E
....................             { 
....................                vFlags = ACK; 
4532:  MOVLW  10
4534:  MOVLB  3
4536:  MOVWF  x9D
....................                bRetransmit = TRUE; 
4538:  BSF    x9C.0
....................             } 
453A:  BRA    4548
453C:  MOVLB  1
....................             else 
....................             { 
....................                // No response back for too long, close connection 
....................                // This could happen, for instance, if the communication  
....................                // medium was lost 
....................                MyTCBStub.smState = TCP_FIN_WAIT_1; 
453E:  MOVLW  08
4540:  MOVWF  xEF
....................                vFlags = FIN | ACK; 
4542:  MOVLW  11
4544:  MOVLB  3
4546:  MOVWF  x9D
....................             } 
....................             break; 
4548:  MOVLB  1
454A:  BRA    45BC
....................     
....................          case TCP_FIN_WAIT_1: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
454C:  MOVLB  1
454E:  MOVF   x9A,W
4550:  SUBLW  04
4552:  BNC   4560
....................             { 
....................                // Send another FIN 
....................                vFlags = FIN | ACK; 
4554:  MOVLW  11
4556:  MOVLB  3
4558:  MOVWF  x9D
....................                bRetransmit = TRUE; 
455A:  BSF    x9C.0
....................             } 
455C:  BRA    4568
455E:  MOVLB  1
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
4560:  MOVLW  14
4562:  MOVLB  3
4564:  MOVWF  x9D
....................                bCloseSocket = TRUE; 
4566:  BSF    x9C.1
....................             } 
....................             break; 
4568:  MOVLB  1
456A:  BRA    45BC
....................     
....................          case TCP_FIN_WAIT_2: 
....................             // Close on our own, we can't seem to communicate  
....................             // with the remote node anymore 
....................             vFlags = RST | ACK; 
456C:  MOVLW  14
456E:  MOVLB  3
4570:  MOVWF  x9D
....................             bCloseSocket = TRUE; 
4572:  BSF    x9C.1
....................             break; 
4574:  MOVLB  1
4576:  BRA    45BC
....................  
....................          case TCP_CLOSING: 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
4578:  MOVLB  1
457A:  MOVF   x9A,W
457C:  SUBLW  04
457E:  BNC   458C
....................             { 
....................                // Send another ACK+FIN (the FIN is retransmitted  
....................                // automatically since it hasn't been acknowledged by  
....................                // the remote node yet) 
....................                vFlags = ACK; 
4580:  MOVLW  10
4582:  MOVLB  3
4584:  MOVWF  x9D
....................                bRetransmit = TRUE; 
4586:  BSF    x9C.0
....................             } 
4588:  BRA    4594
458A:  MOVLB  1
....................             else 
....................             { 
....................                // Close on our own, we can't seem to communicate  
....................                // with the remote node anymore 
....................                vFlags = RST | ACK; 
458C:  MOVLW  14
458E:  MOVLB  3
4590:  MOVWF  x9D
....................                bCloseSocket = TRUE; 
4592:  BSF    x9C.1
....................             } 
....................             break; 
4594:  MOVLB  1
4596:  BRA    45BC
....................     
.................... //         case TCP_TIME_WAIT: 
.................... //            // Wait around for a while (2MSL) and then goto closed state 
.................... //            bCloseSocket = TRUE; 
.................... //            break; 
.................... //          
....................  
....................          case TCP_LAST_ACK: 
....................             // Send some more FINs or close anyway 
....................             if(MyTCB.retryCount < TCP_MAX_RETRIES) 
4598:  MOVLB  1
459A:  MOVF   x9A,W
459C:  SUBLW  04
459E:  BNC   45AC
....................             { 
....................                vFlags = FIN | ACK; 
45A0:  MOVLW  11
45A2:  MOVLB  3
45A4:  MOVWF  x9D
....................                bRetransmit = TRUE; 
45A6:  BSF    x9C.0
....................             } 
45A8:  BRA    45B4
45AA:  MOVLB  1
....................             else 
....................             { 
....................                vFlags = RST | ACK; 
45AC:  MOVLW  14
45AE:  MOVLB  3
45B0:  MOVWF  x9D
....................                bCloseSocket = TRUE; 
45B2:  BSF    x9C.1
....................             } 
....................             break; 
45B4:  MOVLB  1
45B6:  BRA    45BC
45B8:  MOVLB  0
....................           
....................          default: 
....................             break; 
45BA:  MOVLB  1
....................       } 
....................  
....................       if(vFlags) 
45BC:  MOVLB  3
45BE:  MOVF   x9D,F
45C0:  BZ    465E
....................       { 
....................          // Transmit all unacknowledged data over again 
....................          if(bRetransmit) 
45C2:  BTFSS  x9C.0
45C4:  BRA    464E
....................          { 
....................             // Set the appropriate retry time 
....................             MyTCB.retryCount++; 
45C6:  MOVLB  1
45C8:  INCF   x9A,F
....................             MyTCB.retryInterval <<= 1; 
45CA:  BCF    FD8.0
45CC:  RLCF   x75,F
45CE:  RLCF   x76,F
45D0:  RLCF   x77,F
45D2:  RLCF   x78,F
....................        
....................             // Calculate how many bytes we have to roll back and retransmit 
....................             w = MyTCB.txUnackedTail - MyTCBStub.txTail; 
45D4:  MOVF   xE1,W
45D6:  SUBWF  x81,W
45D8:  MOVLB  3
45DA:  MOVWF  x9E
45DC:  MOVLB  1
45DE:  MOVF   xE2,W
45E0:  SUBWFB x82,W
45E2:  MOVLB  3
45E4:  MOVWF  x9F
....................             if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
45E6:  MOVLB  1
45E8:  MOVF   x82,W
45EA:  SUBWF  xE2,W
45EC:  BNC   460E
45EE:  BNZ   45F6
45F0:  MOVF   xE1,W
45F2:  SUBWF  x81,W
45F4:  BC    460E
....................                w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
45F6:  MOVF   xD9,W
45F8:  SUBWF  xDB,W
45FA:  MOVWF  00
45FC:  MOVF   xDA,W
45FE:  SUBWFB xDC,W
4600:  MOVWF  03
4602:  MOVF   00,W
4604:  MOVLB  3
4606:  ADDWF  x9E,F
4608:  MOVF   03,W
460A:  ADDWFC x9F,F
460C:  MOVLB  1
....................              
....................             // Perform roll back of local SEQuence counter, remote window  
....................             // adjustment, and cause all unacknowledged data to be  
....................             // retransmitted by moving the unacked tail pointer. 
....................             MyTCB.MySEQ -= w; 
460E:  MOVLB  3
4610:  MOVF   x9E,W
4612:  MOVLB  1
4614:  SUBWF  x79,F
4616:  MOVLB  3
4618:  MOVF   x9F,W
461A:  MOVLB  1
461C:  SUBWFB x7A,F
461E:  MOVLW  00
4620:  SUBWFB x7B,F
4622:  SUBWFB x7C,F
....................             MyTCB.remoteWindow += w; 
4624:  MOVLB  3
4626:  MOVF   x9E,W
4628:  MOVLB  1
462A:  ADDWF  x87,F
462C:  MOVLB  3
462E:  MOVF   x9F,W
4630:  MOVLB  1
4632:  ADDWFC x88,F
....................             MyTCB.txUnackedTail = MyTCBStub.txTail;       
4634:  MOVFF  1E2,182
4638:  MOVFF  1E1,181
....................             SendTCP(vFlags, 0); 
463C:  MOVFF  39D,3E6
4640:  MOVLB  3
4642:  CLRF   xE7
4644:  MOVLB  0
4646:  CALL   3870
....................          } 
464A:  BRA    465C
464C:  MOVLB  3
....................          else 
....................             SendTCP(vFlags, SENDTCP_RESET_TIMERS); 
464E:  MOVFF  39D,3E6
4652:  MOVLW  01
4654:  MOVWF  xE7
4656:  MOVLB  0
4658:  CALL   3870
465C:  MOVLB  3
....................  
....................       } 
....................        
....................       if(bCloseSocket) 
465E:  BTFSS  x9C.1
4660:  BRA    466A
....................          CloseSocket(); 
4662:  MOVLB  0
4664:  CALL   10E4
4668:  MOVLB  3
....................    } 
....................     
....................     
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
466A:  INCF   x9B,F
466C:  BRA    3FB4
....................       // Process SYN Queue entry timeouts 
....................       for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++) 
466E:  CLRF   x9F
4670:  CLRF   x9E
4672:  MOVF   x9F,F
4674:  BTFSS  FD8.2
4676:  BRA    47EA
4678:  MOVF   x9E,W
467A:  SUBLW  02
467C:  BTFSS  FD8.0
467E:  BRA    47EA
....................       { 
....................          // Abort search if there are no more valid records 
....................          if(SYNQueue[w].wDestPort == 0u) 
4680:  MOVFF  39F,3D1
4684:  MOVFF  39E,3D0
4688:  CLRF   xD3
468A:  MOVLW  14
468C:  MOVWF  xD2
468E:  MOVLB  0
4690:  CALL   3252
4694:  MOVFF  01,3A0
4698:  MOVLW  10
469A:  MOVLB  3
469C:  ADDWF  01,W
469E:  MOVWF  01
46A0:  MOVLW  00
46A2:  ADDWFC 02,W
46A4:  MOVWF  03
46A6:  MOVF   01,W
46A8:  ADDLW  9D
46AA:  MOVWF  FE9
46AC:  MOVLW  01
46AE:  ADDWFC 03,W
46B0:  MOVWF  FEA
46B2:  MOVFF  FEC,3A1
46B6:  MOVF   FED,F
46B8:  MOVFF  FEF,3A0
46BC:  MOVF   xA0,F
46BE:  BNZ   46C6
46C0:  MOVF   xA1,F
46C2:  BNZ   46C6
....................             break; 
46C4:  BRA    47EA
....................           
....................          // See if this SYN has timed out 
....................          if((WORD)TickGetDiv256() - SYNQueue[w].wTimestamp > (WORD)(TCP_SYN_QUEUE_TIMEOUT/256ull)) 
46C6:  MOVLB  0
46C8:  CALL   322C
46CC:  MOVFF  01,3A1
46D0:  MOVFF  00,3A0
46D4:  MOVFF  39F,3D1
46D8:  MOVFF  39E,3D0
46DC:  MOVLB  3
46DE:  CLRF   xD3
46E0:  MOVLW  14
46E2:  MOVWF  xD2
46E4:  MOVLB  0
46E6:  CALL   3252
46EA:  MOVFF  02,3A3
46EE:  MOVFF  01,3A2
46F2:  MOVLW  12
46F4:  MOVLB  3
46F6:  ADDWF  01,W
46F8:  MOVWF  01
46FA:  MOVLW  00
46FC:  ADDWFC 02,W
46FE:  MOVWF  03
4700:  MOVF   01,W
4702:  ADDLW  9D
4704:  MOVWF  FE9
4706:  MOVLW  01
4708:  ADDWFC 03,W
470A:  MOVWF  FEA
470C:  MOVFF  FEC,03
4710:  MOVF   FED,F
4712:  MOVF   FEF,W
4714:  SUBWF  xA0,F
4716:  MOVF   03,W
4718:  SUBWFB xA1,F
471A:  BNZ   4722
471C:  MOVF   xA0,W
471E:  SUBLW  5B
4720:  BC    47E2
....................          { 
....................             // Delete this SYN from the SYNQueue and compact the SYNQueue[] array 
....................             TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE)); 
4722:  MOVFF  39F,3D1
4726:  MOVFF  39E,3D0
472A:  CLRF   xD3
472C:  MOVLW  14
472E:  MOVWF  xD2
4730:  MOVLB  0
4732:  CALL   3252
4736:  MOVFF  02,03
473A:  MOVF   01,W
473C:  ADDLW  9D
473E:  MOVWF  01
4740:  MOVLW  01
4742:  ADDWFC 03,F
4744:  MOVFF  01,3A0
4748:  MOVLB  3
474A:  MOVFF  03,3A1
474E:  MOVLW  01
4750:  ADDWF  x9E,W
4752:  MOVWF  xA2
4754:  MOVLW  00
4756:  ADDWFC x9F,W
4758:  MOVWF  xA3
475A:  MOVWF  xD1
475C:  MOVFF  3A2,3D0
4760:  CLRF   xD3
4762:  MOVLW  14
4764:  MOVWF  xD2
4766:  MOVLB  0
4768:  CALL   3252
476C:  MOVFF  02,03
4770:  MOVF   01,W
4772:  ADDLW  9D
4774:  MOVWF  01
4776:  MOVLW  01
4778:  ADDWFC 03,F
477A:  MOVFF  01,3A2
477E:  MOVLB  3
4780:  MOVFF  03,3A3
4784:  MOVLW  02
4786:  BSF    FD8.0
4788:  SUBFWB x9E,W
478A:  MOVWF  xA4
478C:  MOVLW  00
478E:  SUBFWB x9F,W
4790:  MOVWF  xA5
4792:  MOVWF  xD1
4794:  MOVFF  3A4,3D0
4798:  CLRF   xD3
479A:  MOVLW  14
479C:  MOVWF  xD2
479E:  MOVLB  0
47A0:  CALL   3252
47A4:  MOVFF  02,3A5
47A8:  MOVFF  01,3A4
47AC:  MOVFF  3A1,418
47B0:  MOVFF  3A0,417
47B4:  MOVLW  01
47B6:  MOVLB  4
47B8:  MOVWF  x19
47BA:  MOVFF  3A3,41B
47BE:  MOVFF  3A2,41A
47C2:  MOVWF  x1C
47C4:  MOVFF  02,41E
47C8:  MOVFF  01,41D
47CC:  MOVLB  0
47CE:  CALL   0F26
....................             SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u; 
47D2:  MOVLB  1
47D4:  CLRF   xD6
47D6:  CLRF   xD5
....................     
....................             // Since we deleted an entry, we need to roll back one  
....................             // index so next loop will process the correct record 
....................             w--;    
47D8:  MOVLB  3
47DA:  MOVF   x9E,W
47DC:  BTFSC  FD8.2
47DE:  DECF   x9F,F
47E0:  DECF   x9E,F
....................          } 
47E2:  INCF   x9E,F
47E4:  BTFSC  FD8.2
47E6:  INCF   x9F,F
47E8:  BRA    4672
....................       } 
....................    #endif 
47EA:  MOVLB  0
47EC:  GOTO   6D98 (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
....................  
....................   Summary: 
....................      Handles incoming TCP segments. 
....................  
....................   Description: 
....................    This function handles incoming TCP segments.  When a segment arrives, it 
....................    is compared to open sockets using a hash of the remote port and IP.   
....................    On a match, the data is passed to HandleTCPSeg for further processing. 
....................  
....................   Precondition: 
....................    TCP is initialized and a TCP segment is ready in the MAC buffer. 
....................  
....................   Parameters: 
....................    remote - Remote NODE_INFO structure 
....................    localIP - This stack's IP address (for header checking) 
....................    len - Total length of the waiting TCP segment 
....................  
....................   Return Values: 
....................    TRUE - the segment was properly handled. 
....................    FALSE - otherwise 
....................   ***************************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
6890:  MOVLB  3
6892:  MOVFF  39B,FE9
6896:  MOVFF  39C,FEA
689A:  MOVFF  FEF,00
689E:  MOVFF  FEC,01
68A2:  MOVFF  FEC,02
68A6:  MOVFF  FEC,03
68AA:  MOVFF  00,3B5
68AE:  MOVFF  01,3B6
68B2:  MOVFF  02,3B7
68B6:  MOVFF  03,3B8
....................    pseudoHeader.DestAddress        = *localIP; 
68BA:  MOVFF  39D,FE9
68BE:  MOVFF  39E,FEA
68C2:  MOVFF  FEF,00
68C6:  MOVFF  FEC,01
68CA:  MOVFF  FEC,02
68CE:  MOVFF  FEC,03
68D2:  MOVFF  00,3B9
68D6:  MOVFF  01,3BA
68DA:  MOVFF  02,3BB
68DE:  MOVFF  03,3BC
....................    pseudoHeader.Zero               = 0x0; 
68E2:  CLRF   xBD
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
68E4:  MOVLW  06
68E6:  MOVWF  xBE
....................    pseudoHeader.Length             = len; 
68E8:  MOVFF  3A0,3C0
68EC:  MOVFF  39F,3BF
....................  
....................    SwapPseudoHeader(pseudoHeader); 
68F0:  MOVFF  3C0,430
68F4:  MOVFF  3BF,42F
68F8:  MOVLB  0
68FA:  CALL   1C92
68FE:  MOVFF  02,3C0
6902:  MOVFF  01,3BF
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
6906:  MOVLW  03
6908:  MOVLB  3
690A:  MOVWF  xC7
690C:  MOVLW  B5
690E:  MOVWF  xC6
6910:  MOVFF  3C7,42C
6914:  MOVFF  FE8,42B
6918:  MOVLB  4
691A:  CLRF   x2E
691C:  MOVLW  0C
691E:  MOVWF  x2D
6920:  MOVLB  0
6922:  CALL   1D8E
6926:  MOVFF  01,3C1
692A:  MOVLB  3
692C:  COMF   xC1,F
692E:  MOVFF  02,3C2
6932:  COMF   xC2,F
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
6934:  MOVFF  3A0,411
6938:  MOVFF  39F,410
693C:  MOVLB  0
693E:  CALL   3728
6942:  MOVFF  02,3C4
6946:  MOVFF  01,3C3
....................  
....................    // Compare checksums. 
....................    if(checksum1.Val != checksum2.Val) 
694A:  MOVLB  3
694C:  MOVF   xC3,W
694E:  SUBWF  xC1,W
6950:  BNZ   6958
6952:  MOVF   xC4,W
6954:  SUBWF  xC2,W
6956:  BZ    6966
....................    { 
....................       MACDiscardRx(); 
6958:  MOVLB  0
695A:  CALL   2870
....................       return TRUE; 
695E:  MOVLW  01
6960:  MOVWF  01
6962:  BRA    6A08
6964:  MOVLB  3
....................    } 
....................  
.................... #if defined(DEBUG_GENERATE_RX_LOSS) 
....................    // Throw RX packets away randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_RX_LOSS) 
....................    { 
....................       MACDiscardRx(); 
....................       return TRUE; 
....................    } 
.................... #endif 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
6966:  CLRF   xEB
6968:  CLRF   xEA
696A:  MOVLB  0
696C:  CALL   2712
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
6970:  MOVLW  03
6972:  MOVLB  3
6974:  MOVWF  xC7
6976:  MOVLW  A1
6978:  MOVWF  xC6
697A:  MOVFF  3C7,433
697E:  MOVFF  FE8,432
6982:  MOVLB  4
6984:  CLRF   x35
6986:  MOVLW  14
6988:  MOVWF  x34
698A:  MOVLB  0
698C:  CALL   0BD0
....................    SwapTCPHeader(&TCPHeader); 
6990:  MOVLW  03
6992:  MOVLB  4
6994:  MOVWF  x11
6996:  MOVLW  A1
6998:  MOVWF  x10
699A:  MOVLB  0
699C:  CALL   3502
....................  
....................  
....................    // Skip over options to retrieve data bytes 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
69A0:  MOVLB  3
69A2:  SWAPF  xAD,W
69A4:  ANDLW  0F
69A6:  MOVWF  00
69A8:  RLCF   00,F
69AA:  RLCF   00,F
69AC:  MOVLW  FC
69AE:  ANDWF  00,F
69B0:  MOVF   00,W
69B2:  ADDLW  EC
69B4:  MOVWF  xC5
....................    len = len - optionsSize - sizeof(TCPHeader); 
69B6:  MOVF   xC5,W
69B8:  SUBWF  x9F,W
69BA:  MOVWF  xC6
69BC:  MOVLW  00
69BE:  SUBWFB xA0,W
69C0:  MOVWF  xC7
69C2:  MOVLW  14
69C4:  SUBWF  xC6,W
69C6:  MOVWF  x9F
69C8:  MOVLW  00
69CA:  SUBWFB xC7,W
69CC:  MOVWF  xA0
....................  
....................    // Find matching socket. 
....................    if(FindMatchingTCPSocket(&TCPHeader, remote)) 
69CE:  MOVLW  03
69D0:  MOVWF  xC7
69D2:  MOVLW  A1
69D4:  MOVWF  xC6
69D6:  MOVFF  39C,3C9
69DA:  MOVFF  39B,3C8
69DE:  MOVLB  0
69E0:  GOTO   4F70
69E4:  MOVF   01,F
69E6:  BZ    6A00
....................    { 
....................       #if defined(STACK_USE_SSL) 
....................       PTR_BASE prevRxHead; 
....................       // For SSL connections, show HandleTCPSeg() the full data buffer 
....................       prevRxHead = MyTCBStub.rxHead; 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................          MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................       #endif 
....................        
....................       HandleTCPSeg(&TCPHeader, len); 
69E8:  MOVLW  03
69EA:  MOVLB  3
69EC:  MOVWF  xC7
69EE:  MOVLW  A1
69F0:  MOVWF  xC6
69F2:  MOVFF  3A0,3C9
69F6:  MOVFF  39F,3C8
69FA:  MOVLB  0
69FC:  GOTO   56B8
....................        
....................       #if defined(STACK_USE_SSL) 
....................       if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       { 
....................          // Restore the buffer state 
....................          MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          MyTCBStub.rxHead = prevRxHead; 
....................  
....................          // Process the new SSL data, using the currently loaded stub 
....................          TCPSSLHandleIncoming(hCurrentTCP); 
....................       } 
....................       #endif 
....................    } 
.................... //   else 
.................... //   { 
.................... //      // NOTE: RFC 793 specifies that if the socket is closed and a segment  
.................... //      // arrives, we should send back a RST if the RST bit in the incoming  
.................... //      // packet is not set.  Instead, we will just silently ignore such a  
.................... //      // packet since this is what firewalls do on purpose to enhance  
.................... //      // security. 
.................... //      //if(!TCPHeader.Flags.bits.flagRST) 
.................... //      //   SendTCP(RST, SENDTCP_RESET_TIMERS); 
.................... //   } 
....................  
....................    // Finished with this packet, discard it and free the Ethernet RAM for new packets 
....................    MACDiscardRx(); 
6A00:  CALL   2870
....................  
....................    return TRUE; 
6A04:  MOVLW  01
6A06:  MOVWF  01
6A08:  GOTO   6EFA (RETURN)
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
....................  
....................   Summary: 
....................    Transmits a TPC segment. 
....................  
....................   Description: 
....................    This function assembles and transmits a TCP segment, including any  
....................    pending data.  It also supports retransmissions, keep-alives, and  
....................    other packet types. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    vTCPFlags - Additional TCP flags to include 
....................    vSendFlags - Any combinations of SENDTCP_* constants to modify the 
....................              transmit behavior or contents. 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SendTCP(BYTE vTCPFlags, BYTE vSendFlags) 
.................... { 
....................    WORD_VAL        wVal; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    WORD          len; 
....................     
....................    SyncTCB(); 
*
3870:  CALL   100C
....................  
....................    // FINs must be handled specially 
....................    if(vTCPFlags & FIN) 
3874:  MOVLB  3
3876:  BTFSS  xE6.0
3878:  BRA    3882
....................    { 
....................       MyTCBStub.Flags.bTXFIN = 1; 
387A:  MOVLB  1
387C:  BSF    xF1.3
....................       vTCPFlags &= ~FIN; 
387E:  MOVLB  3
3880:  BCF    xE6.0
....................    } 
....................  
....................    // Status will now be synched, disable automatic future  
....................    // status transmissions 
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
3882:  MOVLB  1
3884:  BCF    xF0.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
3886:  BCF    xF0.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
3888:  BCF    xF0.7
....................    MyTCBStub.Flags.bTXASAP = 0; 
388A:  BCF    xF1.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
388C:  BCF    xF1.2
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
388E:  BCF    xF1.0
....................  
....................    //  Make sure that we can write to the MAC transmit area 
....................    while(!IPIsTxReady()); 
3890:  MOVLB  0
3892:  CALL   19F2
3896:  MOVF   01,F
3898:  BZ    3892
....................  
....................    // Put all socket application data in the TX space 
....................    if(vTCPFlags & (SYN | RST)) 
389A:  MOVLB  3
389C:  MOVF   xE6,W
389E:  ANDLW  06
38A0:  BZ    38AC
....................    { 
....................       // Don't put any data in SYN and RST messages 
....................       len = 0; 
38A2:  MOVLB  4
38A4:  CLRF   x0F
38A6:  CLRF   x0E
....................    } 
38A8:  BRA    3AE2
38AA:  MOVLB  3
....................    else 
....................    { 
....................       // Begin copying any application data over to the TX space 
....................       if(MyTCBStub.txHead == MyTCB.txUnackedTail) 
38AC:  MOVLB  1
38AE:  MOVF   x81,W
38B0:  SUBWF  xDF,W
38B2:  BNZ   38C4
38B4:  MOVF   x82,W
38B6:  SUBWF  xE0,W
38B8:  BNZ   38C4
....................       { 
....................          // All caught up on data TX, no real data for this packet 
....................          len = 0; 
38BA:  MOVLB  4
38BC:  CLRF   x0F
38BE:  CLRF   x0E
....................       } 
38C0:  BRA    3AB0
38C2:  MOVLB  1
....................       else if(MyTCBStub.txHead > MyTCB.txUnackedTail) 
38C4:  MOVF   x82,W
38C6:  SUBWF  xE0,W
38C8:  BNC   3968
38CA:  BNZ   38D2
38CC:  MOVF   xDF,W
38CE:  SUBWF  x81,W
38D0:  BC    3968
....................       { 
....................          len = MyTCBStub.txHead - MyTCB.txUnackedTail; 
38D2:  MOVF   x81,W
38D4:  SUBWF  xDF,W
38D6:  MOVLB  4
38D8:  MOVWF  x0E
38DA:  MOVLB  1
38DC:  MOVF   x82,W
38DE:  SUBWFB xE0,W
38E0:  MOVLB  4
38E2:  MOVWF  x0F
....................  
....................          if(len > MyTCB.remoteWindow) 
38E4:  MOVLB  1
38E6:  MOVF   x88,W
38E8:  MOVLB  4
38EA:  SUBWF  x0F,W
38EC:  BNC   3908
38EE:  BNZ   3900
38F0:  MOVF   x0E,W
38F2:  MOVLB  1
38F4:  SUBWF  x87,W
38F6:  BTFSS  FD8.0
38F8:  BRA    38FE
38FA:  MOVLB  4
38FC:  BRA    3908
38FE:  MOVLB  4
....................             len = MyTCB.remoteWindow; 
3900:  MOVFF  188,40F
3904:  MOVFF  187,40E
....................  
....................          if(len > MyTCB.wRemoteMSS) 
3908:  MOVLB  1
390A:  MOVF   x99,W
390C:  MOVLB  4
390E:  SUBWF  x0F,W
3910:  BNC   3932
3912:  BNZ   3924
3914:  MOVF   x0E,W
3916:  MOVLB  1
3918:  SUBWF  x98,W
391A:  BTFSS  FD8.0
391C:  BRA    3922
391E:  MOVLB  4
3920:  BRA    3932
3922:  MOVLB  4
....................          { 
....................             len = MyTCB.wRemoteMSS; 
3924:  MOVFF  199,40F
3928:  MOVFF  198,40E
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
392C:  MOVLB  1
392E:  BSF    xF1.2
3930:  MOVLB  4
....................          } 
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len); 
3932:  MOVLW  12
3934:  MOVWF  x18
3936:  MOVLW  0D
3938:  MOVWF  x17
393A:  CLRF   x19
393C:  MOVFF  182,41B
3940:  MOVFF  181,41A
3944:  MOVFF  1F4,41C
3948:  MOVFF  40F,41E
394C:  MOVFF  40E,41D
3950:  MOVLB  0
3952:  CALL   0F26
....................          MyTCB.txUnackedTail += len; 
3956:  MOVLB  4
3958:  MOVF   x0E,W
395A:  MOVLB  1
395C:  ADDWF  x81,F
395E:  MOVLB  4
3960:  MOVF   x0F,W
3962:  MOVLB  1
3964:  ADDWFC x82,F
....................       } 
3966:  BRA    3AAE
....................       else 
....................       { 
....................          pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail; 
3968:  MOVF   x81,W
396A:  SUBWF  xDB,W
396C:  MOVLB  4
396E:  MOVWF  x0C
3970:  MOVLB  1
3972:  MOVF   x82,W
3974:  SUBWFB xDC,W
3976:  MOVLB  4
3978:  MOVWF  x0D
....................          len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart; 
397A:  MOVLB  1
397C:  MOVF   xDF,W
397E:  MOVLB  4
3980:  ADDWF  x0C,W
3982:  MOVWF  x10
3984:  MOVLB  1
3986:  MOVF   xE0,W
3988:  MOVLB  4
398A:  ADDWFC x0D,W
398C:  MOVWF  x11
398E:  MOVLB  1
3990:  MOVF   xD9,W
3992:  MOVLB  4
3994:  SUBWF  x10,W
3996:  MOVWF  x0E
3998:  MOVLB  1
399A:  MOVF   xDA,W
399C:  MOVLB  4
399E:  SUBWFB x11,W
39A0:  MOVWF  x0F
....................  
....................          if(len > MyTCB.remoteWindow) 
39A2:  MOVLB  1
39A4:  MOVF   x88,W
39A6:  MOVLB  4
39A8:  SUBWF  x0F,W
39AA:  BNC   39C6
39AC:  BNZ   39BE
39AE:  MOVF   x0E,W
39B0:  MOVLB  1
39B2:  SUBWF  x87,W
39B4:  BTFSS  FD8.0
39B6:  BRA    39BC
39B8:  MOVLB  4
39BA:  BRA    39C6
39BC:  MOVLB  4
....................             len = MyTCB.remoteWindow; 
39BE:  MOVFF  188,40F
39C2:  MOVFF  187,40E
....................  
....................          if(len > MyTCB.wRemoteMSS) 
39C6:  MOVLB  1
39C8:  MOVF   x99,W
39CA:  MOVLB  4
39CC:  SUBWF  x0F,W
39CE:  BNC   39F0
39D0:  BNZ   39E2
39D2:  MOVF   x0E,W
39D4:  MOVLB  1
39D6:  SUBWF  x98,W
39D8:  BTFSS  FD8.0
39DA:  BRA    39E0
39DC:  MOVLB  4
39DE:  BRA    39F0
39E0:  MOVLB  4
....................          { 
....................             len = MyTCB.wRemoteMSS; 
39E2:  MOVFF  199,40F
39E6:  MOVFF  198,40E
....................             MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
39EA:  MOVLB  1
39EC:  BSF    xF1.2
39EE:  MOVLB  4
....................          } 
....................  
....................          if(pseudoHeader.Length > len) 
39F0:  MOVF   x0F,W
39F2:  SUBWF  x0D,W
39F4:  BNC   3A06
39F6:  BNZ   39FE
39F8:  MOVF   x0C,W
39FA:  SUBWF  x0E,W
39FC:  BC    3A06
....................             pseudoHeader.Length = len; 
39FE:  MOVFF  40F,40D
3A02:  MOVFF  40E,40C
....................  
....................          // Copy application data into the raw TX buffer 
....................          TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
3A06:  MOVLW  12
3A08:  MOVWF  x18
3A0A:  MOVLW  0D
3A0C:  MOVWF  x17
3A0E:  CLRF   x19
3A10:  MOVFF  182,41B
3A14:  MOVFF  181,41A
3A18:  MOVFF  1F4,41C
3A1C:  MOVFF  40D,41E
3A20:  MOVFF  40C,41D
3A24:  MOVLB  0
3A26:  CALL   0F26
....................          pseudoHeader.Length = len - pseudoHeader.Length; 
3A2A:  MOVLB  4
3A2C:  MOVF   x0C,W
3A2E:  SUBWF  x0E,W
3A30:  MOVWF  x0C
3A32:  MOVF   x0D,W
3A34:  SUBWFB x0F,W
3A36:  MOVWF  x0D
....................     
....................          // Copy any left over chunks of application data over 
....................          if(pseudoHeader.Length) 
3A38:  MOVF   x0C,W
3A3A:  IORWF  x0D,W
3A3C:  BZ    3A7E
....................          { 
....................             TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length); 
3A3E:  MOVLB  1
3A40:  MOVF   x81,W
3A42:  SUBWF  xDB,W
3A44:  MOVWF  00
3A46:  MOVF   x82,W
3A48:  SUBWFB xDC,W
3A4A:  MOVWF  03
3A4C:  MOVF   00,W
3A4E:  ADDLW  0D
3A50:  MOVLB  4
3A52:  MOVWF  x10
3A54:  MOVLW  12
3A56:  ADDWFC 03,W
3A58:  MOVWF  x11
3A5A:  MOVWF  x18
3A5C:  MOVFF  410,417
3A60:  CLRF   x19
3A62:  MOVFF  1DA,41B
3A66:  MOVFF  1D9,41A
3A6A:  MOVFF  1F4,41C
3A6E:  MOVFF  40D,41E
3A72:  MOVFF  40C,41D
3A76:  MOVLB  0
3A78:  CALL   0F26
3A7C:  MOVLB  4
....................          } 
....................  
....................          MyTCB.txUnackedTail += len; 
3A7E:  MOVF   x0E,W
3A80:  MOVLB  1
3A82:  ADDWF  x81,F
3A84:  MOVLB  4
3A86:  MOVF   x0F,W
3A88:  MOVLB  1
3A8A:  ADDWFC x82,F
....................          if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
3A8C:  MOVF   xDC,W
3A8E:  SUBWF  x82,W
3A90:  BNC   3AAE
3A92:  BNZ   3A9A
3A94:  MOVF   xDB,W
3A96:  SUBWF  x81,W
3A98:  BNC   3AAE
....................             MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart; 
3A9A:  MOVF   xD9,W
3A9C:  SUBWF  xDB,W
3A9E:  MOVWF  00
3AA0:  MOVF   xDA,W
3AA2:  SUBWFB xDC,W
3AA4:  MOVWF  03
3AA6:  MOVF   00,W
3AA8:  SUBWF  x81,F
3AAA:  MOVF   03,W
3AAC:  SUBWFB x82,F
3AAE:  MOVLB  4
....................       } 
....................  
....................       // If we are to transmit a FIN, make sure we can put one in this packet 
....................       if(MyTCBStub.Flags.bTXFIN) 
3AB0:  MOVLB  1
3AB2:  BTFSS  xF1.3
3AB4:  BRA    3AE4
....................       { 
....................          if((len != MyTCB.remoteWindow) && (len != MyTCB.wRemoteMSS)) 
3AB6:  MOVF   x87,W
3AB8:  MOVLB  4
3ABA:  SUBWF  x0E,W
3ABC:  BNZ   3AC8
3ABE:  MOVLB  1
3AC0:  MOVF   x88,W
3AC2:  MOVLB  4
3AC4:  SUBWF  x0F,W
3AC6:  BZ    3AE2
3AC8:  MOVLB  1
3ACA:  MOVF   x98,W
3ACC:  MOVLB  4
3ACE:  SUBWF  x0E,W
3AD0:  BNZ   3ADC
3AD2:  MOVLB  1
3AD4:  MOVF   x99,W
3AD6:  MOVLB  4
3AD8:  SUBWF  x0F,W
3ADA:  BZ    3AE2
....................             vTCPFlags |= FIN; 
3ADC:  MOVLB  3
3ADE:  BSF    xE6.0
3AE0:  MOVLB  4
3AE2:  MOVLB  1
....................       } 
....................    } 
....................  
....................    // Ensure that all packets with data of some kind are  
....................    // retransmitted by TCPTick() until acknowledged 
....................    // Pure ACK packets with no data are not ACKed back in TCP 
....................    if(len || (vTCPFlags & (SYN | FIN))) 
3AE4:  MOVLB  4
3AE6:  MOVF   x0E,W
3AE8:  IORWF  x0F,W
3AEA:  BNZ   3AF6
3AEC:  MOVLB  3
3AEE:  MOVF   xE6,W
3AF0:  ANDLW  03
3AF2:  BZ    3B60
3AF4:  MOVLB  4
....................    { 
....................       // Transmitting data, update remote window variable to reflect smaller  
....................       // window. 
....................       MyTCB.remoteWindow -= len; 
3AF6:  MOVF   x0E,W
3AF8:  MOVLB  1
3AFA:  SUBWF  x87,F
3AFC:  MOVLB  4
3AFE:  MOVF   x0F,W
3B00:  MOVLB  1
3B02:  SUBWFB x88,F
....................  
....................       // Push (PSH) all data for enhanced responsiveness on  
....................       // the remote end, especially with GUIs 
....................       if(len) 
3B04:  MOVLB  4
3B06:  MOVF   x0E,W
3B08:  IORWF  x0F,W
3B0A:  BZ    3B12
....................          vTCPFlags |= PSH; 
3B0C:  MOVLB  3
3B0E:  BSF    xE6.3
3B10:  MOVLB  4
....................  
....................       if(vSendFlags & SENDTCP_RESET_TIMERS) 
3B12:  MOVLB  3
3B14:  BTFSS  xE7.0
3B16:  BRA    3B2A
....................       { 
....................          MyTCB.retryCount = 0; 
3B18:  MOVLB  1
3B1A:  CLRF   x9A
....................          MyTCB.retryInterval = TCP_START_TIMEOUT_VAL; 
3B1C:  CLRF   x78
3B1E:  CLRF   x77
3B20:  MOVLW  1E
3B22:  MOVWF  x76
3B24:  MOVLW  85
3B26:  MOVWF  x75
3B28:  MOVLB  3
....................       }    
....................  
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
3B2A:  MOVLB  0
3B2C:  CALL   2692
3B30:  MOVLB  1
3B32:  MOVF   x75,W
3B34:  MOVLB  4
3B36:  ADDWF  00,W
3B38:  MOVLB  1
3B3A:  MOVWF  xE7
3B3C:  MOVF   x76,W
3B3E:  MOVLB  4
3B40:  ADDWFC 01,W
3B42:  MOVLB  1
3B44:  MOVWF  xE8
3B46:  MOVF   x77,W
3B48:  MOVLB  4
3B4A:  ADDWFC 02,W
3B4C:  MOVLB  1
3B4E:  MOVWF  xE9
3B50:  MOVF   x78,W
3B52:  MOVLB  4
3B54:  ADDWFC 03,W
3B56:  MOVLB  1
3B58:  MOVWF  xEA
....................       MyTCBStub.Flags.bTimerEnabled = 1; 
3B5A:  BSF    xF0.4
....................    } 
3B5C:  BRA    3BDC
3B5E:  MOVLB  3
....................    else if(vSendFlags & SENDTCP_KEEP_ALIVE) 
3B60:  BTFSS  xE7.1
3B62:  BRA    3B8C
....................    { 
....................       // Increment Keep Alive TX counter to handle disconnection if not response is returned 
....................       MyTCBStub.Flags.vUnackedKeepalives++; 
3B64:  MOVLB  1
3B66:  MOVF   xF0,W
3B68:  ADDLW  01
3B6A:  ANDLW  07
3B6C:  MOVWF  00
3B6E:  MOVLW  F8
3B70:  ANDWF  xF0,W
3B72:  IORWF  00,W
3B74:  MOVWF  xF0
....................        
....................       // Generate a dummy byte 
....................       MyTCB.MySEQ -= 1; 
3B76:  MOVLW  01
3B78:  SUBWF  x79,F
3B7A:  MOVLW  00
3B7C:  SUBWFB x7A,F
3B7E:  SUBWFB x7B,F
3B80:  SUBWFB x7C,F
....................       len = 1; 
3B82:  MOVLB  4
3B84:  CLRF   x0F
3B86:  MOVLW  01
3B88:  MOVWF  x0E
....................    } 
3B8A:  BRA    3BDE
....................    else if(MyTCBStub.Flags.bTimerEnabled)  
3B8C:  MOVLB  1
3B8E:  BTFSS  xF0.4
3B90:  BRA    3BDC
....................    { 
....................       // If we have data to transmit, but the remote RX window is zero,  
....................       // so we aren't transmitting any right now then make sure to not  
....................       // extend the retry counter or timer.  This will stall our TX  
....................       // with a periodic ACK sent to the remote node. 
....................       if(!(vSendFlags & SENDTCP_RESET_TIMERS)) 
3B92:  MOVLB  3
3B94:  BTFSC  xE7.0
3B96:  BRA    3BAC
....................       { 
....................          // Roll back retry counters since we can't send anything,  
....................          // but only if we incremented it in the first place 
....................          if(MyTCB.retryCount) 
3B98:  MOVLB  1
3B9A:  MOVF   x9A,F
3B9C:  BZ    3BAA
....................          { 
....................             MyTCB.retryCount--; 
3B9E:  DECF   x9A,F
....................             MyTCB.retryInterval >>= 1; 
3BA0:  BCF    FD8.0
3BA2:  RRCF   x78,F
3BA4:  RRCF   x77,F
3BA6:  RRCF   x76,F
3BA8:  RRCF   x75,F
3BAA:  MOVLB  3
....................          } 
....................       } 
....................     
....................       MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval; 
3BAC:  MOVLB  0
3BAE:  CALL   2692
3BB2:  MOVLB  1
3BB4:  MOVF   x75,W
3BB6:  MOVLB  4
3BB8:  ADDWF  00,W
3BBA:  MOVLB  1
3BBC:  MOVWF  xE7
3BBE:  MOVF   x76,W
3BC0:  MOVLB  4
3BC2:  ADDWFC 01,W
3BC4:  MOVLB  1
3BC6:  MOVWF  xE8
3BC8:  MOVF   x77,W
3BCA:  MOVLB  4
3BCC:  ADDWFC 02,W
3BCE:  MOVLB  1
3BD0:  MOVWF  xE9
3BD2:  MOVF   x78,W
3BD4:  MOVLB  4
3BD6:  ADDWFC 03,W
3BD8:  MOVLB  1
3BDA:  MOVWF  xEA
3BDC:  MOVLB  4
....................    } 
....................     
....................  
....................    header.SourcePort         = MyTCB.localPort.Val; 
3BDE:  MOVFF  186,3EB
3BE2:  MOVFF  185,3EA
....................    header.DestPort            = MyTCB.remotePort.Val; 
3BE6:  MOVFF  184,3ED
3BEA:  MOVFF  183,3EC
....................    header.SeqNumber         = MyTCB.MySEQ; 
3BEE:  MOVFF  17C,3F1
3BF2:  MOVFF  17B,3F0
3BF6:  MOVFF  17A,3EF
3BFA:  MOVFF  179,3EE
....................    header.AckNumber         = MyTCB.RemoteSEQ; 
3BFE:  MOVFF  180,3F5
3C02:  MOVFF  17F,3F4
3C06:  MOVFF  17E,3F3
3C0A:  MOVFF  17D,3F2
....................    header.Flags.bits.Reserved2   = 0; 
3C0E:  MOVLW  3F
3C10:  MOVLB  3
3C12:  ANDWF  xF7,W
3C14:  MOVWF  xF7
....................    header.DataOffset.Reserved3   = 0; 
3C16:  MOVLW  F0
3C18:  ANDWF  xF6,W
3C1A:  MOVWF  xF6
....................    header.Flags.byte         = vTCPFlags; 
3C1C:  MOVFF  3E6,3F7
....................    header.UrgentPointer        = 0; 
3C20:  CLRF   xFD
3C22:  CLRF   xFC
....................  
....................    // Update our send sequence number and ensure retransmissions  
....................    // of SYNs and FINs use the right sequence number 
....................    MyTCB.MySEQ += (DWORD)len; 
3C24:  MOVFF  40E,00
3C28:  MOVFF  40F,01
3C2C:  CLRF   02
3C2E:  CLRF   03
3C30:  MOVF   00,W
3C32:  MOVLB  1
3C34:  ADDWF  x79,F
3C36:  MOVF   01,W
3C38:  ADDWFC x7A,F
3C3A:  MOVF   02,W
3C3C:  ADDWFC x7B,F
3C3E:  MOVF   03,W
3C40:  ADDWFC x7C,F
....................    if(vTCPFlags & SYN) 
3C42:  MOVLB  3
3C44:  BTFSS  xE6.1
3C46:  BRA    3C84
....................    { 
....................       // SEG.ACK needs to be zero for the first SYN packet for compatibility  
....................       // with certain paranoid TCP/IP stacks, even though the ACK flag isn't  
....................       // set (indicating that the AckNumber field is unused). 
....................       if(!(vTCPFlags & ACK)) 
3C48:  BTFSC  xE6.4
3C4A:  BRA    3C54
....................          header.AckNumber = 0x00000000; 
3C4C:  CLRF   xF5
3C4E:  CLRF   xF4
3C50:  CLRF   xF3
3C52:  CLRF   xF2
....................  
....................       if(MyTCB.flags.bSYNSent) 
3C54:  MOVLB  1
3C56:  BTFSS  x97.1
3C58:  BRA    3C70
....................          header.SeqNumber--; 
3C5A:  MOVLW  FF
3C5C:  MOVLB  3
3C5E:  ADDWF  xEE,F
3C60:  BTFSS  FD8.0
3C62:  ADDWF  xEF,F
3C64:  BTFSS  FD8.0
3C66:  ADDWF  xF0,F
3C68:  BTFSS  FD8.0
3C6A:  ADDWF  xF1,F
3C6C:  BRA    3C84
3C6E:  MOVLB  1
....................       else 
....................       { 
....................          MyTCB.MySEQ++; 
3C70:  MOVLW  01
3C72:  ADDWF  x79,F
3C74:  BTFSC  FD8.0
3C76:  INCF   x7A,F
3C78:  BTFSC  FD8.2
3C7A:  INCF   x7B,F
3C7C:  BTFSC  FD8.2
3C7E:  INCF   x7C,F
....................          MyTCB.flags.bSYNSent = 1; 
3C80:  BSF    x97.1
3C82:  MOVLB  3
....................       } 
....................    } 
....................    if(vTCPFlags & FIN) 
3C84:  BTFSS  xE6.0
3C86:  BRA    3C8E
....................    { 
....................         MyTCB.flags.bFINSent = 1;   // do not advance the seq no for FIN! 
3C88:  MOVLB  1
3C8A:  BSF    x97.0
3C8C:  MOVLB  3
....................    } 
....................  
....................    // Calculate the amount of free space in the RX buffer area of this socket 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
3C8E:  MOVLB  1
3C90:  MOVF   xE6,W
3C92:  SUBWF  xE4,W
3C94:  BNC   3CD6
3C96:  BNZ   3C9E
3C98:  MOVF   xE5,W
3C9A:  SUBWF  xE3,W
3C9C:  BNC   3CD6
....................       header.Window = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
3C9E:  MOVF   xDB,W
3CA0:  SUBWF  xDD,W
3CA2:  MOVLB  4
3CA4:  MOVWF  x10
3CA6:  MOVLB  1
3CA8:  MOVF   xDC,W
3CAA:  SUBWFB xDE,W
3CAC:  MOVLB  4
3CAE:  MOVWF  x11
3CB0:  MOVLB  1
3CB2:  MOVF   xE5,W
3CB4:  SUBWF  xE3,W
3CB6:  MOVWF  00
3CB8:  MOVF   xE6,W
3CBA:  SUBWFB xE4,W
3CBC:  MOVWF  03
3CBE:  MOVF   00,W
3CC0:  MOVLB  4
3CC2:  SUBWF  x10,W
3CC4:  MOVLB  3
3CC6:  MOVWF  xF8
3CC8:  MOVF   03,W
3CCA:  MOVLB  4
3CCC:  SUBWFB x11,W
3CCE:  MOVLB  3
3CD0:  MOVWF  xF9
3CD2:  BRA    3CFA
3CD4:  MOVLB  1
....................    else 
....................       header.Window = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
3CD6:  MOVF   xE3,W
3CD8:  SUBWF  xE5,W
3CDA:  MOVLB  4
3CDC:  MOVWF  x10
3CDE:  MOVLB  1
3CE0:  MOVF   xE4,W
3CE2:  SUBWFB xE6,W
3CE4:  MOVLB  4
3CE6:  MOVWF  x11
3CE8:  MOVLW  01
3CEA:  SUBWF  x10,W
3CEC:  MOVLB  3
3CEE:  MOVWF  xF8
3CF0:  MOVLW  00
3CF2:  MOVLB  4
3CF4:  SUBWFB x11,W
3CF6:  MOVLB  3
3CF8:  MOVWF  xF9
....................  
....................    // Calculate the amount of free space in the MAC RX buffer area and adjust window if needed 
....................    wVal.Val = MACGetFreeRxSize(); 
3CFA:  MOVLB  0
3CFC:  GOTO   3274
3D00:  MOVFF  02,3E9
3D04:  MOVFF  01,3E8
....................    if(wVal.Val < 64) 
3D08:  MOVLB  3
3D0A:  MOVF   xE9,F
3D0C:  BNZ   3D1A
3D0E:  MOVF   xE8,W
3D10:  SUBLW  3F
3D12:  BNC   3D1A
....................     { 
....................       wVal.Val = 0; 
3D14:  CLRF   xE9
3D16:  CLRF   xE8
....................     } 
3D18:  BRA    3D22
....................     else 
....................     { 
....................       wVal.Val -= 64; 
3D1A:  MOVLW  40
3D1C:  SUBWF  xE8,F
3D1E:  MOVLW  00
3D20:  SUBWFB xE9,F
....................     } 
....................    // Force the remote node to throttle back if we are running low on general RX buffer space 
....................    if(header.Window > wVal.Val) 
3D22:  MOVF   xE9,W
3D24:  SUBWF  xF9,W
3D26:  BNC   3D38
3D28:  BNZ   3D30
3D2A:  MOVF   xF8,W
3D2C:  SUBWF  xE8,W
3D2E:  BC    3D38
....................       header.Window = wVal.Val; 
3D30:  MOVFF  3E9,3F9
3D34:  MOVFF  3E8,3F8
....................  
....................    SwapTCPHeader(&header); 
3D38:  MOVLW  03
3D3A:  MOVLB  4
3D3C:  MOVWF  x11
3D3E:  MOVLW  EA
3D40:  MOVWF  x10
3D42:  MOVLB  0
3D44:  CALL   3502
....................  
....................  
....................    len += sizeof(header); 
3D48:  MOVLW  14
3D4A:  MOVLB  4
3D4C:  ADDWF  x0E,F
3D4E:  MOVLW  00
3D50:  ADDWFC x0F,F
....................    header.DataOffset.Val   = sizeof(header) >> 2; 
3D52:  MOVLW  0F
3D54:  MOVLB  3
3D56:  ANDWF  xF6,W
3D58:  IORLW  50
3D5A:  MOVWF  xF6
....................  
....................    // Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet 
....................    if(vTCPFlags & SYN) 
3D5C:  BTFSS  xE6.1
3D5E:  BRA    3D96
....................    { 
....................       len += sizeof(options); 
3D60:  MOVLW  04
3D62:  MOVLB  4
3D64:  ADDWF  x0E,F
3D66:  MOVLW  00
3D68:  ADDWFC x0F,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
3D6A:  MOVLW  02
3D6C:  MOVLB  3
3D6E:  MOVWF  xFE
....................       options.Length = 0x04; 
3D70:  MOVLW  04
3D72:  MOVWF  xFF
....................  
....................       // Load MSS and swap to big endian 
....................       options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8); 
3D74:  MOVLW  18
3D76:  MOVLB  4
3D78:  MOVWF  x01
3D7A:  MOVLW  02
3D7C:  MOVWF  x00
....................  
....................      #if defined(__PCD__)  //__PCD__ __PCH__ __CCS__ bug 
....................       unsigned int8 scr8; 
....................       scr8 = header.DataOffset.Val; 
....................       scr8 += sizeof(options) >> 2; 
....................       header.DataOffset.Val = scr8; 
....................      #else  //standard code 
....................       header.DataOffset.Val   += sizeof(options) >> 2; 
3D7E:  MOVLB  3
3D80:  SWAPF  xF6,W
3D82:  ANDLW  0F
3D84:  ADDLW  01
3D86:  MOVWF  00
3D88:  SWAPF  00,W
3D8A:  ANDLW  F0
3D8C:  MOVWF  00
3D8E:  MOVLW  0F
3D90:  ANDWF  xF6,W
3D92:  IORWF  00,W
3D94:  MOVWF  xF6
....................      #endif 
....................    } 
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
3D96:  MOVFF  25,405
3D9A:  MOVFF  24,404
3D9E:  MOVFF  23,403
3DA2:  MOVFF  22,402
....................    pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr; 
3DA6:  MOVFF  18E,409
3DAA:  MOVFF  18D,408
3DAE:  MOVFF  18C,407
3DB2:  MOVFF  18B,406
....................    pseudoHeader.Zero           = 0x0; 
3DB6:  MOVLB  4
3DB8:  CLRF   x0A
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
3DBA:  MOVLW  06
3DBC:  MOVWF  x0B
....................    pseudoHeader.Length         = len; 
3DBE:  MOVFF  40F,40D
3DC2:  MOVFF  40E,40C
....................    SwapPseudoHeader(pseudoHeader); 
3DC6:  MOVFF  40D,430
3DCA:  MOVFF  40C,42F
3DCE:  MOVLB  0
3DD0:  CALL   1C92
3DD4:  MOVFF  02,40D
3DD8:  MOVFF  01,40C
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, sizeof(pseudoHeader)); 
3DDC:  MOVLW  04
3DDE:  MOVLB  4
3DE0:  MOVWF  x11
3DE2:  MOVLW  02
3DE4:  MOVWF  x10
3DE6:  MOVFF  411,42C
3DEA:  MOVWF  x2B
3DEC:  CLRF   x2E
3DEE:  MOVLW  0C
3DF0:  MOVWF  x2D
3DF2:  MOVLB  0
3DF4:  CALL   1D8E
3DF8:  MOVFF  01,3FA
3DFC:  MOVLB  3
3DFE:  COMF   xFA,F
3E00:  MOVFF  02,3FB
3E04:  COMF   xFB,F
....................  
....................    // Write IP header 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER)); 
3E06:  MOVLW  11
3E08:  MOVLB  4
3E0A:  MOVWF  x20
3E0C:  MOVLW  E5
3E0E:  MOVWF  x1F
3E10:  MOVLB  0
3E12:  CALL   0AAE
....................    IPPutHeader(&MyTCB.remote.niRemoteMACIP, IP_PROT_TCP, len); 
3E16:  MOVLW  01
3E18:  MOVLB  4
3E1A:  MOVWF  x11
3E1C:  MOVLW  8B
3E1E:  MOVWF  x10
3E20:  MOVLW  06
3E22:  MOVWF  x12
3E24:  MOVFF  40F,414
3E28:  MOVFF  40E,413
3E2C:  MOVLB  0
3E2E:  CALL   1F3C
....................    MACPutArray((BYTE*)&header, sizeof(header)); 
3E32:  MOVLW  03
3E34:  MOVLB  4
3E36:  MOVWF  x11
3E38:  MOVLW  EA
3E3A:  MOVWF  x10
3E3C:  MOVFF  411,435
3E40:  MOVWF  x34
3E42:  CLRF   x37
3E44:  MOVLW  14
3E46:  MOVWF  x36
3E48:  MOVLB  0
3E4A:  CALL   0B1E
....................    if(vTCPFlags & SYN) 
3E4E:  MOVLB  3
3E50:  BTFSS  xE6.1
3E52:  BRA    3E72
....................       MACPutArray((BYTE*)&options, sizeof(options)); 
3E54:  MOVLW  03
3E56:  MOVLB  4
3E58:  MOVWF  x11
3E5A:  MOVLW  FE
3E5C:  MOVWF  x10
3E5E:  MOVFF  411,435
3E62:  MOVWF  x34
3E64:  CLRF   x37
3E66:  MOVLW  04
3E68:  MOVWF  x36
3E6A:  MOVLB  0
3E6C:  CALL   0B1E
3E70:  MOVLB  3
....................  
....................    // Update the TCP checksum 
....................    MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER)); 
3E72:  MOVLW  11
3E74:  MOVLB  4
3E76:  MOVWF  x20
3E78:  MOVLW  F9
3E7A:  MOVWF  x1F
3E7C:  MOVLB  0
3E7E:  CALL   0B64
....................    wVal.Val = CalcIPBufferChecksum(len); 
3E82:  MOVFF  40F,411
3E86:  MOVFF  40E,410
3E8A:  RCALL  3728
3E8C:  MOVFF  02,3E9
3E90:  MOVFF  01,3E8
.................... #if defined(DEBUG_GENERATE_TX_LOSS) 
....................    // Damage TCP checksums on TX packets randomly 
....................    if(LFSRRand() > DEBUG_GENERATE_TX_LOSS) 
....................    { 
....................       wVal.Val++; 
....................    } 
.................... #endif 
....................    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 16); 
3E94:  MOVLW  12
3E96:  MOVLB  4
3E98:  MOVWF  x20
3E9A:  MOVLW  09
3E9C:  MOVWF  x1F
3E9E:  MOVLB  0
3EA0:  CALL   0AAE
....................    MACPutArray((BYTE*)&wVal, sizeof(WORD)); 
3EA4:  MOVLW  03
3EA6:  MOVLB  4
3EA8:  MOVWF  x11
3EAA:  MOVLW  E8
3EAC:  MOVWF  x10
3EAE:  MOVFF  411,435
3EB2:  MOVWF  x34
3EB4:  CLRF   x37
3EB6:  MOVLW  02
3EB8:  MOVWF  x36
3EBA:  MOVLB  0
3EBC:  CALL   0B1E
....................  
....................    // Physically start the packet transmission over the network 
....................    MACFlush(); 
3EC0:  CALL   2026
3EC4:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
....................  
....................   Summary: 
....................    Finds a suitable socket for a TCP segment. 
....................  
....................   Description: 
....................    This function searches through the sockets and attempts to match one with 
....................    a given TCP header and NODE_INFO structure.  If a socket is found, its  
....................    index is saved in hCurrentTCP and the associated MyTCBStub and MyTCB are 
....................    loaded. Otherwise, INVALID_SOCKET is placed in hCurrentTCP. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    h - TCP header to be matched against 
....................    remote - The remote node who sent this header 
....................  
....................   Return Values: 
....................    TRUE - A match was found and is loaded in hCurrentTCP 
....................    FALSE - No suitable socket was found and hCurrentTCP is INVALID_SOCKET 
....................   ***************************************************************************/ 
.................... static BOOL FindMatchingTCPSocket(TCP_HEADER* h, NODE_INFO* remote) 
.................... { 
....................    TCP_SOCKET hTCP; 
....................    TCP_SOCKET partialMatch; 
....................    WORD hash; 
....................  
....................    // Prevent connections on invalid port 0 
....................    if(h->DestPort == 0u) 
*
4F70:  MOVLW  02
4F72:  MOVLB  3
4F74:  ADDWF  xC6,W
4F76:  MOVWF  FE9
4F78:  MOVLW  00
4F7A:  ADDWFC xC7,W
4F7C:  MOVWF  FEA
4F7E:  MOVFF  FEC,3D1
4F82:  MOVF   FED,F
4F84:  MOVFF  FEF,3D0
4F88:  MOVF   xD0,F
4F8A:  BNZ   4F96
4F8C:  MOVF   xD1,F
4F8E:  BNZ   4F96
....................       return FALSE; 
4F90:  MOVLW  00
4F92:  MOVWF  01
4F94:  BRA    5590
....................  
....................    partialMatch = INVALID_SOCKET; 
4F96:  MOVLW  FE
4F98:  MOVWF  xCB
....................    hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort; 
4F9A:  MOVLW  02
4F9C:  ADDWF  xC8,W
4F9E:  MOVWF  FE9
4FA0:  MOVLW  00
4FA2:  ADDWFC xC9,W
4FA4:  MOVWF  FEA
4FA6:  MOVFF  FEC,3D1
4FAA:  MOVF   FED,F
4FAC:  MOVFF  FEF,3D0
4FB0:  MOVFF  3C8,FE9
4FB4:  MOVFF  3C9,FEA
4FB8:  MOVFF  FEC,03
4FBC:  MOVF   FED,F
4FBE:  MOVF   FEF,W
4FC0:  ADDWF  xD0,F
4FC2:  MOVF   03,W
4FC4:  ADDWFC xD1,F
4FC6:  MOVFF  3C6,FE9
4FCA:  MOVFF  3C7,FEA
4FCE:  MOVFF  FEC,03
4FD2:  MOVF   FED,F
4FD4:  MOVF   FEF,W
4FD6:  ADDWF  xD0,F
4FD8:  MOVF   03,W
4FDA:  ADDWFC xD1,F
4FDC:  MOVLW  02
4FDE:  ADDWF  xC6,W
4FE0:  MOVWF  FE9
4FE2:  MOVLW  00
4FE4:  ADDWFC xC7,W
4FE6:  MOVWF  FEA
4FE8:  MOVFF  FEC,03
4FEC:  MOVF   FED,F
4FEE:  MOVF   FEF,W
4FF0:  XORWF  xD0,W
4FF2:  MOVWF  xCC
4FF4:  MOVF   03,W
4FF6:  XORWF  xD1,W
4FF8:  MOVWF  xCD
....................  
....................    // Loop through all sockets looking for a socket that is expecting this  
....................    // packet or can handle it. 
....................    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ ) 
4FFA:  CLRF   xCA
4FFC:  MOVF   xCA,F
4FFE:  BTFSS  FD8.2
5000:  BRA    5104
....................    { 
....................       SyncTCBStub(hTCP); 
5002:  MOVFF  3CA,3D0
5006:  MOVLB  0
5008:  CALL   0A0C
....................  
....................       if(MyTCBStub.smState == TCP_CLOSED) 
500C:  MOVLB  1
500E:  MOVF   xEF,W
5010:  SUBLW  0D
5012:  BNZ   5018
....................       { 
....................          continue; 
5014:  BRA    50FE
....................       } 
5016:  BRA    505E
....................       else if(MyTCBStub.smState == TCP_LISTEN) 
5018:  MOVF   xEF,W
501A:  SUBLW  04
501C:  BNZ   5048
....................       {// For listening ports, check if this is the correct port 
....................          if(MyTCBStub.remoteHash.Val == h->DestPort) 
501E:  MOVLW  02
5020:  MOVLB  3
5022:  ADDWF  xC6,W
5024:  MOVWF  FE9
5026:  MOVLW  00
5028:  ADDWFC xC7,W
502A:  MOVWF  FEA
502C:  MOVFF  FEC,03
5030:  MOVF   FED,F
5032:  MOVF   FEF,W
5034:  MOVLB  1
5036:  SUBWF  xF2,W
5038:  BNZ   5044
503A:  MOVF   03,W
503C:  SUBWF  xF3,W
503E:  BNZ   5044
....................             partialMatch = hTCP; 
5040:  MOVFF  3CA,3CB
....................           
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          // Check the SSL port as well for SSL Servers 
....................          // 0 is defined as an invalid port number 
....................          if(MyTCBStub.sslTxHead == h->DestPort) 
....................             partialMatch = hTCP; 
....................          #endif 
....................           
....................          continue; 
5044:  BRA    50FE
....................       } 
5046:  BRA    505E
....................       else if(MyTCBStub.remoteHash.Val != hash) 
5048:  MOVLB  3
504A:  MOVF   xCC,W
504C:  MOVLB  1
504E:  SUBWF  xF2,W
5050:  BNZ   505C
5052:  MOVLB  3
5054:  MOVF   xCD,W
5056:  MOVLB  1
5058:  SUBWF  xF3,W
505A:  BZ    505E
....................       {// Ignore if the hash doesn't match 
....................          continue; 
505C:  BRA    50FE
....................       } 
....................  
....................       SyncTCB(); 
505E:  MOVLB  0
5060:  CALL   100C
....................       if(   h->DestPort == MyTCB.localPort.Val && 
....................          h->SourcePort == MyTCB.remotePort.Val && 
....................          remote->IPAddr.Val == MyTCB.remote.niRemoteMACIP.IPAddr.Val) 
5064:  MOVLW  02
5066:  MOVLB  3
5068:  ADDWF  xC6,W
506A:  MOVWF  FE9
506C:  MOVLW  00
506E:  ADDWFC xC7,W
5070:  MOVWF  FEA
5072:  MOVFF  FEC,3D1
5076:  MOVF   FED,F
5078:  MOVFF  FEF,3D0
507C:  MOVLB  1
507E:  MOVF   x85,W
5080:  MOVLB  3
5082:  SUBWF  xD0,W
5084:  BNZ   50FC
5086:  MOVLB  1
5088:  MOVF   x86,W
508A:  MOVLB  3
508C:  SUBWF  xD1,W
508E:  BNZ   50FC
5090:  MOVFF  3C6,FE9
5094:  MOVFF  3C7,FEA
5098:  MOVFF  FEC,3D1
509C:  MOVF   FED,F
509E:  MOVFF  FEF,3D0
50A2:  MOVLB  1
50A4:  MOVF   x83,W
50A6:  MOVLB  3
50A8:  SUBWF  xD0,W
50AA:  BNZ   50FC
50AC:  MOVLB  1
50AE:  MOVF   x84,W
50B0:  MOVLB  3
50B2:  SUBWF  xD1,W
50B4:  BNZ   50FC
50B6:  MOVFF  3C8,FE9
50BA:  MOVFF  3C9,FEA
50BE:  MOVFF  FEF,3D0
50C2:  MOVFF  FEC,3D1
50C6:  MOVFF  FEC,3D2
50CA:  MOVFF  FEC,3D3
50CE:  MOVLB  1
50D0:  MOVF   x8B,W
50D2:  MOVLB  3
50D4:  SUBWF  xD0,W
50D6:  BNZ   50FC
50D8:  MOVLB  1
50DA:  MOVF   x8C,W
50DC:  MOVLB  3
50DE:  SUBWF  xD1,W
50E0:  BNZ   50FC
50E2:  MOVLB  1
50E4:  MOVF   x8D,W
50E6:  MOVLB  3
50E8:  SUBWF  xD2,W
50EA:  BNZ   50FC
50EC:  MOVLB  1
50EE:  MOVF   x8E,W
50F0:  MOVLB  3
50F2:  SUBWF  xD3,W
50F4:  BNZ   50FC
....................       { 
....................          return TRUE; 
50F6:  MOVLW  01
50F8:  MOVWF  01
50FA:  BRA    5590
50FC:  MOVLB  1
....................       } 
50FE:  MOVLB  3
5100:  INCF   xCA,F
5102:  BRA    4FFC
....................    } 
....................  
....................  
....................    // If there is a partial match, then a listening socket is currently  
....................    // available.  Set up the extended TCB with the info needed  
....................    // to establish a connection and return this socket to the  
....................    // caller. 
....................    if(partialMatch != INVALID_SOCKET) 
5104:  MOVF   xCB,W
5106:  SUBLW  FE
5108:  BZ    517E
....................    { 
....................       SyncTCBStub(partialMatch); 
510A:  MOVFF  3CB,3D0
510E:  MOVLB  0
5110:  CALL   0A0C
....................       SyncTCB(); 
5114:  CALL   100C
....................     
....................       // For SSL ports, begin the SSL Handshake 
....................       #if defined(STACK_USE_SSL_SERVER) 
....................       if(MyTCBStub.sslTxHead == h->DestPort) 
....................       { 
....................          // Try to start an SSL session.  If no stubs are available, 
....................          // we can't service this request right now, so ignore it. 
....................          if(!TCPStartSSLServer(partialMatch)) 
....................             partialMatch = INVALID_SOCKET; 
....................       } 
....................       #endif 
....................     
....................       // Make sure the above check didn't fail (this is unfortunately  
....................       // redundant for non-SSL sockets).  Otherwise, fall out to below 
....................       // and add to the SYN queue. 
....................       if(partialMatch != INVALID_SOCKET) 
5118:  MOVLB  3
511A:  MOVF   xCB,W
511C:  SUBLW  FE
511E:  BZ    517E
....................       { 
....................          MyTCBStub.remoteHash.Val = hash; 
5120:  MOVFF  3CD,1F3
5124:  MOVFF  3CC,1F2
....................        
....................          memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO)); 
5128:  MOVLW  01
512A:  MOVWF  xD1
512C:  MOVLW  8B
512E:  MOVFF  3D1,FEA
5132:  MOVWF  FE9
5134:  MOVFF  3C9,FE2
5138:  MOVFF  3C8,FE1
513C:  MOVLW  0A
513E:  MOVWF  01
5140:  MOVFF  FE6,FEE
5144:  DECFSZ 01,F
5146:  BRA    5140
....................          MyTCB.remotePort.Val = h->SourcePort; 
5148:  MOVFF  3C6,FE9
514C:  MOVFF  3C7,FEA
5150:  MOVFF  FEC,184
5154:  MOVF   FED,F
5156:  MOVFF  FEF,183
....................          MyTCB.localPort.Val = h->DestPort; 
515A:  MOVLW  02
515C:  ADDWF  xC6,W
515E:  MOVWF  FE9
5160:  MOVLW  00
5162:  ADDWFC xC7,W
5164:  MOVWF  FEA
5166:  MOVFF  FEC,186
516A:  MOVF   FED,F
516C:  MOVFF  FEF,185
....................          MyTCB.txUnackedTail   = MyTCBStub.bufferTxStart; 
5170:  MOVFF  1DA,182
5174:  MOVFF  1D9,181
....................        
....................          // All done, and we have a match 
....................          return TRUE; 
5178:  MOVLW  01
517A:  MOVWF  01
517C:  BRA    5590
....................       } 
....................    } 
....................  
....................    // No available sockets are listening on this port.  (Or, for 
....................    // SSL requests, perhaps no SSL sessions were available.  However, 
....................    // there may be a server socket which is currently busy but  
....................    // could handle this packet, so we should check. 
....................    #if TCP_SYN_QUEUE_MAX_ENTRIES 
....................    { 
....................       WORD wQueueInsertPos; 
....................        
....................       // See if this is a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
517E:  MOVLW  0D
5180:  ADDWF  xC6,W
5182:  MOVWF  FE9
5184:  MOVLW  00
5186:  ADDWFC xC7,W
5188:  MOVWF  FEA
518A:  BTFSC  FEF.1
518C:  BRA    5194
....................          return FALSE; 
518E:  MOVLW  00
5190:  MOVWF  01
5192:  BRA    5590
....................  
....................       // See if there is space in our SYN queue 
....................       if(SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort) 
5194:  MOVLB  1
5196:  MOVF   xD5,W
5198:  IORWF  xD6,W
519A:  BZ    51A6
....................          return FALSE; 
519C:  MOVLW  00
519E:  MOVWF  01
51A0:  MOVLB  3
51A2:  BRA    5590
51A4:  MOVLB  1
....................        
....................       // See if we have this SYN already in our SYN queue. 
....................       // If not already in the queue, find out where we  
....................       // should insert this SYN to the queue 
....................       for(wQueueInsertPos = 0; wQueueInsertPos < TCP_SYN_QUEUE_MAX_ENTRIES; wQueueInsertPos++) 
51A6:  MOVLB  3
51A8:  CLRF   xCF
51AA:  CLRF   xCE
51AC:  MOVF   xCF,F
51AE:  BTFSS  FD8.2
51B0:  BRA    537E
51B2:  MOVF   xCE,W
51B4:  SUBLW  02
51B6:  BTFSS  FD8.0
51B8:  BRA    537E
....................       { 
....................          // Exit loop if we found a free record 
....................          if(SYNQueue[wQueueInsertPos].wDestPort == 0u) 
51BA:  MOVFF  3CF,3D1
51BE:  MOVFF  3CE,3D0
51C2:  CLRF   xD3
51C4:  MOVLW  14
51C6:  MOVWF  xD2
51C8:  MOVLB  0
51CA:  CALL   3252
51CE:  MOVFF  01,3D0
51D2:  MOVLW  10
51D4:  MOVLB  3
51D6:  ADDWF  01,W
51D8:  MOVWF  01
51DA:  MOVLW  00
51DC:  ADDWFC 02,W
51DE:  MOVWF  03
51E0:  MOVF   01,W
51E2:  ADDLW  9D
51E4:  MOVWF  FE9
51E6:  MOVLW  01
51E8:  ADDWFC 03,W
51EA:  MOVWF  FEA
51EC:  MOVFF  FEC,3D1
51F0:  MOVF   FED,F
51F2:  MOVFF  FEF,3D0
51F6:  MOVF   xD0,F
51F8:  BNZ   5200
51FA:  MOVF   xD1,F
51FC:  BNZ   5200
....................             break; 
51FE:  BRA    537E
....................  
....................          // Check if this SYN packet is already in the SYN queue 
....................          if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort) 
5200:  MOVFF  3CF,3D1
5204:  MOVFF  3CE,3D0
5208:  CLRF   xD3
520A:  MOVLW  14
520C:  MOVWF  xD2
520E:  MOVLB  0
5210:  CALL   3252
5214:  MOVFF  01,3D0
5218:  MOVLW  10
521A:  MOVLB  3
521C:  ADDWF  01,W
521E:  MOVWF  01
5220:  MOVLW  00
5222:  ADDWFC 02,W
5224:  MOVWF  03
5226:  MOVF   01,W
5228:  ADDLW  9D
522A:  MOVWF  FE9
522C:  MOVLW  01
522E:  ADDWFC 03,W
5230:  MOVWF  FEA
5232:  MOVFF  FEC,3D1
5236:  MOVF   FED,F
5238:  MOVFF  FEF,3D0
523C:  MOVLW  02
523E:  ADDWF  xC6,W
5240:  MOVWF  FE9
5242:  MOVLW  00
5244:  ADDWFC xC7,W
5246:  MOVWF  FEA
5248:  MOVFF  FEC,03
524C:  MOVF   FED,F
524E:  MOVF   FEF,W
5250:  SUBWF  xD0,W
5252:  BNZ   525A
5254:  MOVF   03,W
5256:  SUBWF  xD1,W
5258:  BZ    525C
....................             continue; 
525A:  BRA    5376
....................          if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort) 
525C:  MOVFF  3CF,3D1
5260:  MOVFF  3CE,3D0
5264:  CLRF   xD3
5266:  MOVLW  14
5268:  MOVWF  xD2
526A:  MOVLB  0
526C:  CALL   3252
5270:  MOVFF  01,3D0
5274:  MOVLW  0A
5276:  MOVLB  3
5278:  ADDWF  01,W
527A:  MOVWF  01
527C:  MOVLW  00
527E:  ADDWFC 02,W
5280:  MOVWF  03
5282:  MOVF   01,W
5284:  ADDLW  9D
5286:  MOVWF  FE9
5288:  MOVLW  01
528A:  ADDWFC 03,W
528C:  MOVWF  FEA
528E:  MOVFF  FEC,3D1
5292:  MOVF   FED,F
5294:  MOVFF  FEF,3D0
5298:  MOVFF  3C6,FE9
529C:  MOVFF  3C7,FEA
52A0:  MOVFF  FEC,03
52A4:  MOVF   FED,F
52A6:  MOVF   FEF,W
52A8:  SUBWF  xD0,W
52AA:  BNZ   52B2
52AC:  MOVF   03,W
52AE:  SUBWF  xD1,W
52B0:  BZ    52B4
....................             continue; 
52B2:  BRA    5376
....................          if(SYNQueue[wQueueInsertPos].niSourceAddress.IPAddr.Val != remote->IPAddr.Val) 
52B4:  MOVFF  3CF,3D1
52B8:  MOVFF  3CE,3D0
52BC:  CLRF   xD3
52BE:  MOVLW  14
52C0:  MOVWF  xD2
52C2:  MOVLB  0
52C4:  CALL   3252
52C8:  MOVFF  02,3D1
52CC:  MOVFF  01,3D0
52D0:  MOVLW  9D
52D2:  MOVLB  3
52D4:  ADDWF  01,W
52D6:  MOVWF  FE9
52D8:  MOVLW  01
52DA:  ADDWFC 02,W
52DC:  MOVWF  FEA
52DE:  MOVFF  FEF,3D2
52E2:  MOVFF  FEC,3D3
52E6:  MOVFF  FEC,3D4
52EA:  MOVFF  FEC,3D5
52EE:  MOVFF  3C8,FE9
52F2:  MOVFF  3C9,FEA
52F6:  MOVFF  FEF,00
52FA:  MOVFF  FEC,01
52FE:  MOVFF  FEC,02
5302:  MOVFF  FEC,03
5306:  MOVF   00,W
5308:  SUBWF  xD2,W
530A:  BNZ   531E
530C:  MOVF   01,W
530E:  SUBWF  xD3,W
5310:  BNZ   531E
5312:  MOVF   02,W
5314:  SUBWF  xD4,W
5316:  BNZ   531E
5318:  MOVF   03,W
531A:  SUBWF  xD5,W
531C:  BZ    5320
....................             continue; 
531E:  BRA    5376
....................  
....................          // SYN matches SYN queue entry.  Update timestamp and do nothing. 
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
5320:  MOVFF  3CF,3D1
5324:  MOVFF  3CE,3D0
5328:  CLRF   xD3
532A:  MOVLW  14
532C:  MOVWF  xD2
532E:  MOVLB  0
5330:  CALL   3252
5334:  MOVFF  01,3D0
5338:  MOVLW  12
533A:  MOVLB  3
533C:  ADDWF  01,W
533E:  MOVWF  01
5340:  MOVLW  00
5342:  ADDWFC 02,W
5344:  MOVWF  03
5346:  MOVF   01,W
5348:  ADDLW  9D
534A:  MOVWF  01
534C:  MOVLW  01
534E:  ADDWFC 03,F
5350:  MOVFF  01,3D0
5354:  MOVFF  03,3D1
5358:  MOVLB  0
535A:  CALL   322C
535E:  MOVFF  3D1,FEA
5362:  MOVFF  3D0,FE9
5366:  MOVFF  00,FEF
536A:  MOVFF  01,FEC
....................          return FALSE; 
536E:  MOVLW  00
5370:  MOVWF  01
5372:  MOVLB  3
5374:  BRA    5590
5376:  INCF   xCE,F
5378:  BTFSC  FD8.2
537A:  INCF   xCF,F
537C:  BRA    51AC
....................       } 
....................        
....................       // Check to see if we have any server sockets which  
....................       // are currently connected, but could handle this SYN  
....................       // request at a later time if the client disconnects. 
....................       for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++) 
537E:  CLRF   xCA
5380:  MOVF   xCA,F
5382:  BTFSS  FD8.2
5384:  BRA    558C
....................       { 
....................          SyncTCBStub(hTCP); 
5386:  MOVFF  3CA,3D0
538A:  MOVLB  0
538C:  CALL   0A0C
....................          if(!MyTCBStub.Flags.bServer) 
5390:  MOVLB  1
5392:  BTFSC  xF0.3
5394:  BRA    5398
....................             continue; 
5396:  BRA    5586
....................  
....................          SyncTCB(); 
5398:  MOVLB  0
539A:  CALL   100C
....................          #if defined(STACK_USE_SSL_SERVER) 
....................          if((MyTCB.localPort.Val != h->DestPort) && (MyTCB.localSSLPort.Val != h->DestPort)) 
....................          #else 
....................          if(MyTCB.localPort.Val != h->DestPort) 
539E:  MOVLW  02
53A0:  MOVLB  3
53A2:  ADDWF  xC6,W
53A4:  MOVWF  FE9
53A6:  MOVLW  00
53A8:  ADDWFC xC7,W
53AA:  MOVWF  FEA
53AC:  MOVFF  FEC,03
53B0:  MOVF   FED,F
53B2:  MOVF   FEF,W
53B4:  MOVLB  1
53B6:  SUBWF  x85,W
53B8:  BNZ   53C0
53BA:  MOVF   03,W
53BC:  SUBWF  x86,W
53BE:  BZ    53C2
....................          #endif 
....................             continue; 
53C0:  BRA    5586
....................  
....................          // Generate the SYN queue entry 
....................          memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO)); 
53C2:  MOVFF  3CF,3D1
53C6:  MOVFF  3CE,3D0
53CA:  MOVLB  3
53CC:  CLRF   xD3
53CE:  MOVLW  14
53D0:  MOVWF  xD2
53D2:  MOVLB  0
53D4:  CALL   3252
53D8:  MOVFF  02,3D1
53DC:  MOVFF  01,3D0
53E0:  MOVLW  9D
53E2:  MOVLB  3
53E4:  ADDWF  01,W
53E6:  MOVWF  01
53E8:  MOVLW  01
53EA:  ADDWFC 02,W
53EC:  MOVWF  03
53EE:  MOVFF  01,3D2
53F2:  MOVWF  xD3
53F4:  MOVWF  FEA
53F6:  MOVFF  01,FE9
53FA:  MOVFF  3C9,FE2
53FE:  MOVFF  3C8,FE1
5402:  MOVLW  0A
5404:  MOVWF  01
5406:  MOVFF  FE6,FEE
540A:  DECFSZ 01,F
540C:  BRA    5406
....................          SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort; 
540E:  MOVFF  3CF,3D1
5412:  MOVFF  3CE,3D0
5416:  CLRF   xD3
5418:  MOVLW  14
541A:  MOVWF  xD2
541C:  MOVLB  0
541E:  CALL   3252
5422:  MOVFF  01,3D0
5426:  MOVLW  0A
5428:  MOVLB  3
542A:  ADDWF  01,W
542C:  MOVWF  01
542E:  MOVLW  00
5430:  ADDWFC 02,W
5432:  MOVWF  03
5434:  MOVF   01,W
5436:  ADDLW  9D
5438:  MOVWF  01
543A:  MOVLW  01
543C:  ADDWFC 03,F
543E:  MOVFF  03,3D1
5442:  MOVFF  3C6,FE9
5446:  MOVFF  3C7,FEA
544A:  MOVFF  FEC,03
544E:  MOVF   FED,F
5450:  MOVFF  FEF,3D2
5454:  MOVFF  3D1,FEA
5458:  MOVFF  01,FE9
545C:  MOVFF  03,FEC
5460:  MOVF   FED,F
5462:  MOVFF  3D2,FEF
....................          SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber; 
5466:  MOVFF  3CF,3D1
546A:  MOVFF  3CE,3D0
546E:  CLRF   xD3
5470:  MOVLW  14
5472:  MOVWF  xD2
5474:  MOVLB  0
5476:  CALL   3252
547A:  MOVFF  01,3D0
547E:  MOVLW  0C
5480:  MOVLB  3
5482:  ADDWF  01,W
5484:  MOVWF  01
5486:  MOVLW  00
5488:  ADDWFC 02,W
548A:  MOVWF  03
548C:  MOVF   01,W
548E:  ADDLW  9D
5490:  MOVWF  01
5492:  MOVLW  01
5494:  ADDWFC 03,F
5496:  MOVFF  01,3D0
549A:  MOVFF  03,3D1
549E:  MOVLW  04
54A0:  ADDWF  xC6,W
54A2:  MOVWF  FE9
54A4:  MOVLW  00
54A6:  ADDWFC xC7,W
54A8:  MOVWF  FEA
54AA:  MOVFF  FEF,00
54AE:  MOVFF  FEC,01
54B2:  MOVFF  FEC,02
54B6:  MOVFF  FEC,03
54BA:  MOVFF  3D1,FEA
54BE:  MOVFF  3D0,FE9
54C2:  MOVFF  00,FEF
54C6:  MOVFF  01,FEC
54CA:  MOVFF  02,FEC
54CE:  MOVFF  03,FEC
....................          SYNQueue[wQueueInsertPos].wDestPort = h->DestPort; 
54D2:  MOVFF  3CF,3D1
54D6:  MOVFF  3CE,3D0
54DA:  CLRF   xD3
54DC:  MOVLW  14
54DE:  MOVWF  xD2
54E0:  MOVLB  0
54E2:  CALL   3252
54E6:  MOVFF  01,3D0
54EA:  MOVLW  10
54EC:  MOVLB  3
54EE:  ADDWF  01,W
54F0:  MOVWF  01
54F2:  MOVLW  00
54F4:  ADDWFC 02,W
54F6:  MOVWF  03
54F8:  MOVF   01,W
54FA:  ADDLW  9D
54FC:  MOVWF  01
54FE:  MOVLW  01
5500:  ADDWFC 03,F
5502:  MOVFF  03,3D1
5506:  MOVLW  02
5508:  ADDWF  xC6,W
550A:  MOVWF  FE9
550C:  MOVLW  00
550E:  ADDWFC xC7,W
5510:  MOVWF  FEA
5512:  MOVFF  FEC,03
5516:  MOVF   FED,F
5518:  MOVFF  FEF,3D2
551C:  MOVFF  3D1,FEA
5520:  MOVFF  01,FE9
5524:  MOVFF  03,FEC
5528:  MOVF   FED,F
552A:  MOVFF  3D2,FEF
....................          SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256(); 
552E:  MOVFF  3CF,3D1
5532:  MOVFF  3CE,3D0
5536:  CLRF   xD3
5538:  MOVLW  14
553A:  MOVWF  xD2
553C:  MOVLB  0
553E:  CALL   3252
5542:  MOVFF  01,3D0
5546:  MOVLW  12
5548:  MOVLB  3
554A:  ADDWF  01,W
554C:  MOVWF  01
554E:  MOVLW  00
5550:  ADDWFC 02,W
5552:  MOVWF  03
5554:  MOVF   01,W
5556:  ADDLW  9D
5558:  MOVWF  01
555A:  MOVLW  01
555C:  ADDWFC 03,F
555E:  MOVFF  01,3D0
5562:  MOVFF  03,3D1
5566:  MOVLB  0
5568:  CALL   322C
556C:  MOVFF  3D1,FEA
5570:  MOVFF  3D0,FE9
5574:  MOVFF  00,FEF
5578:  MOVFF  01,FEC
....................  
....................          return FALSE; 
557C:  MOVLW  00
557E:  MOVWF  01
5580:  MOVLB  3
5582:  BRA    5590
5584:  MOVLB  1
5586:  MOVLB  3
5588:  INCF   xCA,F
558A:  BRA    5380
....................       } 
....................    } 
....................    #endif 
....................        
....................    return FALSE; 
558C:  MOVLW  00
558E:  MOVWF  01
5590:  MOVLB  0
5592:  GOTO   69E4 (RETURN)
....................  
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void SwapTCPHeader(TCP_HEADER* header) 
....................  
....................   Summary: 
....................    Swaps endian-ness of a TCP header. 
....................  
....................   Description: 
....................    This function swaps the endian-ness of a given TCP header for comparison. 
....................  
....................   Precondition: 
....................    None 
....................  
....................   Parameters: 
....................    header - The TCP header that is to be swapped 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................    header->SourcePort      = swaps(header->SourcePort); 
*
3502:  MOVLB  4
3504:  MOVFF  410,01
3508:  MOVFF  411,03
350C:  MOVFF  410,412
3510:  MOVFF  411,413
3514:  MOVFF  410,FE9
3518:  MOVFF  411,FEA
351C:  MOVFF  FEC,415
3520:  MOVF   FED,F
3522:  MOVFF  FEF,414
3526:  MOVFF  415,430
352A:  MOVFF  414,42F
352E:  MOVLB  0
3530:  CALL   1C92
3534:  MOVFF  413,FEA
3538:  MOVFF  412,FE9
353C:  MOVFF  02,FEC
3540:  MOVF   FED,F
3542:  MOVFF  01,FEF
....................    header->DestPort        = swaps(header->DestPort); 
3546:  MOVLW  02
3548:  MOVLB  4
354A:  ADDWF  x10,W
354C:  MOVWF  01
354E:  MOVLW  00
3550:  ADDWFC x11,W
3552:  MOVWF  03
3554:  MOVFF  01,412
3558:  MOVWF  x13
355A:  MOVLW  02
355C:  ADDWF  x10,W
355E:  MOVWF  FE9
3560:  MOVLW  00
3562:  ADDWFC x11,W
3564:  MOVWF  FEA
3566:  MOVFF  FEC,415
356A:  MOVF   FED,F
356C:  MOVFF  FEF,414
3570:  MOVFF  415,430
3574:  MOVFF  414,42F
3578:  MOVLB  0
357A:  CALL   1C92
357E:  MOVFF  413,FEA
3582:  MOVFF  412,FE9
3586:  MOVFF  02,FEC
358A:  MOVF   FED,F
358C:  MOVFF  01,FEF
....................    header->SeqNumber       = swapl(header->SeqNumber); 
3590:  MOVLW  04
3592:  MOVLB  4
3594:  ADDWF  x10,W
3596:  MOVWF  01
3598:  MOVLW  00
359A:  ADDWFC x11,W
359C:  MOVWF  03
359E:  MOVFF  01,412
35A2:  MOVWF  x13
35A4:  MOVLW  04
35A6:  ADDWF  x10,W
35A8:  MOVWF  FE9
35AA:  MOVLW  00
35AC:  ADDWFC x11,W
35AE:  MOVWF  FEA
35B0:  MOVFF  FEF,414
35B4:  MOVFF  FEC,415
35B8:  MOVFF  FEC,416
35BC:  MOVFF  FEC,417
35C0:  MOVFF  417,41B
35C4:  MOVFF  416,41A
35C8:  MOVFF  415,419
35CC:  MOVFF  414,418
35D0:  MOVLB  0
35D2:  RCALL  338C
35D4:  MOVFF  413,FEA
35D8:  MOVFF  412,FE9
35DC:  MOVFF  00,FEF
35E0:  MOVFF  01,FEC
35E4:  MOVFF  02,FEC
35E8:  MOVFF  03,FEC
....................    header->AckNumber       = swapl(header->AckNumber); 
35EC:  MOVLW  08
35EE:  MOVLB  4
35F0:  ADDWF  x10,W
35F2:  MOVWF  01
35F4:  MOVLW  00
35F6:  ADDWFC x11,W
35F8:  MOVWF  03
35FA:  MOVFF  01,412
35FE:  MOVWF  x13
3600:  MOVLW  08
3602:  ADDWF  x10,W
3604:  MOVWF  FE9
3606:  MOVLW  00
3608:  ADDWFC x11,W
360A:  MOVWF  FEA
360C:  MOVFF  FEF,414
3610:  MOVFF  FEC,415
3614:  MOVFF  FEC,416
3618:  MOVFF  FEC,417
361C:  MOVFF  417,41B
3620:  MOVFF  416,41A
3624:  MOVFF  415,419
3628:  MOVFF  414,418
362C:  MOVLB  0
362E:  RCALL  338C
3630:  MOVFF  413,FEA
3634:  MOVFF  412,FE9
3638:  MOVFF  00,FEF
363C:  MOVFF  01,FEC
3640:  MOVFF  02,FEC
3644:  MOVFF  03,FEC
....................    header->Window          = swaps(header->Window); 
3648:  MOVLW  0E
364A:  MOVLB  4
364C:  ADDWF  x10,W
364E:  MOVWF  01
3650:  MOVLW  00
3652:  ADDWFC x11,W
3654:  MOVWF  03
3656:  MOVFF  01,412
365A:  MOVWF  x13
365C:  MOVLW  0E
365E:  ADDWF  x10,W
3660:  MOVWF  FE9
3662:  MOVLW  00
3664:  ADDWFC x11,W
3666:  MOVWF  FEA
3668:  MOVFF  FEC,415
366C:  MOVF   FED,F
366E:  MOVFF  FEF,414
3672:  MOVFF  415,430
3676:  MOVFF  414,42F
367A:  MOVLB  0
367C:  CALL   1C92
3680:  MOVFF  413,FEA
3684:  MOVFF  412,FE9
3688:  MOVFF  02,FEC
368C:  MOVF   FED,F
368E:  MOVFF  01,FEF
....................    header->Checksum        = swaps(header->Checksum); 
3692:  MOVLW  10
3694:  MOVLB  4
3696:  ADDWF  x10,W
3698:  MOVWF  01
369A:  MOVLW  00
369C:  ADDWFC x11,W
369E:  MOVWF  03
36A0:  MOVFF  01,412
36A4:  MOVWF  x13
36A6:  MOVLW  10
36A8:  ADDWF  x10,W
36AA:  MOVWF  FE9
36AC:  MOVLW  00
36AE:  ADDWFC x11,W
36B0:  MOVWF  FEA
36B2:  MOVFF  FEC,415
36B6:  MOVF   FED,F
36B8:  MOVFF  FEF,414
36BC:  MOVFF  415,430
36C0:  MOVFF  414,42F
36C4:  MOVLB  0
36C6:  CALL   1C92
36CA:  MOVFF  413,FEA
36CE:  MOVFF  412,FE9
36D2:  MOVFF  02,FEC
36D6:  MOVF   FED,F
36D8:  MOVFF  01,FEF
....................    header->UrgentPointer   = swaps(header->UrgentPointer); 
36DC:  MOVLW  12
36DE:  MOVLB  4
36E0:  ADDWF  x10,W
36E2:  MOVWF  01
36E4:  MOVLW  00
36E6:  ADDWFC x11,W
36E8:  MOVWF  03
36EA:  MOVFF  01,412
36EE:  MOVWF  x13
36F0:  MOVLW  12
36F2:  ADDWF  x10,W
36F4:  MOVWF  FE9
36F6:  MOVLW  00
36F8:  ADDWFC x11,W
36FA:  MOVWF  FEA
36FC:  MOVFF  FEC,415
3700:  MOVF   FED,F
3702:  MOVFF  FEF,414
3706:  MOVFF  415,430
370A:  MOVFF  414,42F
370E:  MOVLB  0
3710:  CALL   1C92
3714:  MOVFF  413,FEA
3718:  MOVFF  412,FE9
371C:  MOVFF  02,FEC
3720:  MOVF   FED,F
3722:  MOVFF  01,FEF
3726:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void CloseSocket(void) 
....................  
....................   Summary: 
....................    Closes a TCP socket. 
....................  
....................   Description: 
....................    This function closes a TCP socket.  All socket state information is  
....................    reset, and any buffered bytes are discarded.  The socket is no longer 
....................    accessible by the application after this point. 
....................  
....................   Precondition: 
....................    The TCPStub corresponding to the socket to be closed is synced. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void CloseSocket(void) 
.................... { 
....................    SyncTCB(); 
*
10E4:  RCALL  100C
....................  
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
10E6:  MOVFF  186,1F3
10EA:  MOVFF  185,1F2
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
10EE:  MOVFF  1DA,1E0
10F2:  MOVFF  1D9,1DF
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
10F6:  MOVFF  1DA,1E2
10FA:  MOVFF  1D9,1E1
....................    MyTCBStub.rxHead = MyTCBStub.bufferRxStart; 
10FE:  MOVFF  1DC,1E4
1102:  MOVFF  1DB,1E3
....................    MyTCBStub.rxTail = MyTCBStub.bufferRxStart; 
1106:  MOVFF  1DC,1E6
110A:  MOVFF  1DB,1E5
....................    MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED; 
110E:  MOVLB  1
1110:  BTFSS  xF0.3
1112:  BRA    1118
1114:  MOVLW  04
1116:  BRA    111A
1118:  MOVLW  0D
111A:  MOVWF  xEF
....................    MyTCBStub.Flags.vUnackedKeepalives = 0; 
111C:  MOVLW  F8
111E:  ANDWF  xF0,W
1120:  MOVWF  xF0
....................    MyTCBStub.Flags.bTimerEnabled = 0; 
1122:  BCF    xF0.4
....................    MyTCBStub.Flags.bTimer2Enabled = 0; 
1124:  BCF    xF0.5
....................    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0; 
1126:  BCF    xF0.6
....................    MyTCBStub.Flags.bOneSegmentReceived = 0; 
1128:  BCF    xF0.7
....................    MyTCBStub.Flags.bHalfFullFlush = 0; 
112A:  BCF    xF1.0
....................    MyTCBStub.Flags.bTXASAP = 0; 
112C:  BCF    xF1.1
....................    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0; 
112E:  BCF    xF1.2
....................    MyTCBStub.Flags.bTXFIN = 0; 
1130:  BCF    xF1.3
....................    MyTCBStub.Flags.bSocketReset = 1; 
1132:  BSF    xF1.4
....................  
....................    #if defined(STACK_USE_SSL) 
....................    // If SSL is active, then we need to close it 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................    { 
....................       SSLTerminate(MyTCBStub.sslStubID); 
....................       MyTCBStub.sslStubID = SSL_INVALID_ID; 
....................  
....................       // Swap the SSL port and local port back to proper values 
....................       MyTCBStub.remoteHash.Val = MyTCB.localSSLPort.Val; 
....................       MyTCB.localSSLPort.Val = MyTCB.localPort.Val; 
....................       MyTCB.localPort.Val = MyTCBStub.remoteHash.Val; 
....................    } 
....................  
....................    // Reset the SSL buffer pointers 
....................    MyTCBStub.sslRxHead = MyTCBStub.bufferRxStart; 
....................    MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    #endif 
....................     
....................    #if defined(STACK_USE_SSL_SERVER) 
....................    MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val; 
....................    #endif 
....................  
....................    MyTCB.flags.bFINSent = 0; 
1134:  BCF    x97.0
....................    MyTCB.flags.bSYNSent = 0; 
1136:  BCF    x97.1
....................    MyTCB.flags.bRXNoneACKed1 = 0; 
1138:  BCF    x97.3
....................    MyTCB.flags.bRXNoneACKed2 = 0; 
113A:  BCF    x97.4
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
113C:  MOVFF  1DA,182
1140:  MOVFF  1D9,181
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand(); 
1144:  MOVLW  01
1146:  MOVLB  3
1148:  MOVWF  xE7
114A:  MOVLW  79
114C:  MOVWF  xE6
114E:  MOVWF  01
1150:  MOVFF  3E7,03
1154:  MOVWF  xE8
1156:  MOVFF  3E7,3E9
115A:  MOVLB  0
115C:  CALL   02A8
1160:  MOVFF  3E9,FEA
1164:  MOVFF  3E8,FE9
1168:  MOVFF  02,FEC
116C:  MOVF   FED,F
116E:  MOVFF  01,FEF
....................    ((DWORD_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand(); 
1172:  MOVLW  01
1174:  MOVLB  3
1176:  MOVWF  xE7
1178:  MOVLW  79
117A:  MOVWF  xE6
117C:  MOVLW  02
117E:  ADDWF  xE6,W
1180:  MOVWF  01
1182:  MOVLW  00
1184:  ADDWFC xE7,W
1186:  MOVWF  03
1188:  MOVFF  01,3E8
118C:  MOVWF  xE9
118E:  MOVLB  0
1190:  CALL   02A8
1194:  MOVFF  3E9,FEA
1198:  MOVFF  3E8,FE9
119C:  MOVFF  02,FEC
11A0:  MOVF   FED,F
11A2:  MOVFF  01,FEF
....................    MyTCB.sHoleSize = -1; 
11A6:  MOVLB  1
11A8:  SETF   x96
11AA:  SETF   x95
....................    MyTCB.remoteWindow = 1; 
11AC:  CLRF   x88
11AE:  MOVLW  01
11B0:  MOVWF  x87
11B2:  MOVLB  0
11B4:  RETURN 0
.................... } 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static WORD GetMaxSegSizeOption(void) 
....................  
....................   Summary: 
....................    Obtains the Maximum Segment Size (MSS) TCP Option out of the TCP header  
....................    for the current socket. 
....................  
....................   Description: 
....................    Parses the current TCP packet header and extracts the Maximum Segment Size  
....................    option.   
....................  
....................   Precondition: 
....................    Must be called while a TCP packet is present and being processed via  
....................    HandleTCPSeg() and only if the the TCP SYN flag is set. 
....................  
....................   Parameters: 
....................    None 
....................  
....................   Returns: 
....................    Maximum segment size option value.  If illegal or not present, a failsafe  
....................    value of 536 is returned.  If the option is larger than the  
....................    TCP_MAX_SEG_SIZE_TX upper limit, then TCP_MAX_SEG_SIZE_TX is returned. 
....................  
....................   Remarks: 
....................    The internal MAC Read Pointer is moved but not restored. 
....................   ***************************************************************************/ 
.................... static WORD GetMaxSegSizeOption(void) 
.................... { 
....................    BYTE vOptionsBytes; 
....................    BYTE vOption; 
....................    WORD wMSS; 
....................  
....................    // Find out how many options bytes are in this packet. 
....................    IPSetRxBuffer(2+2+4+4);   // Seek to data offset field, skipping Source port (2), Destination port (2), Sequence number (4), and Acknowledgement number (4) 
*
5596:  MOVLB  3
5598:  CLRF   xEB
559A:  MOVLW  0C
559C:  MOVWF  xEA
559E:  MOVLB  0
55A0:  CALL   2712
....................    vOptionsBytes = MACGet(); 
55A4:  CALL   0C46
55A8:  MOVFF  01,3E6
....................    vOptionsBytes = ((vOptionsBytes&0xF0)>>2) - sizeof(TCP_HEADER); 
55AC:  MOVLB  3
55AE:  MOVF   xE6,W
55B0:  ANDLW  F0
55B2:  MOVWF  00
55B4:  RRCF   00,F
55B6:  RRCF   00,F
55B8:  MOVLW  3F
55BA:  ANDWF  00,F
55BC:  MOVF   00,W
55BE:  ADDLW  EC
55C0:  MOVWF  xE6
....................  
....................    // Return minimum Maximum Segment Size value of 536 bytes if none are  
....................    // present 
....................    if(vOptionsBytes == 0u) 
55C2:  MOVF   xE6,F
55C4:  BNZ   55D0
....................       return 536; 
55C6:  MOVLW  18
55C8:  MOVWF  01
55CA:  MOVLW  02
55CC:  MOVWF  02
55CE:  BRA    56B4
....................        
....................    // Seek to beginning of options 
....................    MACGetArray(NULL, 7); 
55D0:  MOVLB  4
55D2:  CLRF   x33
55D4:  CLRF   x32
55D6:  CLRF   x35
55D8:  MOVLW  07
55DA:  MOVWF  x34
55DC:  MOVLB  0
55DE:  CALL   0BD0
....................  
....................    // Search for the Maximum Segment Size option    
....................    while(vOptionsBytes--) 
55E2:  MOVLB  3
55E4:  MOVF   xE6,W
55E6:  DECF   xE6,F
55E8:  XORLW  00
55EA:  BTFSC  FD8.2
55EC:  BRA    56AC
....................    { 
....................       vOption = MACGet(); 
55EE:  MOVLB  0
55F0:  CALL   0C46
55F4:  MOVFF  01,3E7
....................        
....................       if(vOption == 0u)   // End of Options list 
55F8:  MOVLB  3
55FA:  MOVF   xE7,F
55FC:  BNZ   5600
....................          break; 
55FE:  BRA    56AC
....................        
....................       if(vOption == 1u)   // NOP option 
5600:  DECFSZ xE7,W
5602:  BRA    5606
....................          continue; 
5604:  BRA    55E4
....................           
....................       if(vOption == 2u)   // Maximum Segment Size option 
5606:  MOVF   xE7,W
5608:  SUBLW  02
560A:  BNZ   5676
....................       { 
....................          if(vOptionsBytes < 3u) 
560C:  MOVF   xE6,W
560E:  SUBLW  02
5610:  BNC   5614
....................             break; 
5612:  BRA    56AC
....................  
....................          wMSS = 0; 
5614:  CLRF   xE9
5616:  CLRF   xE8
....................              
....................          // Get option length 
....................          vOption = MACGet(); 
5618:  MOVLB  0
561A:  CALL   0C46
561E:  MOVFF  01,3E7
....................          if(vOption == 4u) 
5622:  MOVLB  3
5624:  MOVF   xE7,W
5626:  SUBLW  04
5628:  BNZ   563E
....................          {// Retrieve MSS and swap value to little endian 
....................             ((BYTE*)&wMSS)[1] = MACGet(); 
562A:  MOVLB  0
562C:  CALL   0C46
5630:  MOVFF  01,3E9
....................             ((BYTE*)&wMSS)[0] = MACGet(); 
5634:  CALL   0C46
5638:  MOVFF  01,3E8
563C:  MOVLB  3
....................          } 
....................           
....................          if(wMSS < 536u) 
563E:  MOVF   xE9,W
5640:  SUBLW  02
5642:  BNC   564E
5644:  BNZ   564C
5646:  MOVF   xE8,W
5648:  SUBLW  17
564A:  BNC   564E
....................             break; 
564C:  BRA    56AC
....................          if(wMSS > TCP_MAX_SEG_SIZE_TX) 
564E:  MOVF   xE9,W
5650:  SUBLW  04
5652:  BC    566A
5654:  XORLW  FF
5656:  BNZ   565E
5658:  MOVF   xE8,W
565A:  SUBLW  B4
565C:  BC    566A
....................             return TCP_MAX_SEG_SIZE_TX; 
565E:  MOVLW  B4
5660:  MOVWF  01
5662:  MOVLW  05
5664:  MOVWF  02
5666:  BRA    56B4
5668:  BRA    5674
....................          else  
....................             return wMSS; 
566A:  MOVFF  3E8,01
566E:  MOVFF  3E9,02
5672:  BRA    56B4
....................       } 
5674:  BRA    56AA
....................       else 
....................       { // Assume this is a multi byte option and throw it way 
....................          if(vOptionsBytes < 2u) 
5676:  MOVF   xE6,W
5678:  SUBLW  01
567A:  BNC   567E
....................             break; 
567C:  BRA    56AC
....................          vOption = MACGet(); 
567E:  MOVLB  0
5680:  CALL   0C46
5684:  MOVFF  01,3E7
....................          if(vOptionsBytes < vOption) 
5688:  MOVLB  3
568A:  MOVF   xE7,W
568C:  SUBWF  xE6,W
568E:  BC    5692
....................             break; 
5690:  BRA    56AC
....................          MACGetArray(NULL, vOption); 
5692:  MOVLB  4
5694:  CLRF   x33
5696:  CLRF   x32
5698:  CLRF   x35
569A:  MOVFF  3E7,434
569E:  MOVLB  0
56A0:  CALL   0BD0
....................          vOptionsBytes -= vOption; 
56A4:  MOVLB  3
56A6:  MOVF   xE7,W
56A8:  SUBWF  xE6,F
....................       } 
56AA:  BRA    55E4
....................        
....................    } 
....................     
....................    // Did not find MSS option, return worst case default 
....................    return 536; 
56AC:  MOVLW  18
56AE:  MOVWF  01
56B0:  MOVLW  02
56B2:  MOVWF  02
56B4:  MOVLB  0
56B6:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
....................  
....................   Summary: 
....................    Processes an incoming TCP segment. 
....................  
....................   Description: 
....................    Once an incoming segment has been matched to a socket, this function 
....................    performs the necessary processing with the data.  Depending on the  
....................    segment and the state, this may include copying data to the TCP buffer, 
....................    re-assembling out-of order packets, continuing an initialization or  
....................    closing handshake, or closing the socket altogether. 
....................  
....................   Precondition: 
....................    TCP is initialized and the current TCP stub is already synced. 
....................  
....................   Parameters: 
....................    h - The TCP header for this packet 
....................    len - The total buffer length of this segment 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... static void HandleTCPSeg(TCP_HEADER* h, WORD len) 
.................... { 
....................    DWORD dwTemp; 
....................    PTR_BASE wTemp; 
....................    LONG lMissingBytes; 
....................    WORD wMissingBytes; 
....................    WORD wFreeSpace; 
....................    BYTE localHeaderFlags; 
....................    DWORD localAckNumber; 
....................    DWORD localSeqNumber; 
....................    WORD wSegmentLength; 
....................    BOOL bSegmentAcceptable; 
....................    WORD wNewWindow; 
....................  
....................  
....................    // Cache a few variables in local RAM.   
....................    // PIC18s take a fair amount of code and execution time to  
....................    // dereference pointers frequently. 
....................    localHeaderFlags = h->Flags.byte; 
56B8:  MOVLW  0D
56BA:  MOVLB  3
56BC:  ADDWF  xC6,W
56BE:  MOVWF  FE9
56C0:  MOVLW  00
56C2:  ADDWFC xC7,W
56C4:  MOVWF  FEA
56C6:  MOVFF  FEF,3D8
....................    localAckNumber = h->AckNumber; 
56CA:  MOVLW  08
56CC:  ADDWF  xC6,W
56CE:  MOVWF  FE9
56D0:  MOVLW  00
56D2:  ADDWFC xC7,W
56D4:  MOVWF  FEA
56D6:  MOVFF  FEF,3D9
56DA:  MOVFF  FEC,3DA
56DE:  MOVFF  FEC,3DB
56E2:  MOVFF  FEC,3DC
....................    localSeqNumber = h->SeqNumber; 
56E6:  MOVLW  04
56E8:  ADDWF  xC6,W
56EA:  MOVWF  FE9
56EC:  MOVLW  00
56EE:  ADDWFC xC7,W
56F0:  MOVWF  FEA
56F2:  MOVFF  FEF,3DD
56F6:  MOVFF  FEC,3DE
56FA:  MOVFF  FEC,3DF
56FE:  MOVFF  FEC,3E0
....................  
....................    // We received a packet, reset the keep alive timer and count 
....................    #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................       MyTCBStub.Flags.vUnackedKeepalives = 0; 
5702:  MOVLW  F8
5704:  MOVLB  1
5706:  ANDWF  xF0,W
5708:  MOVWF  xF0
....................       if(!MyTCBStub.Flags.bTimerEnabled) 
570A:  BTFSC  xF0.4
570C:  BRA    573C
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
570E:  MOVLB  0
5710:  CALL   2692
5714:  MOVLW  32
5716:  MOVLB  3
5718:  ADDWF  00,W
571A:  MOVLB  1
571C:  MOVWF  xE7
571E:  MOVLW  31
5720:  MOVLB  3
5722:  ADDWFC 01,W
5724:  MOVLB  1
5726:  MOVWF  xE8
5728:  MOVLW  01
572A:  MOVLB  3
572C:  ADDWFC 02,W
572E:  MOVLB  1
5730:  MOVWF  xE9
5732:  MOVLW  00
5734:  MOVLB  3
5736:  ADDWFC 03,W
5738:  MOVLB  1
573A:  MOVWF  xEA
....................    #endif 
....................  
....................    // Handle TCP_LISTEN and TCP_SYN_SENT states 
....................    // Both of these states will return, so code following this  
....................    // state machine need not check explicitly for these two  
....................    // states. 
....................    switch(MyTCBStub.smState) 
573C:  MOVF   xEF,W
573E:  XORLW  04
5740:  MOVLB  0
5742:  BZ    574A
5744:  XORLW  01
5746:  BZ    57E4
5748:  BRA    591A
....................    { 
....................       case TCP_LISTEN: 
....................          // First: check RST flag 
....................          if(localHeaderFlags & RST) 
574A:  MOVLB  3
574C:  BTFSS  xD8.2
574E:  BRA    575C
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
5750:  MOVLB  0
5752:  CALL   10E4
....................             return; 
5756:  GOTO   6888
575A:  MOVLB  3
....................          } 
....................  
....................          // Second: check ACK flag, which would be invalid 
....................          if(localHeaderFlags & ACK) 
575C:  BTFSS  xD8.4
575E:  BRA    5786
....................          { 
....................             // Use a believable sequence number and reset the remote node 
....................             MyTCB.MySEQ = localAckNumber; 
5760:  MOVFF  3DC,17C
5764:  MOVFF  3DB,17B
5768:  MOVFF  3DA,17A
576C:  MOVFF  3D9,179
....................             SendTCP(RST, 0); 
5770:  MOVLW  04
5772:  MOVWF  xE6
5774:  CLRF   xE7
5776:  MOVLB  0
5778:  CALL   3870
....................             CloseSocket();   // Unbind remote IP address/port info 
577C:  CALL   10E4
....................             return; 
5780:  GOTO   6888
5784:  MOVLB  3
....................          } 
....................  
....................          // Third: check for SYN flag, which is what we're looking for 
....................          if(localHeaderFlags & SYN) 
5786:  BTFSS  xD8.1
5788:  BRA    57D6
....................          { 
....................             // We now have a sequence number for the remote node 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
578A:  MOVLW  01
578C:  ADDWF  xDD,W
578E:  MOVLB  1
5790:  MOVWF  x7D
5792:  MOVLW  00
5794:  MOVLB  3
5796:  ADDWFC xDE,W
5798:  MOVLB  1
579A:  MOVWF  x7E
579C:  MOVLW  00
579E:  MOVLB  3
57A0:  ADDWFC xDF,W
57A2:  MOVLB  1
57A4:  MOVWF  x7F
57A6:  MOVLW  00
57A8:  MOVLB  3
57AA:  ADDWFC xE0,W
57AC:  MOVLB  1
57AE:  MOVWF  x80
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
57B0:  MOVLB  0
57B2:  RCALL  5596
57B4:  MOVFF  02,199
57B8:  MOVFF  01,198
....................  
....................             // Set Initial Send Sequence (ISS) number 
....................             // Nothing to do on this step... ISS already set in CloseSocket() 
....................              
....................             // Respond with SYN + ACK 
....................             SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
57BC:  MOVLW  12
57BE:  MOVLB  3
57C0:  MOVWF  xE6
57C2:  MOVLW  01
57C4:  MOVWF  xE7
57C6:  MOVLB  0
57C8:  CALL   3870
....................             MyTCBStub.smState = TCP_SYN_RECEIVED; 
57CC:  MOVLW  06
57CE:  MOVLB  1
57D0:  MOVWF  xEF
....................          } 
57D2:  BRA    57DE
57D4:  MOVLB  3
....................          else 
....................          { 
....................             CloseSocket();   // Unbind remote IP address/port info 
57D6:  MOVLB  0
57D8:  CALL   10E4
57DC:  MOVLB  1
....................          } 
....................  
....................          // Fourth: check for other text and control 
....................          // Nothing to do since we don't support this 
....................          return; 
57DE:  MOVLB  0
57E0:  GOTO   6888
....................  
....................       case TCP_SYN_SENT: 
....................          // Second: check the RST bit 
....................          // This is out of order because this stack has no API for  
....................          // notifying the application that the connection seems to  
....................          // be failing.  Instead, the application must time out and  
....................          // the stack will just keep trying in the mean time. 
....................          if(localHeaderFlags & RST) 
57E4:  MOVLB  3
57E6:  BTFSS  xD8.2
57E8:  BRA    57F2
....................             return; 
57EA:  MOVLB  0
57EC:  GOTO   6888
57F0:  MOVLB  3
....................  
....................          // First: check ACK bit 
....................          if(localHeaderFlags & ACK) 
57F2:  BTFSS  xD8.4
57F4:  BRA    5862
....................          { 
....................             if(localAckNumber != MyTCB.MySEQ) 
57F6:  MOVLB  1
57F8:  MOVF   x79,W
57FA:  MOVLB  3
57FC:  SUBWF  xD9,W
57FE:  BNZ   581E
5800:  MOVLB  1
5802:  MOVF   x7A,W
5804:  MOVLB  3
5806:  SUBWF  xDA,W
5808:  BNZ   581E
580A:  MOVLB  1
580C:  MOVF   x7B,W
580E:  MOVLB  3
5810:  SUBWF  xDB,W
5812:  BNZ   581E
5814:  MOVLB  1
5816:  MOVF   x7C,W
5818:  MOVLB  3
581A:  SUBWF  xDC,W
581C:  BZ    5862
....................             { 
....................                // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................                // number for arivial of any other SYN+ACK packets 
....................                localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
581E:  MOVFF  17C,3E0
5822:  MOVFF  17B,3DF
5826:  MOVFF  17A,3DE
582A:  MOVFF  179,3DD
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
582E:  MOVFF  3DC,17C
5832:  MOVFF  3DB,17B
5836:  MOVFF  3DA,17A
583A:  MOVFF  3D9,179
....................                SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
583E:  MOVLW  04
5840:  MOVWF  xE6
5842:  MOVLW  01
5844:  MOVWF  xE7
5846:  MOVLB  0
5848:  CALL   3870
....................                MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
584C:  MOVFF  3E0,17C
5850:  MOVFF  3DF,17B
5854:  MOVFF  3DE,17A
5858:  MOVFF  3DD,179
....................                return; 
585C:  GOTO   6888
5860:  MOVLB  3
....................             } 
....................          } 
....................  
....................          // Third: check the security and precedence 
....................          // No such feature in this stack.  We want to accept all connections. 
....................  
....................          // Fourth: check the SYN bit 
....................          if(localHeaderFlags & SYN) 
5862:  BTFSS  xD8.1
5864:  BRA    5914
....................          { 
....................             // We now have an initial sequence number and window size 
....................             MyTCB.RemoteSEQ = localSeqNumber + 1; 
5866:  MOVLW  01
5868:  ADDWF  xDD,W
586A:  MOVLB  1
586C:  MOVWF  x7D
586E:  MOVLW  00
5870:  MOVLB  3
5872:  ADDWFC xDE,W
5874:  MOVLB  1
5876:  MOVWF  x7E
5878:  MOVLW  00
587A:  MOVLB  3
587C:  ADDWFC xDF,W
587E:  MOVLB  1
5880:  MOVWF  x7F
5882:  MOVLW  00
5884:  MOVLB  3
5886:  ADDWFC xE0,W
5888:  MOVLB  1
588A:  MOVWF  x80
....................             MyTCB.remoteWindow = h->Window; 
588C:  MOVLW  0E
588E:  MOVLB  3
5890:  ADDWF  xC6,W
5892:  MOVWF  FE9
5894:  MOVLW  00
5896:  ADDWFC xC7,W
5898:  MOVWF  FEA
589A:  MOVFF  FEC,188
589E:  MOVF   FED,F
58A0:  MOVFF  FEF,187
....................  
....................             // Get MSS option 
....................             MyTCB.wRemoteMSS = GetMaxSegSizeOption(); 
58A4:  MOVLB  0
58A6:  RCALL  5596
58A8:  MOVFF  02,199
58AC:  MOVFF  01,198
....................  
....................             if(localHeaderFlags & ACK) 
58B0:  MOVLB  3
58B2:  BTFSS  xD8.4
58B4:  BRA    58FE
....................             { 
....................                SendTCP(ACK, SENDTCP_RESET_TIMERS); 
58B6:  MOVLW  10
58B8:  MOVWF  xE6
58BA:  MOVLW  01
58BC:  MOVWF  xE7
58BE:  MOVLB  0
58C0:  CALL   3870
....................                MyTCBStub.smState = TCP_ESTABLISHED; 
58C4:  MOVLW  07
58C6:  MOVLB  1
58C8:  MOVWF  xEF
....................                // Set up keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
58CA:  MOVLB  0
58CC:  CALL   2692
58D0:  MOVLW  32
58D2:  MOVLB  3
58D4:  ADDWF  00,W
58D6:  MOVLB  1
58D8:  MOVWF  xE7
58DA:  MOVLW  31
58DC:  MOVLB  3
58DE:  ADDWFC 01,W
58E0:  MOVLB  1
58E2:  MOVWF  xE8
58E4:  MOVLW  01
58E6:  MOVLB  3
58E8:  ADDWFC 02,W
58EA:  MOVLB  1
58EC:  MOVWF  xE9
58EE:  MOVLW  00
58F0:  MOVLB  3
58F2:  ADDWFC 03,W
58F4:  MOVLB  1
58F6:  MOVWF  xEA
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
58F8:  BCF    xF0.4
....................             } 
58FA:  BRA    5912
58FC:  MOVLB  3
....................             else 
....................             { 
....................                SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS); 
58FE:  MOVLW  12
5900:  MOVWF  xE6
5902:  MOVLW  01
5904:  MOVWF  xE7
5906:  MOVLB  0
5908:  CALL   3870
....................                MyTCBStub.smState = TCP_SYN_RECEIVED; 
590C:  MOVLW  06
590E:  MOVLB  1
5910:  MOVWF  xEF
5912:  MOVLB  3
....................             } 
....................          } 
....................  
....................          // Fifth: drop the segment if neither SYN or RST is set 
....................          return; 
5914:  MOVLB  0
5916:  GOTO   6888
....................  
....................       default: 
....................          break; 
....................    } 
....................  
....................    // 
....................    // First: check the sequence number 
....................    // 
....................    wSegmentLength = len; 
591A:  MOVFF  3C9,3E2
591E:  MOVFF  3C8,3E1
....................    if(localHeaderFlags & FIN) 
5922:  MOVLB  3
5924:  BTFSS  xD8.0
5926:  BRA    592E
....................       wSegmentLength++; 
5928:  INCF   xE1,F
592A:  BTFSC  FD8.2
592C:  INCF   xE2,F
....................    if(localHeaderFlags & SYN) 
592E:  BTFSS  xD8.1
5930:  BRA    5938
....................       wSegmentLength++; 
5932:  INCF   xE1,F
5934:  BTFSC  FD8.2
5936:  INCF   xE2,F
....................  
....................    // Calculate the RX FIFO space 
....................    if(MyTCBStub.rxHead >= MyTCBStub.rxTail) 
5938:  MOVLB  1
593A:  MOVF   xE6,W
593C:  SUBWF  xE4,W
593E:  BNC   597A
5940:  BNZ   5948
5942:  MOVF   xE5,W
5944:  SUBWF  xE3,W
5946:  BNC   597A
....................       wFreeSpace = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail); 
5948:  MOVF   xDB,W
594A:  SUBWF  xDD,W
594C:  MOVLB  3
594E:  MOVWF  xE6
5950:  MOVLB  1
5952:  MOVF   xDC,W
5954:  SUBWFB xDE,W
5956:  MOVLB  3
5958:  MOVWF  xE7
595A:  MOVLB  1
595C:  MOVF   xE5,W
595E:  SUBWF  xE3,W
5960:  MOVWF  00
5962:  MOVF   xE6,W
5964:  SUBWFB xE4,W
5966:  MOVWF  03
5968:  MOVF   00,W
596A:  MOVLB  3
596C:  SUBWF  xE6,W
596E:  MOVWF  xD6
5970:  MOVF   03,W
5972:  SUBWFB xE7,W
5974:  MOVWF  xD7
5976:  BRA    5998
5978:  MOVLB  1
....................    else 
....................       wFreeSpace = MyTCBStub.rxTail - MyTCBStub.rxHead - 1; 
597A:  MOVF   xE3,W
597C:  SUBWF  xE5,W
597E:  MOVLB  3
5980:  MOVWF  xE6
5982:  MOVLB  1
5984:  MOVF   xE4,W
5986:  SUBWFB xE6,W
5988:  MOVLB  3
598A:  MOVWF  xE7
598C:  MOVLW  01
598E:  SUBWF  xE6,W
5990:  MOVWF  xD6
5992:  MOVLW  00
5994:  SUBWFB xE7,W
5996:  MOVWF  xD7
....................  
....................    // Calculate the number of bytes ahead of our head pointer this segment skips 
....................    lMissingBytes = localSeqNumber - MyTCB.RemoteSEQ; 
5998:  MOVLB  1
599A:  MOVF   x7D,W
599C:  MOVLB  3
599E:  SUBWF  xDD,W
59A0:  MOVWF  00
59A2:  MOVLB  1
59A4:  MOVF   x7E,W
59A6:  MOVLB  3
59A8:  SUBWFB xDE,W
59AA:  MOVWF  01
59AC:  MOVLB  1
59AE:  MOVF   x7F,W
59B0:  MOVLB  3
59B2:  SUBWFB xDF,W
59B4:  MOVWF  02
59B6:  MOVLB  1
59B8:  MOVF   x80,W
59BA:  MOVLB  3
59BC:  SUBWFB xE0,W
59BE:  MOVWF  xD3
59C0:  MOVFF  02,3D2
59C4:  MOVFF  01,3D1
59C8:  MOVFF  00,3D0
....................    wMissingBytes = (WORD)lMissingBytes; 
59CC:  MOVFF  3D1,3D5
59D0:  MOVFF  3D0,3D4
....................     
....................    // Run TCP acceptability tests to verify that this packet has a valid sequence number 
....................    bSegmentAcceptable = FALSE; 
59D4:  BCF    xE3.0
....................    if(wSegmentLength) 
59D6:  MOVF   xE1,W
59D8:  IORWF  xE2,W
59DA:  BTFSC  FD8.2
59DC:  BRA    5AE0
....................    { 
....................       // Check to see if we have free space, and if so, if any of the data falls within the freespace 
....................       if(wFreeSpace) 
59DE:  MOVF   xD6,W
59E0:  IORWF  xD7,W
59E2:  BTFSC  FD8.2
59E4:  BRA    5ADE
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
59E6:  BTFSC  xD3.7
59E8:  BRA    5A04
59EA:  MOVF   xD3,F
59EC:  BNZ   5A04
59EE:  MOVF   xD2,F
59F0:  BNZ   5A04
59F2:  MOVF   xD1,W
59F4:  SUBWF  xD7,W
59F6:  BNC   5A04
59F8:  BNZ   5A00
59FA:  MOVF   xD6,W
59FC:  SUBWF  xD0,W
59FE:  BC    5A04
....................             bSegmentAcceptable = TRUE; 
5A00:  BSF    xE3.0
5A02:  BRA    5A8A
....................          else 
....................          { 
....................             // RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND 
....................             if((lMissingBytes + (LONG)wSegmentLength > (LONG)0) && (lMissingBytes <= (LONG)(SHORT)(wFreeSpace - wSegmentLength))) 
5A04:  MOVFF  3E1,00
5A08:  MOVFF  3E2,01
5A0C:  CLRF   02
5A0E:  CLRF   03
5A10:  MOVF   xE1,W
5A12:  ADDWF  xD0,W
5A14:  MOVWF  xE6
5A16:  MOVF   xE2,W
5A18:  ADDWFC xD1,W
5A1A:  MOVWF  xE7
5A1C:  MOVF   02,W
5A1E:  ADDWFC xD2,W
5A20:  MOVWF  xE8
5A22:  MOVF   03,W
5A24:  ADDWFC xD3,W
5A26:  MOVWF  xE9
5A28:  BTFSC  FE8.7
5A2A:  BRA    5A8A
5A2C:  MOVF   xE9,F
5A2E:  BNZ   5A3E
5A30:  MOVF   xE8,F
5A32:  BNZ   5A3E
5A34:  MOVF   xE7,F
5A36:  BNZ   5A3E
5A38:  MOVF   xE6,W
5A3A:  SUBLW  00
5A3C:  BC    5A8A
5A3E:  MOVF   xE1,W
5A40:  SUBWF  xD6,W
5A42:  MOVWF  00
5A44:  MOVF   xE2,W
5A46:  SUBWFB xD7,W
5A48:  MOVWF  03
5A4A:  MOVF   00,W
5A4C:  MOVFF  03,01
5A50:  CLRF   02
5A52:  CLRF   03
5A54:  BTFSS  01.7
5A56:  BRA    5A5C
5A58:  DECF   02,F
5A5A:  DECF   03,F
5A5C:  BTFSS  xD3.7
5A5E:  BRA    5A66
5A60:  BTFSS  03.7
5A62:  BRA    5A88
5A64:  BRA    5A6A
5A66:  BTFSC  03.7
5A68:  BRA    5A8A
5A6A:  MOVF   xD3,W
5A6C:  SUBWF  03,W
5A6E:  BNC   5A8A
5A70:  BNZ   5A88
5A72:  MOVF   xD2,W
5A74:  SUBWF  02,W
5A76:  BNC   5A8A
5A78:  BNZ   5A88
5A7A:  MOVF   xD1,W
5A7C:  SUBWF  01,W
5A7E:  BNC   5A8A
5A80:  BNZ   5A88
5A82:  MOVF   xD0,W
5A84:  SUBWF  00,W
5A86:  BNC   5A8A
....................                bSegmentAcceptable = TRUE; 
5A88:  BSF    xE3.0
....................          } 
....................           
....................          if((lMissingBytes < (LONG)wFreeSpace) && ((SHORT)wMissingBytes + (SHORT)wSegmentLength > (SHORT)0)) 
5A8A:  MOVFF  3D6,00
5A8E:  MOVFF  3D7,01
5A92:  CLRF   02
5A94:  CLRF   03
5A96:  BTFSS  xD3.7
5A98:  BRA    5AA0
5A9A:  BTFSS  03.7
5A9C:  BRA    5AC2
5A9E:  BRA    5AA4
5AA0:  BTFSC  03.7
5AA2:  BRA    5ADE
5AA4:  MOVF   xD3,W
5AA6:  SUBWF  03,W
5AA8:  BNC   5ADE
5AAA:  BNZ   5AC2
5AAC:  MOVF   xD2,W
5AAE:  SUBWF  02,W
5AB0:  BNC   5ADE
5AB2:  BNZ   5AC2
5AB4:  MOVF   xD1,W
5AB6:  SUBWF  01,W
5AB8:  BNC   5ADE
5ABA:  BNZ   5AC2
5ABC:  MOVF   00,W
5ABE:  SUBWF  xD0,W
5AC0:  BC    5ADE
5AC2:  MOVF   xE1,W
5AC4:  ADDWF  xD4,W
5AC6:  MOVWF  xE6
5AC8:  MOVF   xE2,W
5ACA:  ADDWFC xD5,W
5ACC:  MOVWF  xE7
5ACE:  BTFSC  FE8.7
5AD0:  BRA    5ADE
5AD2:  MOVF   xE7,F
5AD4:  BNZ   5ADC
5AD6:  MOVF   xE6,W
5AD8:  SUBLW  00
5ADA:  BC    5ADE
....................             bSegmentAcceptable = TRUE; 
5ADC:  BSF    xE3.0
....................       } 
....................       // Segments with data are not acceptable if we have no free space 
....................    } 
5ADE:  BRA    5B10
....................    else 
....................    { 
....................       // Zero length packets are acceptable if they fall within our free space window 
....................       // SEG.SEQ = RCV.NXT 
....................       if(lMissingBytes == 0) 
5AE0:  MOVF   xD0,F
5AE2:  BNZ   5AF4
5AE4:  MOVF   xD1,F
5AE6:  BNZ   5AF4
5AE8:  MOVF   xD2,F
5AEA:  BNZ   5AF4
5AEC:  MOVF   xD3,F
5AEE:  BNZ   5AF4
....................       { 
....................          bSegmentAcceptable = TRUE; 
5AF0:  BSF    xE3.0
....................       } 
5AF2:  BRA    5B10
....................       else 
....................       { 
....................          // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND 
....................          if((lMissingBytes >= (LONG)0) && (wFreeSpace > (DWORD)lMissingBytes)) 
5AF4:  BTFSC  xD3.7
5AF6:  BRA    5B10
5AF8:  MOVF   xD3,F
5AFA:  BNZ   5B10
5AFC:  MOVF   xD2,F
5AFE:  BNZ   5B10
5B00:  MOVF   xD1,W
5B02:  SUBWF  xD7,W
5B04:  BNC   5B10
5B06:  BNZ   5B0E
5B08:  MOVF   xD6,W
5B0A:  SUBWF  xD0,W
5B0C:  BC    5B10
....................             bSegmentAcceptable = TRUE; 
5B0E:  BSF    xE3.0
....................       } 
....................    } 
....................     
....................    if(!bSegmentAcceptable) 
5B10:  BTFSC  xE3.0
5B12:  BRA    5B30
....................    { 
....................       // Unacceptable segment, drop it and respond appropriately 
....................       if(!(localHeaderFlags & RST))  
5B14:  BTFSC  xD8.2
5B16:  BRA    5B28
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
5B18:  MOVLW  10
5B1A:  MOVWF  xE6
5B1C:  MOVLW  01
5B1E:  MOVWF  xE7
5B20:  MOVLB  0
5B22:  CALL   3870
5B26:  MOVLB  3
....................       return; 
5B28:  MOVLB  0
5B2A:  GOTO   6888
5B2E:  MOVLB  3
....................    } 
....................  
....................  
....................    // 
....................    // Second: check the RST bit 
....................    // 
....................    // 
....................    // Fourth: check the SYN bit 
....................    // 
....................    // Note, that since the third step is not implemented, we can  
....................    // combine this second and fourth step into a single operation. 
....................    if(localHeaderFlags & (RST | SYN)) 
5B30:  MOVF   xD8,W
5B32:  ANDLW  06
5B34:  BZ    5B42
....................    { 
....................       CloseSocket(); 
5B36:  MOVLB  0
5B38:  CALL   10E4
....................       return; 
5B3C:  GOTO   6888
5B40:  MOVLB  3
....................    } 
....................  
....................    // 
....................    // Third: check the security and precedence 
....................    // 
....................    // Feature not supported.  Let's process this segment. 
....................  
....................    // 
....................    // Fifth: check the ACK bit 
....................    // 
....................    if(!(localHeaderFlags & ACK)) 
5B42:  BTFSC  xD8.4
5B44:  BRA    5B4E
....................       return; 
5B46:  MOVLB  0
5B48:  GOTO   6888
5B4C:  MOVLB  3
....................  
....................    switch(MyTCBStub.smState) 
5B4E:  MOVLB  1
5B50:  MOVF   xEF,W
5B52:  XORLW  06
5B54:  MOVLB  0
5B56:  BZ    5B74
5B58:  XORLW  01
5B5A:  BZ    5BE8
5B5C:  XORLW  0F
5B5E:  BZ    5BE8
5B60:  XORLW  01
5B62:  BZ    5BE8
5B64:  XORLW  02
5B66:  BZ    5BE8
5B68:  XORLW  01
5B6A:  BZ    5BE8
5B6C:  XORLW  06
5B6E:  BTFSC  FD8.2
5B70:  BRA    612C
5B72:  BRA    617A
....................    { 
....................       case TCP_SYN_RECEIVED: 
....................          if(localAckNumber != MyTCB.MySEQ) 
5B74:  MOVLB  1
5B76:  MOVF   x79,W
5B78:  MOVLB  3
5B7A:  SUBWF  xD9,W
5B7C:  BNZ   5B9C
5B7E:  MOVLB  1
5B80:  MOVF   x7A,W
5B82:  MOVLB  3
5B84:  SUBWF  xDA,W
5B86:  BNZ   5B9C
5B88:  MOVLB  1
5B8A:  MOVF   x7B,W
5B8C:  MOVLB  3
5B8E:  SUBWF  xDB,W
5B90:  BNZ   5B9C
5B92:  MOVLB  1
5B94:  MOVF   x7C,W
5B96:  MOVLB  3
5B98:  SUBWF  xDC,W
5B9A:  BZ    5BE0
....................          { 
....................             // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ  
....................             // number for arivial of any other correct packets 
....................             localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number 
5B9C:  MOVFF  17C,3E0
5BA0:  MOVFF  17B,3DF
5BA4:  MOVFF  17A,3DE
5BA8:  MOVFF  179,3DD
....................             MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
5BAC:  MOVFF  3DC,17C
5BB0:  MOVFF  3DB,17B
5BB4:  MOVFF  3DA,17A
5BB8:  MOVFF  3D9,179
....................             SendTCP(RST, SENDTCP_RESET_TIMERS);      // Send the RST 
5BBC:  MOVLW  04
5BBE:  MOVWF  xE6
5BC0:  MOVLW  01
5BC2:  MOVWF  xE7
5BC4:  MOVLB  0
5BC6:  CALL   3870
....................             MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number 
5BCA:  MOVFF  3E0,17C
5BCE:  MOVFF  3DF,17B
5BD2:  MOVFF  3DE,17A
5BD6:  MOVFF  3DD,179
....................             return; 
5BDA:  GOTO   6888
5BDE:  MOVLB  3
....................          } 
....................          MyTCBStub.smState = TCP_ESTABLISHED; 
5BE0:  MOVLW  07
5BE2:  MOVLB  1
5BE4:  MOVWF  xEF
5BE6:  MOVLB  0
....................          // No break 
....................  
....................       case TCP_ESTABLISHED: 
....................       case TCP_FIN_WAIT_1: 
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSE_WAIT: 
....................       case TCP_CLOSING: 
....................          // Calculate what the highest possible SEQ number in our TX FIFO is 
....................          wTemp = MyTCBStub.txHead - MyTCB.txUnackedTail; 
5BE8:  MOVLB  1
5BEA:  MOVF   x81,W
5BEC:  SUBWF  xDF,W
5BEE:  MOVLB  3
5BF0:  MOVWF  xCE
5BF2:  MOVLB  1
5BF4:  MOVF   x82,W
5BF6:  SUBWFB xE0,W
5BF8:  MOVLB  3
5BFA:  MOVWF  xCF
....................          if((SHORT)wTemp < (SHORT)0) 
5BFC:  BTFSS  xCF.7
5BFE:  BRA    5C18
....................             wTemp += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
5C00:  MOVLB  1
5C02:  MOVF   xD9,W
5C04:  SUBWF  xDB,W
5C06:  MOVWF  00
5C08:  MOVF   xDA,W
5C0A:  SUBWFB xDC,W
5C0C:  MOVWF  03
5C0E:  MOVF   00,W
5C10:  MOVLB  3
5C12:  ADDWF  xCE,F
5C14:  MOVF   03,W
5C16:  ADDWFC xCF,F
....................          dwTemp = MyTCB.MySEQ + (DWORD)wTemp; 
5C18:  CLRF   02
5C1A:  CLRF   03
5C1C:  MOVF   xCE,W
5C1E:  MOVLB  1
5C20:  ADDWF  x79,W
5C22:  MOVLB  3
5C24:  MOVWF  xCA
5C26:  MOVF   xCF,W
5C28:  MOVLB  1
5C2A:  ADDWFC x7A,W
5C2C:  MOVLB  3
5C2E:  MOVWF  xCB
5C30:  MOVF   02,W
5C32:  MOVLB  1
5C34:  ADDWFC x7B,W
5C36:  MOVLB  3
5C38:  MOVWF  xCC
5C3A:  MOVF   03,W
5C3C:  MOVLB  1
5C3E:  ADDWFC x7C,W
5C40:  MOVLB  3
5C42:  MOVWF  xCD
....................  
....................          // Drop the packet if it ACKs something we haven't sent 
....................             dwTemp = (LONG)localAckNumber - (LONG)dwTemp; 
5C44:  MOVF   xCA,W
5C46:  SUBWF  xD9,W
5C48:  MOVWF  00
5C4A:  MOVF   xCB,W
5C4C:  SUBWFB xDA,W
5C4E:  MOVWF  01
5C50:  MOVF   xCC,W
5C52:  SUBWFB xDB,W
5C54:  MOVWF  02
5C56:  MOVF   xCD,W
5C58:  SUBWFB xDC,W
5C5A:  MOVWF  xCD
5C5C:  MOVFF  02,3CC
5C60:  MOVFF  01,3CB
5C64:  MOVFF  00,3CA
....................             if((LONG)dwTemp > 0) 
5C68:  BTFSC  xCD.7
5C6A:  BRA    5CD0
5C6C:  MOVF   xCD,F
5C6E:  BNZ   5C7E
5C70:  MOVF   xCC,F
5C72:  BNZ   5C7E
5C74:  MOVF   xCB,F
5C76:  BNZ   5C7E
5C78:  MOVF   xCA,W
5C7A:  SUBLW  00
5C7C:  BC    5CD0
....................             {   // acknowledged more than we've sent?? 
....................                 if(!MyTCB.flags.bFINSent || dwTemp != 1) 
5C7E:  MOVLB  1
5C80:  BTFSS  x97.0
5C82:  BRA    5CAA
5C84:  MOVLB  3
5C86:  DECFSZ xCA,W
5C88:  BRA    5C8C
5C8A:  BRA    5C90
5C8C:  MOVLB  1
5C8E:  BRA    5CAA
5C90:  MOVF   xCB,F
5C92:  BTFSC  FD8.2
5C94:  BRA    5C9A
5C96:  MOVLB  1
5C98:  BRA    5CAA
5C9A:  MOVF   xCC,F
5C9C:  BTFSC  FD8.2
5C9E:  BRA    5CA4
5CA0:  MOVLB  1
5CA2:  BRA    5CAA
5CA4:  MOVF   xCD,F
5CA6:  BZ    5CC0
5CA8:  MOVLB  1
....................                 { 
....................                     SendTCP(ACK, 0); 
5CAA:  MOVLW  10
5CAC:  MOVLB  3
5CAE:  MOVWF  xE6
5CB0:  CLRF   xE7
5CB2:  MOVLB  0
5CB4:  CALL   3870
....................                     return; 
5CB8:  GOTO   6888
....................                 } 
5CBC:  BRA    5CD2
5CBE:  MOVLB  3
....................                 else 
....................                 { 
....................                     localAckNumber--;   // since we don't count the FIN anyway 
5CC0:  MOVLW  FF
5CC2:  ADDWF  xD9,F
5CC4:  BTFSS  FD8.0
5CC6:  ADDWF  xDA,F
5CC8:  BTFSS  FD8.0
5CCA:  ADDWF  xDB,F
5CCC:  BTFSS  FD8.0
5CCE:  ADDWF  xDC,F
5CD0:  MOVLB  0
....................                 } 
....................             } 
....................  
....................          // Throw away all ACKnowledged TX data: 
....................          // Calculate what the last acknowledged sequence number was (ignoring any FINs we sent) 
....................          dwTemp = MyTCB.MySEQ - (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
5CD2:  MOVLB  1
5CD4:  MOVF   xE1,W
5CD6:  SUBWF  x81,W
5CD8:  MOVWF  00
5CDA:  MOVF   xE2,W
5CDC:  SUBWFB x82,W
5CDE:  MOVWF  03
5CE0:  MOVF   00,W
5CE2:  MOVFF  03,01
5CE6:  CLRF   02
5CE8:  CLRF   03
5CEA:  BTFSS  01.7
5CEC:  BRA    5CF2
5CEE:  DECF   02,F
5CF0:  DECF   03,F
5CF2:  MOVF   00,W
5CF4:  SUBWF  x79,W
5CF6:  MOVWF  00
5CF8:  MOVF   01,W
5CFA:  SUBWFB x7A,W
5CFC:  MOVWF  01
5CFE:  MOVF   02,W
5D00:  SUBWFB x7B,W
5D02:  MOVWF  02
5D04:  MOVF   03,W
5D06:  SUBWFB x7C,W
5D08:  MOVFF  FE8,3CD
5D0C:  MOVFF  02,3CC
5D10:  MOVFF  01,3CB
5D14:  MOVFF  00,3CA
....................          if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
5D18:  MOVF   x82,W
5D1A:  SUBWF  xE2,W
5D1C:  BNC   5D44
5D1E:  BNZ   5D26
5D20:  MOVF   xE1,W
5D22:  SUBWF  x81,W
5D24:  BC    5D44
....................             dwTemp -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
5D26:  MOVF   xD9,W
5D28:  SUBWF  xDB,W
5D2A:  MOVWF  00
5D2C:  MOVF   xDA,W
5D2E:  SUBWFB xDC,W
5D30:  MOVWF  03
5D32:  MOVF   00,W
5D34:  MOVLB  3
5D36:  SUBWF  xCA,F
5D38:  MOVF   03,W
5D3A:  SUBWFB xCB,F
5D3C:  MOVLW  00
5D3E:  SUBWFB xCC,F
5D40:  SUBWFB xCD,F
5D42:  MOVLB  1
....................     
....................          // Calcluate how many bytes were ACKed with this packet 
....................          dwTemp = localAckNumber - dwTemp; 
5D44:  MOVLB  3
5D46:  MOVF   xCA,W
5D48:  SUBWF  xD9,W
5D4A:  MOVWF  xCA
5D4C:  MOVF   xCB,W
5D4E:  SUBWFB xDA,W
5D50:  MOVWF  xCB
5D52:  MOVF   xCC,W
5D54:  SUBWFB xDB,W
5D56:  MOVWF  xCC
5D58:  MOVF   xCD,W
5D5A:  SUBWFB xDC,W
5D5C:  MOVWF  xCD
....................          if(((LONG)(dwTemp) > (LONG)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart)) 
5D5E:  BTFSC  xCD.7
5D60:  BRA    5EBA
5D62:  MOVF   xCD,F
5D64:  BNZ   5D76
5D66:  MOVF   xCC,F
5D68:  BNZ   5D76
5D6A:  MOVF   xCB,F
5D6C:  BNZ   5D76
5D6E:  MOVF   xCA,W
5D70:  SUBLW  00
5D72:  BTFSC  FD8.0
5D74:  BRA    5EBA
5D76:  MOVLB  1
5D78:  MOVF   xD9,W
5D7A:  SUBWF  xDB,W
5D7C:  MOVWF  00
5D7E:  MOVF   xDA,W
5D80:  SUBWFB xDC,W
5D82:  MOVWF  03
5D84:  MOVFF  00,01
5D88:  MOVLB  3
5D8A:  MOVF   xCD,F
5D8C:  BTFSS  FD8.2
5D8E:  BRA    5EBA
5D90:  MOVF   xCC,F
5D92:  BTFSS  FD8.2
5D94:  BRA    5EBA
5D96:  MOVF   xCB,W
5D98:  SUBWF  03,W
5D9A:  BTFSS  FD8.0
5D9C:  BRA    5EBA
5D9E:  BNZ   5DA8
5DA0:  MOVF   xCA,W
5DA2:  SUBWF  01,W
5DA4:  BTFSS  FD8.0
5DA6:  BRA    5EBA
....................          { 
....................             MyTCB.flags.bRXNoneACKed1 = 0; 
5DA8:  MOVLB  1
5DAA:  BCF    x97.3
....................             MyTCB.flags.bRXNoneACKed2 = 0; 
5DAC:  BCF    x97.4
....................             MyTCBStub.Flags.bHalfFullFlush = FALSE; 
5DAE:  BCF    xF1.0
....................     
....................             // Bytes ACKed, free up the TX FIFO space 
....................             wTemp = MyTCBStub.txTail; 
5DB0:  MOVFF  1E2,3CF
5DB4:  MOVFF  1E1,3CE
....................             MyTCBStub.txTail += dwTemp; 
5DB8:  MOVLB  3
5DBA:  MOVF   xCA,W
5DBC:  MOVLB  1
5DBE:  ADDWF  xE1,F
5DC0:  MOVLB  3
5DC2:  MOVF   xCB,W
5DC4:  MOVLB  1
5DC6:  ADDWFC xE2,F
....................             if(MyTCB.txUnackedTail >= wTemp) 
5DC8:  MOVLB  3
5DCA:  MOVF   xCF,W
5DCC:  MOVLB  1
5DCE:  SUBWF  x82,W
5DD0:  BNC   5E10
5DD2:  BNZ   5DDE
5DD4:  MOVLB  3
5DD6:  MOVF   xCE,W
5DD8:  MOVLB  1
5DDA:  SUBWF  x81,W
5DDC:  BNC   5E10
....................             { 
....................                if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
5DDE:  MOVF   x82,W
5DE0:  SUBWF  xE2,W
5DE2:  BNC   5E0E
5DE4:  BNZ   5DEC
5DE6:  MOVF   xE1,W
5DE8:  SUBWF  x81,W
5DEA:  BC    5E0E
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - MyTCB.txUnackedTail; 
5DEC:  MOVF   x81,W
5DEE:  SUBWF  xE1,W
5DF0:  MOVWF  00
5DF2:  MOVF   x82,W
5DF4:  SUBWFB xE2,W
5DF6:  MOVWF  03
5DF8:  MOVF   00,W
5DFA:  ADDWF  x79,F
5DFC:  MOVF   03,W
5DFE:  ADDWFC x7A,F
5E00:  MOVLW  00
5E02:  ADDWFC x7B,F
5E04:  ADDWFC x7C,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
5E06:  MOVFF  1E2,182
5E0A:  MOVFF  1E1,181
....................                } 
....................             } 
5E0E:  BRA    5E72
....................             else 
....................             { 
....................                wTemp = MyTCB.txUnackedTail + (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
5E10:  MOVF   xD9,W
5E12:  SUBWF  xDB,W
5E14:  MOVWF  00
5E16:  MOVF   xDA,W
5E18:  SUBWFB xDC,W
5E1A:  MOVWF  03
5E1C:  MOVF   00,W
5E1E:  ADDWF  x81,W
5E20:  MOVLB  3
5E22:  MOVWF  xCE
5E24:  MOVF   03,W
5E26:  MOVLB  1
5E28:  ADDWFC x82,W
5E2A:  MOVLB  3
5E2C:  MOVWF  xCF
....................                if(wTemp < MyTCBStub.txTail) 
5E2E:  MOVF   xCF,W
5E30:  MOVLB  1
5E32:  SUBWF  xE2,W
5E34:  BNC   5E72
5E36:  BNZ   5E48
5E38:  MOVF   xE1,W
5E3A:  MOVLB  3
5E3C:  SUBWF  xCE,W
5E3E:  BTFSS  FD8.0
5E40:  BRA    5E46
5E42:  MOVLB  1
5E44:  BRA    5E72
5E46:  MOVLB  1
....................                { 
....................                   MyTCB.MySEQ += MyTCBStub.txTail - wTemp; 
5E48:  MOVLB  3
5E4A:  MOVF   xCE,W
5E4C:  MOVLB  1
5E4E:  SUBWF  xE1,W
5E50:  MOVWF  00
5E52:  MOVLB  3
5E54:  MOVF   xCF,W
5E56:  MOVLB  1
5E58:  SUBWFB xE2,W
5E5A:  MOVWF  03
5E5C:  MOVF   00,W
5E5E:  ADDWF  x79,F
5E60:  MOVF   03,W
5E62:  ADDWFC x7A,F
5E64:  MOVLW  00
5E66:  ADDWFC x7B,F
5E68:  ADDWFC x7C,F
....................                   MyTCB.txUnackedTail = MyTCBStub.txTail; 
5E6A:  MOVFF  1E2,182
5E6E:  MOVFF  1E1,181
....................                } 
....................             } 
....................             if(MyTCBStub.txTail >= MyTCBStub.bufferRxStart) 
5E72:  MOVF   xDC,W
5E74:  SUBWF  xE2,W
5E76:  BNC   5E94
5E78:  BNZ   5E80
5E7A:  MOVF   xDB,W
5E7C:  SUBWF  xE1,W
5E7E:  BNC   5E94
....................                MyTCBStub.txTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
5E80:  MOVF   xD9,W
5E82:  SUBWF  xDB,W
5E84:  MOVWF  00
5E86:  MOVF   xDA,W
5E88:  SUBWFB xDC,W
5E8A:  MOVWF  03
5E8C:  MOVF   00,W
5E8E:  SUBWF  xE1,F
5E90:  MOVF   03,W
5E92:  SUBWFB xE2,F
....................             if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart) 
5E94:  MOVF   xDC,W
5E96:  SUBWF  x82,W
5E98:  BNC   5EB6
5E9A:  BNZ   5EA2
5E9C:  MOVF   xDB,W
5E9E:  SUBWF  x81,W
5EA0:  BNC   5EB6
....................                MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart; 
5EA2:  MOVF   xD9,W
5EA4:  SUBWF  xDB,W
5EA6:  MOVWF  00
5EA8:  MOVF   xDA,W
5EAA:  SUBWFB xDC,W
5EAC:  MOVWF  03
5EAE:  MOVF   00,W
5EB0:  SUBWF  x81,F
5EB2:  MOVF   03,W
5EB4:  SUBWFB x82,F
....................          } 
5EB6:  BRA    5F70
5EB8:  MOVLB  3
....................          else 
....................          { 
....................             // See if we have outstanding TX data that is waiting for an ACK 
....................             if(MyTCBStub.txTail != MyTCB.txUnackedTail) 
5EBA:  MOVLB  1
5EBC:  MOVF   x81,W
5EBE:  SUBWF  xE1,W
5EC0:  BNZ   5EC8
5EC2:  MOVF   x82,W
5EC4:  SUBWF  xE2,W
5EC6:  BZ    5F70
....................             { 
....................                if(MyTCB.flags.bRXNoneACKed1) 
5EC8:  BTFSS  x97.3
5ECA:  BRA    5F6E
....................                { 
....................                   if(MyTCB.flags.bRXNoneACKed2) 
5ECC:  BTFSS  x97.4
5ECE:  BRA    5F6C
....................                   { 
....................                      // Set up to perform a fast retransmission 
....................                      // Roll back unacknowledged TX tail pointer to cause retransmit to occur 
....................                      MyTCB.MySEQ -= (LONG)(SHORT)(MyTCB.txUnackedTail - MyTCBStub.txTail); 
5ED0:  MOVF   xE1,W
5ED2:  SUBWF  x81,W
5ED4:  MOVWF  00
5ED6:  MOVF   xE2,W
5ED8:  SUBWFB x82,W
5EDA:  MOVWF  03
5EDC:  MOVF   00,W
5EDE:  MOVFF  03,01
5EE2:  CLRF   02
5EE4:  CLRF   03
5EE6:  BTFSS  01.7
5EE8:  BRA    5EEE
5EEA:  DECF   02,F
5EEC:  DECF   03,F
5EEE:  MOVF   00,W
5EF0:  SUBWF  x79,W
5EF2:  MOVWF  00
5EF4:  MOVF   01,W
5EF6:  SUBWFB x7A,W
5EF8:  MOVWF  01
5EFA:  MOVF   02,W
5EFC:  SUBWFB x7B,W
5EFE:  MOVWF  02
5F00:  MOVF   03,W
5F02:  SUBWFB x7C,W
5F04:  MOVWF  x7C
5F06:  MOVFF  02,17B
5F0A:  MOVFF  01,17A
5F0E:  MOVFF  00,179
....................                      if(MyTCB.txUnackedTail < MyTCBStub.txTail) 
5F12:  MOVF   x82,W
5F14:  SUBWF  xE2,W
5F16:  BNC   5F62
5F18:  BNZ   5F20
5F1A:  MOVF   xE1,W
5F1C:  SUBWF  x81,W
5F1E:  BC    5F62
....................                         MyTCB.MySEQ -= (LONG)(SHORT)(MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart); 
5F20:  MOVF   xD9,W
5F22:  SUBWF  xDB,W
5F24:  MOVWF  00
5F26:  MOVF   xDA,W
5F28:  SUBWFB xDC,W
5F2A:  MOVWF  03
5F2C:  MOVF   00,W
5F2E:  MOVFF  03,01
5F32:  CLRF   02
5F34:  CLRF   03
5F36:  BTFSS  01.7
5F38:  BRA    5F3E
5F3A:  DECF   02,F
5F3C:  DECF   03,F
5F3E:  MOVF   00,W
5F40:  SUBWF  x79,W
5F42:  MOVWF  00
5F44:  MOVF   01,W
5F46:  SUBWFB x7A,W
5F48:  MOVWF  01
5F4A:  MOVF   02,W
5F4C:  SUBWFB x7B,W
5F4E:  MOVWF  02
5F50:  MOVF   03,W
5F52:  SUBWFB x7C,W
5F54:  MOVWF  x7C
5F56:  MOVFF  02,17B
5F5A:  MOVFF  01,17A
5F5E:  MOVFF  00,179
....................                      MyTCB.txUnackedTail = MyTCBStub.txTail; 
5F62:  MOVFF  1E2,182
5F66:  MOVFF  1E1,181
....................                      MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1; 
5F6A:  BSF    xF1.2
....................                   } 
....................                   MyTCB.flags.bRXNoneACKed2 = 1; 
5F6C:  BSF    x97.4
....................                } 
....................                MyTCB.flags.bRXNoneACKed1 = 1; 
5F6E:  BSF    x97.3
....................             } 
....................          } 
....................  
....................          // No need to keep our retransmit timer going if we have nothing that needs ACKing anymore 
....................          if(MyTCBStub.txTail == MyTCBStub.txHead) 
5F70:  MOVF   xDF,W
5F72:  SUBWF  xE1,W
5F74:  BNZ   5FE2
5F76:  MOVF   xE0,W
5F78:  SUBWF  xE2,W
5F7A:  BNZ   5FE2
....................          { 
....................             // Make sure there isn't a "FIN byte in our TX FIFO" 
....................             if(MyTCBStub.Flags.bTXFIN == 0u) 
5F7C:  BTFSC  xF1.3
5F7E:  BRA    5FB2
....................             { 
....................                // Convert retransmission timer to keep-alive timer 
....................                #if defined(TCP_KEEP_ALIVE_TIMEOUT) 
....................                   MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
5F80:  MOVLB  0
5F82:  CALL   2692
5F86:  MOVLW  32
5F88:  MOVLB  3
5F8A:  ADDWF  00,W
5F8C:  MOVLB  1
5F8E:  MOVWF  xE7
5F90:  MOVLW  31
5F92:  MOVLB  3
5F94:  ADDWFC 01,W
5F96:  MOVLB  1
5F98:  MOVWF  xE8
5F9A:  MOVLW  01
5F9C:  MOVLB  3
5F9E:  ADDWFC 02,W
5FA0:  MOVLB  1
5FA2:  MOVWF  xE9
5FA4:  MOVLW  00
5FA6:  MOVLB  3
5FA8:  ADDWFC 03,W
5FAA:  MOVLB  1
5FAC:  MOVWF  xEA
....................                #endif 
....................                MyTCBStub.Flags.bTimerEnabled = 0; 
5FAE:  BCF    xF0.4
....................             } 
5FB0:  BRA    5FE2
....................             else 
....................             { 
....................                // "Throw away" FIN byte from our TX FIFO if it has been ACKed 
....................                if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
5FB2:  MOVLB  3
5FB4:  MOVF   xD9,W
5FB6:  MOVLB  1
5FB8:  SUBWF  x79,W
5FBA:  BNZ   5FE2
5FBC:  MOVLB  3
5FBE:  MOVF   xDA,W
5FC0:  MOVLB  1
5FC2:  SUBWF  x7A,W
5FC4:  BNZ   5FE2
5FC6:  MOVLB  3
5FC8:  MOVF   xDB,W
5FCA:  MOVLB  1
5FCC:  SUBWF  x7B,W
5FCE:  BNZ   5FE2
5FD0:  MOVLB  3
5FD2:  MOVF   xDC,W
5FD4:  MOVLB  1
5FD6:  SUBWF  x7C,W
5FD8:  BNZ   5FE2
5FDA:  BTFSS  x97.0
5FDC:  BRA    5FE2
....................                { 
....................                   MyTCBStub.Flags.bTimerEnabled = 0; 
5FDE:  BCF    xF0.4
....................                   MyTCBStub.Flags.bTXFIN = 0; 
5FE0:  BCF    xF1.3
....................                } 
....................             } 
....................          } 
....................  
....................          // The window size advirtised in this packet is adjusted to account  
....................          // for any bytes that we have transmitted but haven't been ACKed yet  
....................          // by this segment. 
....................          wNewWindow = h->Window - ((WORD)(MyTCB.MySEQ - localAckNumber)); 
5FE2:  MOVLW  0E
5FE4:  MOVLB  3
5FE6:  ADDWF  xC6,W
5FE8:  MOVWF  FE9
5FEA:  MOVLW  00
5FEC:  ADDWFC xC7,W
5FEE:  MOVWF  FEA
5FF0:  MOVFF  FEC,3E7
5FF4:  MOVF   FED,F
5FF6:  MOVFF  FEF,3E6
5FFA:  MOVF   xD9,W
5FFC:  MOVLB  1
5FFE:  SUBWF  x79,W
6000:  MOVWF  00
6002:  MOVLB  3
6004:  MOVF   xDA,W
6006:  MOVLB  1
6008:  SUBWFB x7A,W
600A:  MOVWF  01
600C:  MOVLB  3
600E:  MOVF   xDB,W
6010:  MOVLB  1
6012:  SUBWFB x7B,W
6014:  MOVLB  3
6016:  MOVF   xDC,W
6018:  MOVLB  1
601A:  SUBWFB x7C,W
601C:  MOVF   00,W
601E:  MOVLB  3
6020:  SUBWF  xE6,W
6022:  MOVWF  xE4
6024:  MOVF   01,W
6026:  SUBWFB xE7,W
6028:  MOVWF  xE5
....................  
....................          // Update the local stored copy of the RemoteWindow. 
....................          // If previously we had a zero window, and now we don't, then  
....................          // immediately send whatever was pending. 
....................          if((MyTCB.remoteWindow == 0u) && wNewWindow) 
602A:  MOVLB  1
602C:  MOVF   x87,F
602E:  BNZ   6046
6030:  MOVF   x88,F
6032:  BNZ   6046
6034:  MOVLB  3
6036:  MOVF   xE4,W
6038:  IORWF  xE5,W
603A:  BTFSS  FD8.2
603C:  BRA    6042
603E:  MOVLB  1
6040:  BRA    6046
....................             MyTCBStub.Flags.bTXASAP = 1; 
6042:  MOVLB  1
6044:  BSF    xF1.1
....................          MyTCB.remoteWindow = wNewWindow; 
6046:  MOVFF  3E5,188
604A:  MOVFF  3E4,187
....................  
....................          // A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more 
....................          if(MyTCBStub.smState == TCP_FIN_WAIT_1) 
604E:  MOVF   xEF,W
6050:  SUBLW  08
6052:  BNZ   60B6
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent) 
6054:  MOVLB  3
6056:  MOVF   xD9,W
6058:  MOVLB  1
605A:  SUBWF  x79,W
605C:  BNZ   60B4
605E:  MOVLB  3
6060:  MOVF   xDA,W
6062:  MOVLB  1
6064:  SUBWF  x7A,W
6066:  BNZ   60B4
6068:  MOVLB  3
606A:  MOVF   xDB,W
606C:  MOVLB  1
606E:  SUBWF  x7B,W
6070:  BNZ   60B4
6072:  MOVLB  3
6074:  MOVF   xDC,W
6076:  MOVLB  1
6078:  SUBWF  x7C,W
607A:  BNZ   60B4
607C:  BTFSS  x97.0
607E:  BRA    60B4
....................             { 
....................                // Reset our timer for forced closure if the remote node  
....................                // doesn't send us a FIN in a timely manner. 
....................                MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT; 
6080:  MOVLB  0
6082:  CALL   2692
6086:  MOVLW  99
6088:  MOVLB  3
608A:  ADDWF  00,W
608C:  MOVLB  1
608E:  MOVWF  xE7
6090:  MOVLW  98
6092:  MOVLB  3
6094:  ADDWFC 01,W
6096:  MOVLB  1
6098:  MOVWF  xE8
609A:  MOVLW  00
609C:  MOVLB  3
609E:  ADDWFC 02,W
60A0:  MOVLB  1
60A2:  MOVWF  xE9
60A4:  MOVLW  00
60A6:  MOVLB  3
60A8:  ADDWFC 03,W
60AA:  MOVLB  1
60AC:  MOVWF  xEA
....................                MyTCBStub.Flags.bTimerEnabled = 1; 
60AE:  BSF    xF0.4
....................                MyTCBStub.smState = TCP_FIN_WAIT_2; 
60B0:  MOVLW  09
60B2:  MOVWF  xEF
....................             } 
....................          } 
60B4:  BRA    6128
....................          else if(MyTCBStub.smState == TCP_FIN_WAIT_2) 
60B6:  MOVF   xEF,W
60B8:  SUBLW  09
60BA:  BNZ   60EC
....................          { 
....................             // RFC noncompliance: 
....................             // The remote node should not keep sending us data  
....................             // indefinitely after we send a FIN to it.   
....................             // However, some bad stacks may still keep sending  
....................             // us data indefinitely after ACKing our FIN.  To  
....................             // prevent this from locking up our socket, let's  
....................             // send a RST right now and close forcefully on  
....................             // our side. 
....................             if(!(localHeaderFlags & FIN)) 
60BC:  MOVLB  3
60BE:  BTFSC  xD8.0
60C0:  BRA    60E8
....................             { 
....................                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK 
60C2:  MOVFF  3DC,17C
60C6:  MOVFF  3DB,17B
60CA:  MOVFF  3DA,17A
60CE:  MOVFF  3D9,179
....................                SendTCP(RST | ACK, 0); 
60D2:  MOVLW  14
60D4:  MOVWF  xE6
60D6:  CLRF   xE7
60D8:  MOVLB  0
60DA:  CALL   3870
....................                CloseSocket(); 
60DE:  CALL   10E4
....................                return; 
60E2:  GOTO   6888
60E6:  MOVLB  3
....................             } 
....................          } 
60E8:  BRA    612A
60EA:  MOVLB  1
....................          else if(MyTCBStub.smState == TCP_CLOSING) 
60EC:  MOVF   xEF,W
60EE:  SUBLW  0A
60F0:  BNZ   6128
....................          { 
....................             // Check to see if our FIN has been ACKnowledged 
....................             if(MyTCB.MySEQ == localAckNumber) 
60F2:  MOVLB  3
60F4:  MOVF   xD9,W
60F6:  MOVLB  1
60F8:  SUBWF  x79,W
60FA:  BNZ   6122
60FC:  MOVLB  3
60FE:  MOVF   xDA,W
6100:  MOVLB  1
6102:  SUBWF  x7A,W
6104:  BNZ   6122
6106:  MOVLB  3
6108:  MOVF   xDB,W
610A:  MOVLB  1
610C:  SUBWF  x7B,W
610E:  BNZ   6122
6110:  MOVLB  3
6112:  MOVF   xDC,W
6114:  MOVLB  1
6116:  SUBWF  x7C,W
6118:  BNZ   6122
....................             { 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                CloseSocket(); 
611A:  MOVLB  0
611C:  CALL   10E4
6120:  MOVLB  1
....................             } 
....................  
....................             return; 
6122:  MOVLB  0
6124:  GOTO   6888
6128:  MOVLB  3
....................          } 
....................  
....................          break; 
612A:  BRA    617C
....................  
....................       case TCP_LAST_ACK: 
....................          // Check to see if our FIN has been ACKnowledged 
....................          if(MyTCB.MySEQ + 1 == localAckNumber) 
612C:  MOVLW  01
612E:  MOVLB  1
6130:  ADDWF  x79,W
6132:  MOVLB  3
6134:  MOVWF  xE6
6136:  MOVLW  00
6138:  MOVLB  1
613A:  ADDWFC x7A,W
613C:  MOVLB  3
613E:  MOVWF  xE7
6140:  MOVLW  00
6142:  MOVLB  1
6144:  ADDWFC x7B,W
6146:  MOVLB  3
6148:  MOVWF  xE8
614A:  MOVLW  00
614C:  MOVLB  1
614E:  ADDWFC x7C,W
6150:  MOVLB  3
6152:  MOVWF  xE9
6154:  MOVF   xD9,W
6156:  SUBWF  xE6,W
6158:  BNZ   6174
615A:  MOVF   xDA,W
615C:  SUBWF  xE7,W
615E:  BNZ   6174
6160:  MOVF   xDB,W
6162:  SUBWF  xE8,W
6164:  BNZ   6174
6166:  MOVF   xDC,W
6168:  SUBWF  xE9,W
616A:  BNZ   6174
....................             CloseSocket(); 
616C:  MOVLB  0
616E:  CALL   10E4
6172:  MOVLB  3
....................          return; 
6174:  MOVLB  0
6176:  GOTO   6888
....................  
.................... //      case TCP_TIME_WAIT: 
.................... //         // Nothing is supposed to arrive here.  If it does, reset the quiet timer. 
.................... //         SendTCP(ACK, SENDTCP_RESET_TIMERS); 
.................... //         return; 
....................  
....................       default: 
....................          break; 
617A:  MOVLB  3
....................    } 
....................  
....................    // 
....................    // Sixth: Check the URG bit 
....................    // 
....................    // Urgent packets are not supported in this stack, so we 
....................    // will throw them away instead 
....................    if(localHeaderFlags & URG) 
617C:  BTFSS  xD8.5
617E:  BRA    6188
....................       return; 
6180:  MOVLB  0
6182:  GOTO   6888
6186:  MOVLB  3
....................  
....................    // 
....................    // Seventh: Process the segment text 
....................    // 
....................    // Throw data away if in a state that doesn't accept data 
....................    if(MyTCBStub.smState == TCP_CLOSE_WAIT) 
6188:  MOVLB  1
618A:  MOVF   xEF,W
618C:  SUBLW  0B
618E:  BNZ   6196
....................       return; 
6190:  MOVLB  0
6192:  BRA    6888
6194:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_CLOSING) 
6196:  MOVF   xEF,W
6198:  SUBLW  0A
619A:  BNZ   61A2
....................       return; 
619C:  MOVLB  0
619E:  BRA    6888
61A0:  MOVLB  1
....................    if(MyTCBStub.smState == TCP_LAST_ACK) 
61A2:  MOVF   xEF,W
61A4:  SUBLW  0C
61A6:  BNZ   61AE
....................       return; 
61A8:  MOVLB  0
61AA:  BRA    6888
61AC:  MOVLB  1
.................... //   if(MyTCBStub.smState == TCP_TIME_WAIT) 
.................... //      return; 
....................  
....................    // Copy any valid segment data into our RX FIFO, if any 
....................    if(len) 
61AE:  MOVLB  3
61B0:  MOVF   xC8,W
61B2:  IORWF  xC9,W
61B4:  BTFSC  FD8.2
61B6:  BRA    66F6
....................    { 
....................       // See if there are bytes we must skip 
....................       if((SHORT)wMissingBytes <= 0) 
61B8:  BTFSC  xD5.7
61BA:  BRA    61CA
61BC:  MOVF   xD5,F
61BE:  BTFSS  FD8.2
61C0:  BRA    63DC
61C2:  MOVF   xD4,W
61C4:  SUBLW  00
61C6:  BTFSS  FD8.0
61C8:  BRA    63DC
....................       { 
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes); 
61CA:  MOVLW  0C
61CC:  ADDWF  xC6,W
61CE:  MOVWF  FE9
61D0:  MOVLW  00
61D2:  ADDWFC xC7,W
61D4:  MOVWF  FEA
61D6:  MOVFF  FEF,00
61DA:  SWAPF  00,W
61DC:  ANDLW  0F
61DE:  MOVWF  00
61E0:  RLCF   00,F
61E2:  RLCF   00,F
61E4:  MOVLW  FC
61E6:  ANDWF  00,F
61E8:  MOVF   00,W
61EA:  BSF    FD8.0
61EC:  SUBFWB xD4,W
61EE:  MOVWF  xE6
61F0:  MOVLW  00
61F2:  SUBFWB xD5,W
61F4:  MOVWF  xE7
61F6:  MOVWF  xEB
61F8:  MOVFF  3E6,3EA
61FC:  MOVLB  0
61FE:  CALL   2712
....................          len += wMissingBytes;       
6202:  MOVLB  3
6204:  MOVF   xD4,W
6206:  ADDWF  xC8,F
6208:  MOVF   xD5,W
620A:  ADDWFC xC9,F
....................     
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          // and request a retransmit by sending a duplicate ACK 
....................          if(len > wFreeSpace) 
620C:  MOVF   xD7,W
620E:  SUBWF  xC9,W
6210:  BNC   6222
6212:  BNZ   621A
6214:  MOVF   xC8,W
6216:  SUBWF  xD6,W
6218:  BC    6222
....................             len = wFreeSpace; 
621A:  MOVFF  3D7,3C9
621E:  MOVFF  3D6,3C8
....................     
....................          MyTCB.RemoteSEQ += (DWORD)len; 
6222:  MOVFF  3C9,01
6226:  CLRF   02
6228:  CLRF   03
622A:  MOVF   xC8,W
622C:  MOVLB  1
622E:  ADDWF  x7D,F
6230:  MOVF   01,W
6232:  ADDWFC x7E,F
6234:  MOVF   02,W
6236:  ADDWFC x7F,F
6238:  MOVF   03,W
623A:  ADDWFC x80,F
....................        
....................          // Copy the application data from the packet into the socket RX FIFO 
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd) 
623C:  MOVLB  3
623E:  MOVF   xC8,W
6240:  MOVLB  1
6242:  ADDWF  xE3,W
6244:  MOVLB  3
6246:  MOVWF  xE6
6248:  MOVF   xC9,W
624A:  MOVLB  1
624C:  ADDWFC xE4,W
624E:  MOVLB  3
6250:  MOVWF  xE7
6252:  MOVLB  1
6254:  MOVF   xDE,W
6256:  MOVLB  3
6258:  SUBWF  xE7,W
625A:  BNC   62FE
625C:  BNZ   626E
625E:  MOVF   xE6,W
6260:  MOVLB  1
6262:  SUBWF  xDD,W
6264:  BTFSS  FD8.0
6266:  BRA    626C
6268:  MOVLB  3
626A:  BRA    62FE
626C:  MOVLB  3
....................          { 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1; 
626E:  MOVLB  1
6270:  MOVF   xE3,W
6272:  SUBWF  xDD,W
6274:  MOVLB  3
6276:  MOVWF  xE6
6278:  MOVLB  1
627A:  MOVF   xE4,W
627C:  SUBWFB xDE,W
627E:  MOVLB  3
6280:  MOVWF  xE7
6282:  MOVLW  01
6284:  ADDWF  xE6,W
6286:  MOVWF  xCE
6288:  MOVLW  00
628A:  ADDWFC xE7,W
628C:  MOVWF  xCF
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
628E:  MOVFF  1E4,418
6292:  MOVFF  1E3,417
6296:  MOVFF  1F4,419
629A:  MOVLB  4
629C:  SETF   x1B
629E:  SETF   x1A
62A0:  CLRF   x1C
62A2:  MOVFF  3CF,41E
62A6:  MOVFF  3CE,41D
62AA:  MOVLB  0
62AC:  CALL   0F26
....................             TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
62B0:  MOVLB  3
62B2:  MOVF   xCE,W
62B4:  SUBWF  xC8,W
62B6:  MOVWF  xE6
62B8:  MOVF   xCF,W
62BA:  SUBWFB xC9,W
62BC:  MOVWF  xE7
62BE:  MOVFF  1DC,418
62C2:  MOVFF  1DB,417
62C6:  MOVFF  1F4,419
62CA:  MOVLB  4
62CC:  SETF   x1B
62CE:  SETF   x1A
62D0:  CLRF   x1C
62D2:  MOVWF  x1E
62D4:  MOVFF  3E6,41D
62D8:  MOVLB  0
62DA:  CALL   0F26
....................             MyTCBStub.rxHead = MyTCBStub.bufferRxStart + (len - wTemp); 
62DE:  MOVLB  3
62E0:  MOVF   xCE,W
62E2:  SUBWF  xC8,W
62E4:  MOVWF  00
62E6:  MOVF   xCF,W
62E8:  SUBWFB xC9,W
62EA:  MOVWF  03
62EC:  MOVF   00,W
62EE:  MOVLB  1
62F0:  ADDWF  xDB,W
62F2:  MOVWF  xE3
62F4:  MOVF   03,W
62F6:  ADDWFC xDC,W
62F8:  MOVWF  xE4
....................          } 
62FA:  BRA    6330
62FC:  MOVLB  3
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
62FE:  MOVFF  1E4,418
6302:  MOVFF  1E3,417
6306:  MOVFF  1F4,419
630A:  MOVLB  4
630C:  SETF   x1B
630E:  SETF   x1A
6310:  CLRF   x1C
6312:  MOVFF  3C9,41E
6316:  MOVFF  3C8,41D
631A:  MOVLB  0
631C:  CALL   0F26
....................             MyTCBStub.rxHead += len; 
6320:  MOVLB  3
6322:  MOVF   xC8,W
6324:  MOVLB  1
6326:  ADDWF  xE3,F
6328:  MOVLB  3
632A:  MOVF   xC9,W
632C:  MOVLB  1
632E:  ADDWFC xE4,F
....................          } 
....................        
....................          // See if we have a hole and other data waiting already in the RX FIFO 
....................          if(MyTCB.sHoleSize != -1) 
6330:  INCFSZ x95,W
6332:  BRA    633A
6334:  INCFSZ x96,W
6336:  BRA    633A
6338:  BRA    63D8
....................          { 
....................             MyTCB.sHoleSize -= len; 
633A:  MOVLB  3
633C:  MOVF   xC8,W
633E:  MOVLB  1
6340:  SUBWF  x95,F
6342:  MOVLB  3
6344:  MOVF   xC9,W
6346:  MOVLB  1
6348:  SUBWFB x96,F
....................             wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize; 
634A:  MOVF   x95,W
634C:  ADDWF  x89,W
634E:  MOVWF  01
6350:  MOVF   x96,W
6352:  ADDWFC x8A,W
6354:  MOVFF  01,3CE
6358:  MOVLB  3
635A:  MOVWF  xCF
....................        
....................             // See if we just closed up a hole, and if so, advance head pointer 
....................             if((SHORT)wTemp < (SHORT)0) 
635C:  BTFSS  xCF.7
635E:  BRA    6368
....................             { 
....................                MyTCB.sHoleSize = -1; 
6360:  MOVLB  1
6362:  SETF   x96
6364:  SETF   x95
....................             } 
6366:  BRA    63D8
....................             else if(MyTCB.sHoleSize <= 0) 
6368:  MOVLB  1
636A:  BTFSC  x96.7
636C:  BRA    6378
636E:  MOVF   x96,F
6370:  BNZ   63D8
6372:  MOVF   x95,W
6374:  SUBLW  00
6376:  BNC   63D8
....................             { 
....................                MyTCB.RemoteSEQ += wTemp; 
6378:  MOVLB  3
637A:  MOVF   xCE,W
637C:  MOVLB  1
637E:  ADDWF  x7D,F
6380:  MOVLB  3
6382:  MOVF   xCF,W
6384:  MOVLB  1
6386:  ADDWFC x7E,F
6388:  MOVLW  00
638A:  ADDWFC x7F,F
638C:  ADDWFC x80,F
....................                MyTCBStub.rxHead += wTemp; 
638E:  MOVLB  3
6390:  MOVF   xCE,W
6392:  MOVLB  1
6394:  ADDWF  xE3,F
6396:  MOVLB  3
6398:  MOVF   xCF,W
639A:  MOVLB  1
639C:  ADDWFC xE4,F
....................                if(MyTCBStub.rxHead > MyTCBStub.bufferEnd) 
639E:  MOVF   xDE,W
63A0:  SUBWF  xE4,W
63A2:  BNC   63D4
63A4:  BNZ   63AC
63A6:  MOVF   xE3,W
63A8:  SUBWF  xDD,W
63AA:  BC    63D4
....................                   MyTCBStub.rxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;                      
63AC:  MOVF   xDB,W
63AE:  SUBWF  xDD,W
63B0:  MOVLB  3
63B2:  MOVWF  xE6
63B4:  MOVLB  1
63B6:  MOVF   xDC,W
63B8:  SUBWFB xDE,W
63BA:  MOVLB  3
63BC:  MOVWF  xE7
63BE:  MOVLW  01
63C0:  ADDWF  xE6,W
63C2:  MOVWF  01
63C4:  MOVLW  00
63C6:  ADDWFC xE7,W
63C8:  MOVWF  03
63CA:  MOVF   01,W
63CC:  MOVLB  1
63CE:  SUBWF  xE3,F
63D0:  MOVF   03,W
63D2:  SUBWFB xE4,F
....................                MyTCB.sHoleSize = -1; 
63D4:  SETF   x96
63D6:  SETF   x95
....................             } 
....................          } 
....................       } // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it 
63D8:  BRA    66F4
63DA:  MOVLB  3
....................       else if((SHORT)wMissingBytes > 0) 
63DC:  BTFSC  xD5.7
63DE:  BRA    66F6
63E0:  MOVF   xD5,F
63E2:  BNZ   63EC
63E4:  MOVF   xD4,W
63E6:  SUBLW  00
63E8:  BTFSC  FD8.0
63EA:  BRA    66F6
....................       { 
....................          // Truncate packets that would overflow our TCP RX FIFO 
....................          if(len + wMissingBytes > wFreeSpace) 
63EC:  MOVF   xD4,W
63EE:  ADDWF  xC8,W
63F0:  MOVWF  xE6
63F2:  MOVF   xD5,W
63F4:  ADDWFC xC9,W
63F6:  MOVWF  xE7
63F8:  MOVF   xD7,W
63FA:  SUBWF  xE7,W
63FC:  BNC   6412
63FE:  BNZ   6406
6400:  MOVF   xE6,W
6402:  SUBWF  xD6,W
6404:  BC    6412
....................             len = wFreeSpace - wMissingBytes; 
6406:  MOVF   xD4,W
6408:  SUBWF  xD6,W
640A:  MOVWF  xC8
640C:  MOVF   xD5,W
640E:  SUBWFB xD7,W
6410:  MOVWF  xC9
....................        
....................          // Position packet read pointer to start of useful data area. 
....................          IPSetRxBuffer(h->DataOffset.Val << 2); 
6412:  MOVLW  0C
6414:  ADDWF  xC6,W
6416:  MOVWF  FE9
6418:  MOVLW  00
641A:  ADDWFC xC7,W
641C:  MOVWF  FEA
641E:  MOVFF  FEF,00
6422:  SWAPF  00,W
6424:  ANDLW  0F
6426:  MOVWF  00
6428:  RLCF   00,W
642A:  MOVWF  xE6
642C:  RLCF   xE6,F
642E:  MOVLW  FC
6430:  ANDWF  xE6,F
6432:  CLRF   xEB
6434:  MOVFF  3E6,3EA
6438:  MOVLB  0
643A:  CALL   2712
....................     
....................          // See if we need a two part copy (spans bufferEnd->bufferRxStart) 
....................          if(MyTCBStub.rxHead + wMissingBytes + len > MyTCBStub.bufferEnd) 
643E:  MOVLB  3
6440:  MOVF   xD4,W
6442:  MOVLB  1
6444:  ADDWF  xE3,W
6446:  MOVLB  3
6448:  MOVWF  xE6
644A:  MOVF   xD5,W
644C:  MOVLB  1
644E:  ADDWFC xE4,W
6450:  MOVLB  3
6452:  MOVWF  xE7
6454:  MOVF   xC8,W
6456:  ADDWF  xE6,F
6458:  MOVF   xC9,W
645A:  ADDWFC xE7,F
645C:  MOVLB  1
645E:  MOVF   xDE,W
6460:  MOVLB  3
6462:  SUBWF  xE7,W
6464:  BTFSS  FD8.0
6466:  BRA    6570
6468:  BNZ   647A
646A:  MOVF   xE6,W
646C:  MOVLB  1
646E:  SUBWF  xDD,W
6470:  BTFSS  FD8.0
6472:  BRA    6478
6474:  MOVLB  3
6476:  BRA    6570
6478:  MOVLB  3
....................          { 
....................             // Calculate number of data bytes to copy before wraparound 
....................             wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1 - wMissingBytes; 
647A:  MOVLB  1
647C:  MOVF   xE3,W
647E:  SUBWF  xDD,W
6480:  MOVLB  3
6482:  MOVWF  xE6
6484:  MOVLB  1
6486:  MOVF   xE4,W
6488:  SUBWFB xDE,W
648A:  MOVLB  3
648C:  MOVWF  xE7
648E:  MOVLW  01
6490:  ADDWF  xE6,F
6492:  MOVLW  00
6494:  ADDWFC xE7,F
6496:  MOVF   xD4,W
6498:  SUBWF  xE6,W
649A:  MOVWF  xCE
649C:  MOVF   xD5,W
649E:  SUBWFB xE7,W
64A0:  MOVWF  xCF
....................             if((SHORT)wTemp >= 0) 
64A2:  BTFSC  xCF.7
64A4:  BRA    650E
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp); 
64A6:  MOVF   xD4,W
64A8:  MOVLB  1
64AA:  ADDWF  xE3,W
64AC:  MOVLB  3
64AE:  MOVWF  xE6
64B0:  MOVF   xD5,W
64B2:  MOVLB  1
64B4:  ADDWFC xE4,W
64B6:  MOVLB  3
64B8:  MOVWF  xE7
64BA:  MOVFF  FE8,418
64BE:  MOVFF  3E6,417
64C2:  MOVFF  1F4,419
64C6:  MOVLB  4
64C8:  SETF   x1B
64CA:  SETF   x1A
64CC:  CLRF   x1C
64CE:  MOVFF  3CF,41E
64D2:  MOVFF  3CE,41D
64D6:  MOVLB  0
64D8:  CALL   0F26
....................                TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp); 
64DC:  MOVLB  3
64DE:  MOVF   xCE,W
64E0:  SUBWF  xC8,W
64E2:  MOVWF  xE6
64E4:  MOVF   xCF,W
64E6:  SUBWFB xC9,W
64E8:  MOVWF  xE7
64EA:  MOVFF  1DC,418
64EE:  MOVFF  1DB,417
64F2:  MOVFF  1F4,419
64F6:  MOVLB  4
64F8:  SETF   x1B
64FA:  SETF   x1A
64FC:  CLRF   x1C
64FE:  MOVWF  x1E
6500:  MOVFF  3E6,41D
6504:  MOVLB  0
6506:  CALL   0F26
....................             } 
650A:  BRA    656C
650C:  MOVLB  3
....................             else 
....................             { 
....................                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes - (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1), MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
650E:  MOVF   xD4,W
6510:  MOVLB  1
6512:  ADDWF  xE3,W
6514:  MOVLB  3
6516:  MOVWF  xE6
6518:  MOVF   xD5,W
651A:  MOVLB  1
651C:  ADDWFC xE4,W
651E:  MOVLB  3
6520:  MOVWF  xE7
6522:  MOVLB  1
6524:  MOVF   xDB,W
6526:  SUBWF  xDD,W
6528:  MOVLB  3
652A:  MOVWF  xE8
652C:  MOVLB  1
652E:  MOVF   xDC,W
6530:  SUBWFB xDE,W
6532:  MOVLB  3
6534:  MOVWF  xE9
6536:  MOVLW  01
6538:  ADDWF  xE8,W
653A:  MOVWF  01
653C:  MOVLW  00
653E:  ADDWFC xE9,W
6540:  MOVWF  03
6542:  MOVF   01,W
6544:  SUBWF  xE6,F
6546:  MOVF   03,W
6548:  SUBWFB xE7,F
654A:  MOVFF  3E7,418
654E:  MOVFF  3E6,417
6552:  MOVFF  1F4,419
6556:  MOVLB  4
6558:  SETF   x1B
655A:  SETF   x1A
655C:  CLRF   x1C
655E:  MOVFF  3C9,41E
6562:  MOVFF  3C8,41D
6566:  MOVLB  0
6568:  CALL   0F26
....................             } 
....................          } 
656C:  BRA    65A6
656E:  MOVLB  3
....................          else 
....................          { 
....................             TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len); 
6570:  MOVF   xD4,W
6572:  MOVLB  1
6574:  ADDWF  xE3,W
6576:  MOVLB  3
6578:  MOVWF  xE6
657A:  MOVF   xD5,W
657C:  MOVLB  1
657E:  ADDWFC xE4,W
6580:  MOVLB  3
6582:  MOVWF  xE7
6584:  MOVFF  FE8,418
6588:  MOVFF  3E6,417
658C:  MOVFF  1F4,419
6590:  MOVLB  4
6592:  SETF   x1B
6594:  SETF   x1A
6596:  CLRF   x1C
6598:  MOVFF  3C9,41E
659C:  MOVFF  3C8,41D
65A0:  MOVLB  0
65A2:  CALL   0F26
....................          } 
....................        
....................          // Record the hole is here 
....................          if(MyTCB.sHoleSize == -1) 
65A6:  MOVLB  1
65A8:  INCFSZ x95,W
65AA:  BRA    65C2
65AC:  INCFSZ x96,W
65AE:  BRA    65C2
....................          { 
....................             MyTCB.sHoleSize = wMissingBytes; 
65B0:  MOVFF  3D5,196
65B4:  MOVFF  3D4,195
....................             MyTCB.wFutureDataSize = len; 
65B8:  MOVFF  3C9,18A
65BC:  MOVFF  3C8,189
....................          } 
65C0:  BRA    66F4
....................          else 
....................          { 
....................             // We already have a hole, see if we can shrink the hole  
....................             // or extend the future data size 
....................             if(wMissingBytes < (WORD)MyTCB.sHoleSize) 
65C2:  MOVLB  3
65C4:  MOVF   xD5,W
65C6:  MOVLB  1
65C8:  SUBWF  x96,W
65CA:  BNC   666E
65CC:  BNZ   65DE
65CE:  MOVF   x95,W
65D0:  MOVLB  3
65D2:  SUBWF  xD4,W
65D4:  BTFSS  FD8.0
65D6:  BRA    65DC
65D8:  MOVLB  1
65DA:  BRA    666E
65DC:  MOVLB  1
....................             { 
....................                if((wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) || (wMissingBytes + len < (WORD)MyTCB.sHoleSize)) 
65DE:  MOVLB  3
65E0:  MOVF   xC8,W
65E2:  ADDWF  xD4,W
65E4:  MOVWF  xE6
65E6:  MOVF   xC9,W
65E8:  ADDWFC xD5,W
65EA:  MOVWF  xE7
65EC:  MOVLB  1
65EE:  MOVF   x89,W
65F0:  ADDWF  x95,W
65F2:  MOVWF  01
65F4:  MOVF   x8A,W
65F6:  ADDWFC x96,W
65F8:  MOVWF  03
65FA:  MOVF   03,W
65FC:  MOVLB  3
65FE:  SUBWF  xE7,W
6600:  BNC   660A
6602:  BNZ   6632
6604:  MOVF   xE6,W
6606:  SUBWF  01,W
6608:  BNC   6632
660A:  MOVF   xC8,W
660C:  ADDWF  xD4,W
660E:  MOVWF  xE6
6610:  MOVF   xC9,W
6612:  ADDWFC xD5,W
6614:  MOVWF  xE7
6616:  MOVLB  1
6618:  SUBWF  x96,W
661A:  BNC   663E
661C:  BTFSC  FD8.2
661E:  BRA    6624
6620:  MOVLB  3
6622:  BRA    6632
6624:  MOVF   x95,W
6626:  MOVLB  3
6628:  SUBWF  xE6,W
662A:  BTFSS  FD8.0
662C:  BRA    6632
662E:  MOVLB  1
6630:  BRA    663E
....................                   MyTCB.wFutureDataSize = len; 
6632:  MOVFF  3C9,18A
6636:  MOVFF  3C8,189
663A:  BRA    6664
663C:  MOVLB  1
....................                else 
....................                   MyTCB.wFutureDataSize = (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes; 
663E:  MOVF   x89,W
6640:  ADDWF  x95,W
6642:  MOVLB  3
6644:  MOVWF  xE6
6646:  MOVLB  1
6648:  MOVF   x8A,W
664A:  ADDWFC x96,W
664C:  MOVLB  3
664E:  MOVWF  xE7
6650:  MOVF   xD4,W
6652:  SUBWF  xE6,W
6654:  MOVLB  1
6656:  MOVWF  x89
6658:  MOVLB  3
665A:  MOVF   xD5,W
665C:  SUBWFB xE7,W
665E:  MOVLB  1
6660:  MOVWF  x8A
6662:  MOVLB  3
....................                MyTCB.sHoleSize = wMissingBytes; 
6664:  MOVFF  3D5,196
6668:  MOVFF  3D4,195
....................             } 
666C:  BRA    66F6
....................             else if(wMissingBytes + len > (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
666E:  MOVLB  3
6670:  MOVF   xC8,W
6672:  ADDWF  xD4,W
6674:  MOVWF  xE6
6676:  MOVF   xC9,W
6678:  ADDWFC xD5,W
667A:  MOVWF  xE7
667C:  MOVLB  1
667E:  MOVF   x89,W
6680:  ADDWF  x95,W
6682:  MOVWF  01
6684:  MOVF   x8A,W
6686:  ADDWFC x96,W
6688:  MOVWF  03
668A:  MOVF   03,W
668C:  MOVLB  3
668E:  SUBWF  xE7,W
6690:  BNC   66F6
6692:  BNZ   669A
6694:  MOVF   xE6,W
6696:  SUBWF  01,W
6698:  BC    66F6
....................             { 
....................                // Make sure that there isn't a second hole between  
....................                // our future data and this TCP segment's future data 
....................                if(wMissingBytes <= (WORD)MyTCB.sHoleSize + MyTCB.wFutureDataSize) 
669A:  MOVLB  1
669C:  MOVF   x89,W
669E:  ADDWF  x95,W
66A0:  MOVWF  01
66A2:  MOVF   x8A,W
66A4:  ADDWFC x96,W
66A6:  MOVWF  03
66A8:  MOVF   01,W
66AA:  MOVLB  3
66AC:  MOVF   xD5,W
66AE:  SUBWF  03,W
66B0:  BNC   66F6
66B2:  BNZ   66BA
66B4:  MOVF   xD4,W
66B6:  SUBWF  01,W
66B8:  BNC   66F6
....................                   MyTCB.wFutureDataSize += wMissingBytes + len - (WORD)MyTCB.sHoleSize - MyTCB.wFutureDataSize; 
66BA:  MOVF   xC8,W
66BC:  ADDWF  xD4,W
66BE:  MOVWF  xE6
66C0:  MOVF   xC9,W
66C2:  ADDWFC xD5,W
66C4:  MOVWF  xE7
66C6:  MOVLB  1
66C8:  MOVF   x95,W
66CA:  MOVLB  3
66CC:  SUBWF  xE6,F
66CE:  MOVLB  1
66D0:  MOVF   x96,W
66D2:  MOVLB  3
66D4:  SUBWFB xE7,F
66D6:  MOVLB  1
66D8:  MOVF   x89,W
66DA:  MOVLB  3
66DC:  SUBWF  xE6,W
66DE:  MOVWF  00
66E0:  MOVLB  1
66E2:  MOVF   x8A,W
66E4:  MOVLB  3
66E6:  SUBWFB xE7,W
66E8:  MOVWF  03
66EA:  MOVF   00,W
66EC:  MOVLB  1
66EE:  ADDWF  x89,F
66F0:  MOVF   03,W
66F2:  ADDWFC x8A,F
66F4:  MOVLB  3
....................             } 
....................              
....................          } 
....................       } 
....................    } 
....................  
....................    // Send back an ACK of the data (+SYN | FIN) we just received,  
....................    // if any.  To minimize bandwidth waste, we are implementing  
....................    // the delayed acknowledgement algorithm here, only sending  
....................    // back an immediate ACK if this is the second segment received.   
....................    // Otherwise, a 200ms timer will cause the ACK to be transmitted. 
....................    if(wSegmentLength) 
66F6:  MOVF   xE1,W
66F8:  IORWF  xE2,W
66FA:  BZ    674E
....................    { 
....................       // For non-established sockets, let's delete all data in  
....................       // the RX buffer immediately after receiving it.  This is  
....................       // not really how TCP was intended to operate since a  
....................       // socket cannot receive any response after it sends a FIN, 
....................       // but our TCP application API doesn't readily accomodate 
....................       // receiving data after calling TCPDisconnect(), which  
....................       // invalidates the application TCP handle.  By deleting all  
....................       // data, we'll ensure that the RX window is nonzero and  
....................       // the remote node will be able to send us a FIN response,  
....................       // which needs an RX window of at least 1. 
....................       if(MyTCBStub.smState != TCP_ESTABLISHED) 
66FC:  MOVLB  1
66FE:  MOVF   xEF,W
6700:  SUBLW  07
6702:  BZ    670C
....................          MyTCBStub.rxTail = MyTCBStub.rxHead; 
6704:  MOVFF  1E4,1E6
6708:  MOVFF  1E3,1E5
....................  
....................       if(MyTCBStub.Flags.bOneSegmentReceived) 
670C:  BTFSS  xF0.7
670E:  BRA    6728
....................       { 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
6710:  MOVLW  10
6712:  MOVLB  3
6714:  MOVWF  xE6
6716:  MOVLW  01
6718:  MOVWF  xE7
671A:  MOVLB  0
671C:  CALL   3870
....................          SyncTCB(); 
6720:  CALL   100C
....................          // bOneSegmentReceived is cleared in SendTCP(), so no need here 
....................       } 
6724:  BRA    674C
6726:  MOVLB  1
....................       else 
....................       { 
....................          MyTCBStub.Flags.bOneSegmentReceived = TRUE;    
6728:  BSF    xF0.7
....................        
....................          // Do not send an ACK immediately back.  Instead, we will  
....................          // perform delayed acknowledgements.  To do this, we will  
....................          // just start a timer 
....................          if(!MyTCBStub.Flags.bDelayedACKTimerEnabled) 
672A:  BTFSC  xF0.6
672C:  BRA    674A
....................          { 
....................             MyTCBStub.Flags.bDelayedACKTimerEnabled = 1; 
672E:  BSF    xF0.6
....................             MyTCBStub.OverlappedTimers.delayedACKTime = (WORD)TickGetDiv256() + (WORD)((TCP_DELAYED_ACK_TIMEOUT)>>8); 
6730:  MOVLB  0
6732:  CALL   322C
6736:  MOVLW  03
6738:  MOVLB  3
673A:  ADDWF  00,W
673C:  MOVLB  1
673E:  MOVWF  xED
6740:  MOVLW  00
6742:  MOVLB  3
6744:  ADDWFC 01,W
6746:  MOVLB  1
6748:  MOVWF  xEE
674A:  MOVLB  0
674C:  MOVLB  3
....................          } 
....................       } 
....................    } 
....................  
....................    // 
....................    // Eighth: check the FIN bit 
....................    // 
....................    if(localHeaderFlags & FIN) 
674E:  BTFSS  xD8.0
6750:  BRA    688A
....................    { 
....................       // Note: Since we don't have a good means of storing "FIN bytes"  
....................       // in our TCP RX FIFO, we must ensure that FINs are processed  
....................       // in-order. 
....................       if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (DWORD)wSegmentLength) 
6752:  MOVLW  01
6754:  MOVLB  1
6756:  ADDWF  x7D,W
6758:  MOVLB  3
675A:  MOVWF  xE6
675C:  MOVLW  00
675E:  MOVLB  1
6760:  ADDWFC x7E,W
6762:  MOVLB  3
6764:  MOVWF  xE7
6766:  MOVLW  00
6768:  MOVLB  1
676A:  ADDWFC x7F,W
676C:  MOVLB  3
676E:  MOVWF  xE8
6770:  MOVLW  00
6772:  MOVLB  1
6774:  ADDWFC x80,W
6776:  MOVLB  3
6778:  MOVWF  xE9
677A:  MOVFF  3E1,00
677E:  MOVFF  3E2,01
6782:  CLRF   02
6784:  CLRF   03
6786:  MOVF   xDD,W
6788:  ADDWF  00,F
678A:  MOVF   xDE,W
678C:  ADDWFC 01,F
678E:  MOVF   xDF,W
6790:  ADDWFC 02,F
6792:  MOVF   xE0,W
6794:  ADDWFC 03,F
6796:  MOVF   00,W
6798:  SUBWF  xE6,W
679A:  BTFSS  FD8.2
679C:  BRA    688A
679E:  MOVF   01,W
67A0:  SUBWF  xE7,W
67A2:  BTFSS  FD8.2
67A4:  BRA    688A
67A6:  MOVF   02,W
67A8:  SUBWF  xE8,W
67AA:  BTFSS  FD8.2
67AC:  BRA    688A
67AE:  MOVF   03,W
67B0:  SUBWF  xE9,W
67B2:  BTFSS  FD8.2
67B4:  BRA    688A
....................       { 
....................          // FINs are treated as one byte of data for ACK sequencing 
....................          MyTCB.RemoteSEQ++; 
67B6:  MOVLW  01
67B8:  MOVLB  1
67BA:  ADDWF  x7D,F
67BC:  BTFSC  FD8.0
67BE:  INCF   x7E,F
67C0:  BTFSC  FD8.2
67C2:  INCF   x7F,F
67C4:  BTFSC  FD8.2
67C6:  INCF   x80,F
....................           
....................          switch(MyTCBStub.smState) 
67C8:  MOVF   xEF,W
67CA:  XORLW  06
67CC:  MOVLB  0
67CE:  BZ    67DE
67D0:  XORLW  01
67D2:  BZ    67F6
67D4:  XORLW  0F
67D6:  BZ    6818
67D8:  XORLW  01
67DA:  BZ    6862
67DC:  BRA    6876
....................          { 
....................             case TCP_SYN_RECEIVED: 
....................                // RFC in exact: Our API has no need for the user  
....................                // to explicitly close a socket that never really  
....................                // got opened fully in the first place, so just  
....................                // transmit a FIN automatically and jump to  
....................                // TCP_LAST_ACK 
....................                MyTCBStub.smState = TCP_LAST_ACK; 
67DE:  MOVLW  0C
67E0:  MOVLB  1
67E2:  MOVWF  xEF
....................                SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS); 
67E4:  MOVLW  11
67E6:  MOVLB  3
67E8:  MOVWF  xE6
67EA:  MOVLW  01
67EC:  MOVWF  xE7
67EE:  MOVLB  0
67F0:  CALL   3870
....................                return; 
67F4:  BRA    6888
....................  
....................             case TCP_ESTABLISHED: 
....................                // Go to TCP_CLOSE_WAIT state 
....................                MyTCBStub.smState = TCP_CLOSE_WAIT; 
67F6:  MOVLW  0B
67F8:  MOVLB  1
67FA:  MOVWF  xEF
....................                 
....................                // For legacy applications that don't call  
....................                // TCPDisconnect() as needed and expect the TCP/IP  
....................                // Stack to automatically close sockets when the  
....................                // remote node sends a FIN, let's start a timer so  
....................                // that we will eventually close the socket automatically 
....................                MyTCBStub.OverlappedTimers.closeWaitTime = (WORD)TickGetDiv256() + (WORD)((TCP_CLOSE_WAIT_TIMEOUT)>>8); 
67FC:  MOVLB  0
67FE:  CALL   322C
6802:  MOVLW  06
6804:  MOVLB  3
6806:  ADDWF  00,W
6808:  MOVLB  1
680A:  MOVWF  xED
680C:  MOVLW  00
680E:  MOVLB  3
6810:  ADDWFC 01,W
6812:  MOVLB  1
6814:  MOVWF  xEE
....................                break; 
6816:  BRA    6878
....................     
....................             case TCP_FIN_WAIT_1: 
....................                if(MyTCB.MySEQ == localAckNumber) 
6818:  MOVLB  3
681A:  MOVF   xD9,W
681C:  MOVLB  1
681E:  SUBWF  x79,W
6820:  BNZ   6858
6822:  MOVLB  3
6824:  MOVF   xDA,W
6826:  MOVLB  1
6828:  SUBWF  x7A,W
682A:  BNZ   6858
682C:  MOVLB  3
682E:  MOVF   xDB,W
6830:  MOVLB  1
6832:  SUBWF  x7B,W
6834:  BNZ   6858
6836:  MOVLB  3
6838:  MOVF   xDC,W
683A:  MOVLB  1
683C:  SUBWF  x7C,W
683E:  BNZ   6858
....................                { 
....................                   // RFC not recommended: We should be going to  
....................                   // the TCP_TIME_WAIT state right here and  
....................                   // starting a 2MSL timer, but since we have so  
....................                   // few precious sockets, we can't afford to  
....................                   // leave a socket waiting around doing nothing  
....................                   // for a long time.  If the remote node does  
....................                   // not recieve this ACK, it'll have to figure  
....................                   // out on it's own that the connection is now  
....................                   // closed. 
....................                   SendTCP(ACK, 0); 
6840:  MOVLW  10
6842:  MOVLB  3
6844:  MOVWF  xE6
6846:  CLRF   xE7
6848:  MOVLB  0
684A:  CALL   3870
....................                   CloseSocket(); 
684E:  CALL   10E4
....................                   return; 
6852:  BRA    6888
....................                } 
6854:  BRA    685E
6856:  MOVLB  1
....................                else 
....................                { 
....................                   MyTCBStub.smState = TCP_CLOSING; 
6858:  MOVLW  0A
685A:  MOVWF  xEF
685C:  MOVLB  0
....................                } 
....................                break; 
685E:  MOVLB  1
6860:  BRA    6878
....................     
....................             case TCP_FIN_WAIT_2: 
....................                // RFC not recommended: We should be going to  
....................                // the TCP_TIME_WAIT state right here and  
....................                // starting a 2MSL timer, but since we have so  
....................                // few precious sockets, we can't afford to  
....................                // leave a socket waiting around doing nothing  
....................                // for a long time.  If the remote node does  
....................                // not recieve this ACK, it'll have to figure  
....................                // out on it's own that the connection is now  
....................                // closed. 
....................                SendTCP(ACK, 0); 
6862:  MOVLW  10
6864:  MOVLB  3
6866:  MOVWF  xE6
6868:  CLRF   xE7
686A:  MOVLB  0
686C:  CALL   3870
....................                CloseSocket(); 
6870:  CALL   10E4
....................                return; 
6874:  BRA    6888
....................  
....................             default: 
....................                break; 
6876:  MOVLB  1
....................          } 
....................  
....................          // Acknowledge receipt of FIN 
....................          SendTCP(ACK, SENDTCP_RESET_TIMERS); 
6878:  MOVLW  10
687A:  MOVLB  3
687C:  MOVWF  xE6
687E:  MOVLW  01
6880:  MOVWF  xE7
6882:  MOVLB  0
6884:  CALL   3870
6888:  MOVLB  3
....................       } 
....................    } 
688A:  MOVLB  0
688C:  GOTO   6A00 (RETURN)
.................... } 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    Buffer Management Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize,  
....................                      WORD wMinTXSize, BYTE vFlags) 
....................  
....................   Summary: 
....................    Adjusts the relative sizes of the RX and TX buffers. 
....................  
....................   Description: 
....................    This function can be used to adjust the relative sizes of the RX and 
....................    TX FIFO depending on the immediate needs of an application.  Since a  
....................    larger FIFO can allow more data to be sent in a given packet, adjusting  
....................    the relative sizes on the fly can allow for optimal transmission speed  
....................    for one-sided application protocols.  For example, HTTP typically  
....................    begins by receiving large amounts of data from the client, then switches 
....................    to serving large amounts of data back.  Adjusting the FIFO at these  
....................    points can increase performance substantially.  Once the FIFO is 
....................    adjusted, a window update is sent. 
....................     
....................    If neither or both of TCP_ADJUST_GIVE_REST_TO_TX and  
....................    TCP_ADJUST_GIVE_REST_TO_RX are set, the function distributes the 
....................    remaining space equally. 
....................     
....................    Received data can be preserved as long as the buffer is expanding and  
....................    has not wrapped. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - The socket to be adjusted 
....................    wMinRXSize   - Minimum number of byte for the RX FIFO 
....................    wMinTXSize    - Minimum number of bytes for the RX FIFO 
....................    vFlags      - Any combination of TCP_ADJUST_GIVE_REST_TO_RX,  
....................               TCP_ADJUST_GIVE_REST_TO_TX, TCP_ADJUST_PRESERVE_RX. 
....................               TCP_ADJUST_PRESERVE_TX is not currently supported. 
....................  
....................   Return Values: 
....................    TRUE - The FIFOs were adjusted successfully 
....................    FALSE - Minimum RX, Minimum TX, or flags couldn't be accommodated and 
....................          therefore the socket was left unchanged. 
....................  
....................   Side Effects: 
....................    Any unacknowledged or untransmitted data in the TX FIFO is always 
....................    deleted. 
....................  
....................   Remarks: 
....................    At least one byte must always be allocated to the RX buffer so that 
....................    a FIN can be received.  The function automatically corrects for this. 
....................   ***************************************************************************/ 
.................... BOOL TCPAdjustFIFOSize(TCP_SOCKET hTCP, WORD wMinRXSize, WORD wMinTXSize, BYTE vFlags) 
.................... { 
....................    PTR_BASE ptrTemp, ptrHead; 
....................    WORD wTXAllocation; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    // Load up info on this socket 
....................    SyncTCBStub(hTCP); 
....................  
....................    // RX has to be at least 1 byte to receive SYN and FIN bytes  
....................    // from the remote node, even if they aren't stored in the RX FIFO 
....................    if(wMinRXSize == 0u) 
....................       wMinRXSize = 1; 
....................        
....................    // SSL connections need to be able to send or receive at least  
....................    // a full Alert record, MAC, and FIN 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP) && wMinRXSize < 25u) 
....................       wMinRXSize = 25; 
....................    if(TCPIsSSL(hTCP) && wMinTXSize < 25u) 
....................       wMinTXSize = 25; 
....................    #endif 
....................     
....................    // Make sure space is available for minimums 
....................    ptrTemp = MyTCBStub.bufferEnd - MyTCBStub.bufferTxStart - 1; 
....................    if(wMinRXSize + wMinTXSize > ptrTemp) 
....................       return FALSE; 
....................  
....................    SyncTCB(); 
....................  
....................    // Set both allocation flags if none set 
....................    if(!(vFlags & (TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX))) 
....................       vFlags |= TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX; 
....................        
....................  
....................    // Allocate minimums 
....................    wTXAllocation = wMinTXSize; 
....................    ptrTemp -= wMinRXSize + wMinTXSize; 
....................  
....................    // Allocate extra 
....................    if(vFlags & TCP_ADJUST_GIVE_REST_TO_TX) 
....................    { 
....................       if(vFlags & TCP_ADJUST_GIVE_REST_TO_RX) 
....................       { 
....................          // Do a 50%/50% split with any odd byte always going to the RX FIFO 
....................          wTXAllocation += ptrTemp>>1; 
....................       } 
....................       else 
....................       { 
....................          wTXAllocation += ptrTemp; 
....................       } 
....................    } 
....................  
....................    // Calculate new bufferRxStart pointer 
....................    ptrTemp = MyTCBStub.bufferTxStart + wTXAllocation + 1; 
....................  
....................    // Find the head pointer to use 
....................    ptrHead = MyTCBStub.rxHead; 
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       ptrHead = MyTCBStub.sslRxHead; 
....................    #endif 
....................     
....................    // If there's out-of-order data pending, adjust the head pointer to compensate 
....................    if(MyTCB.sHoleSize != -1) 
....................    { 
....................       ptrHead += MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................       if(ptrHead > MyTCBStub.bufferEnd) 
....................          ptrHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................    } 
....................  
....................    // Determine if resizing will lose any RX data 
....................    if(MyTCBStub.rxTail < ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.rxTail) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................  
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else if(MyTCBStub.rxTail > ptrHead) 
....................    { 
....................       if(ptrTemp > MyTCBStub.bufferRxStart) 
....................       { 
....................          if(vFlags & TCP_ADJUST_PRESERVE_RX) 
....................             return FALSE; 
....................          else 
....................          { 
....................             MyTCBStub.rxTail = ptrTemp; 
....................             MyTCBStub.rxHead = ptrTemp; 
....................              
....................             #if defined(STACK_USE_SSL) 
....................             MyTCBStub.sslRxHead = ptrTemp; 
....................             #endif 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       // No data to preserve, but we may need to move  
....................       // the pointers to stay in the RX space 
....................       MyTCBStub.rxTail = ptrTemp; 
....................       MyTCBStub.rxHead = ptrTemp; 
....................        
....................       #if defined(STACK_USE_SSL) 
....................       MyTCBStub.sslRxHead = ptrTemp; 
....................       #endif 
....................    } 
....................     
....................    // If we need to preserve data that wrapped in the ring, we must copy 
....................    if(ptrHead < MyTCBStub.rxTail && (vFlags & TCP_ADJUST_PRESERVE_RX)) 
....................    { 
....................       TCPRAMCopy(ptrTemp, MyTCBStub.vMemoryMedium,  
....................          MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, 
....................          ptrHead - MyTCBStub.bufferRxStart); 
....................  
....................       // Move the pointers if they were in front of the tail 
....................       #if defined(STACK_USE_SSL) 
....................       if(TCPIsSSL(hTCP) && MyTCBStub.sslRxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.sslRxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................       #endif 
....................       if(MyTCBStub.rxHead < MyTCBStub.rxTail) 
....................          MyTCBStub.rxHead -= MyTCBStub.bufferRxStart - ptrTemp; 
....................    } 
....................     
....................    // Move the RX buffer pointer - it's the one that divides the two 
....................    MyTCBStub.bufferRxStart = ptrTemp; 
....................  
....................    // Empty the TX buffer 
....................    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txTail = MyTCBStub.bufferTxStart; 
....................    MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................     
....................    #if defined(STACK_USE_SSL) 
....................    if(TCPIsSSL(hTCP)) 
....................       MyTCBStub.sslTxHead = MyTCBStub.txHead + 5; 
....................    #endif 
....................     
....................    // Send a window update to notify remote node of change 
....................    if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       SendTCP(ACK, SENDTCP_RESET_TIMERS); 
....................  
....................    return TRUE; 
....................  
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource,  
....................                      BYTE vSourceType, WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM). 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    ptrDest      - Address to write to 
....................    vDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    ptrSource   - Address to copy from 
....................    vSourceType - Source medium (TCP_PIC_RAM, TCP_ETH_RAM, or TCP_SPI_RAM) 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer.  However, if they do  
....................    overlap there must be at least 4 bytes of non-overlap to ensure correct  
....................    results due to hardware DMA requirements. 
....................   ***************************************************************************/ 
.................... static void TCPRAMCopy(PTR_BASE ptrDest, BYTE vDestType, PTR_BASE ptrSource, BYTE vSourceType, WORD wLength) 
.................... { 
....................    #if defined(SPIRAM_CS_TRIS) 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................    #endif 
....................        
....................    switch(vSourceType) 
*
0F26:  MOVLB  4
0F28:  MOVF   x1C,W
0F2A:  XORLW  01
0F2C:  MOVLB  0
0F2E:  BZ    0F36
0F30:  XORLW  01
0F32:  BZ    0FA8
0F34:  BRA    100A
....................    { 
....................       case TCP_PIC_RAM: 
....................          switch(vDestType) 
0F36:  MOVLB  4
0F38:  MOVF   x19,W
0F3A:  XORLW  01
0F3C:  MOVLB  0
0F3E:  BZ    0F46
0F40:  XORLW  01
0F42:  BZ    0F78
0F44:  BRA    0FA6
....................          { 
....................             case TCP_PIC_RAM: 
....................                memcpy((void*)(BYTE*)ptrDest, (void*)(BYTE*)ptrSource, wLength); 
0F46:  MOVFF  418,FEA
0F4A:  MOVFF  417,FE9
0F4E:  MOVFF  41B,FE2
0F52:  MOVFF  41A,FE1
0F56:  MOVFF  41E,02
0F5A:  MOVFF  41D,01
0F5E:  MOVF   01,F
0F60:  BZ    0F66
0F62:  INCF   02,F
0F64:  BRA    0F6A
0F66:  MOVF   02,F
0F68:  BZ    0F76
0F6A:  MOVFF  FE6,FEE
0F6E:  DECFSZ 01,F
0F70:  BRA    0F6A
0F72:  DECFSZ 02,F
0F74:  BRA    0F6A
....................                break; 
0F76:  BRA    0FA6
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
0F78:  MOVLB  4
0F7A:  INCFSZ x17,W
0F7C:  BRA    0F84
0F7E:  INCFSZ x18,W
0F80:  BRA    0F84
0F82:  BRA    0F92
....................                   MACSetWritePtr(ptrDest); 
0F84:  MOVFF  418,420
0F88:  MOVFF  417,41F
0F8C:  MOVLB  0
0F8E:  RCALL  0AAE
0F90:  MOVLB  4
....................                MACPutArray((BYTE*)ptrSource, wLength); 
0F92:  MOVFF  41B,435
0F96:  MOVFF  41A,434
0F9A:  MOVFF  41E,437
0F9E:  MOVFF  41D,436
0FA2:  MOVLB  0
0FA4:  RCALL  0B1E
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                SPIRAMPutArray(ptrDest, (BYTE*)ptrSource, wLength); 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
0FA6:  BRA    100A
....................     
....................       case TCP_ETH_RAM: 
....................          switch(vDestType) 
0FA8:  MOVLB  4
0FAA:  MOVF   x19,W
0FAC:  XORLW  01
0FAE:  MOVLB  0
0FB0:  BZ    0FB8
0FB2:  XORLW  01
0FB4:  BZ    0FE8
0FB6:  BRA    1008
....................          { 
....................             case TCP_PIC_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
0FB8:  MOVLB  4
0FBA:  INCFSZ x1A,W
0FBC:  BRA    0FC4
0FBE:  INCFSZ x1B,W
0FC0:  BRA    0FC4
0FC2:  BRA    0FD2
....................                   MACSetReadPtr(ptrSource); 
0FC4:  MOVFF  41B,420
0FC8:  MOVFF  41A,41F
0FCC:  MOVLB  0
0FCE:  RCALL  0B64
0FD0:  MOVLB  4
....................                MACGetArray((BYTE*)ptrDest, wLength); 
0FD2:  MOVFF  418,433
0FD6:  MOVFF  417,432
0FDA:  MOVFF  41E,435
0FDE:  MOVFF  41D,434
0FE2:  MOVLB  0
0FE4:  RCALL  0BD0
....................                break; 
0FE6:  BRA    1008
....................     
....................             case TCP_ETH_RAM: 
....................                MACMemCopyAsync(ptrDest, ptrSource, wLength); 
0FE8:  MOVFF  418,420
0FEC:  MOVFF  417,41F
0FF0:  MOVFF  41B,422
0FF4:  MOVFF  41A,421
0FF8:  MOVFF  41E,424
0FFC:  MOVFF  41D,423
1000:  RCALL  0C70
....................                while(!MACIsMemCopyDone()); 
1002:  RCALL  0EFE
1004:  MOVF   01,F
1006:  BZ    1002
....................                break; 
....................     
....................             #if defined(SPIRAM_CS_TRIS) 
....................             case TCP_SPI_RAM: 
....................                if(ptrSource!=(PTR_BASE)-1) 
....................                   MACSetReadPtr(ptrSource); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   MACGetArray(vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................             #endif 
....................          } 
....................          break; 
1008:  BRA    100A
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          switch(vDestType) 
....................          { 
....................             case TCP_PIC_RAM: 
....................                SPIRAMGetArray(ptrSource, (BYTE*)ptrDest, wLength); 
....................                break; 
....................     
....................             case TCP_ETH_RAM: 
....................                if(ptrDest!=(PTR_BASE)-1) 
....................                   MACSetWritePtr(ptrDest); 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                    
....................                   // Read and write a chunk    
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   ptrSource += w; 
....................                   MACPutArray(vBuffer, w); 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................     
....................             case TCP_SPI_RAM: 
....................                // Copy all of the data over in chunks 
....................                w = sizeof(vBuffer); 
....................                while(wLength) 
....................                { 
....................                   if(w > wLength) 
....................                      w = wLength; 
....................                       
....................                   SPIRAMGetArray(ptrSource, vBuffer, w); 
....................                   SPIRAMPutArray(ptrDest, vBuffer, w); 
....................                   ptrSource += w; 
....................                   ptrDest += w; 
....................                   wLength -= w; 
....................                } 
....................                break; 
....................          } 
....................          break; 
....................       #endif          
....................    } 
100A:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource,  
....................                         WORD wLength) 
....................  
....................   Summary: 
....................    Copies data to/from various memory mediums. 
....................  
....................   Description: 
....................    This function copies data between memory mediums (PIC RAM, SPI 
....................    RAM, and Ethernet buffer RAM).  This function is to be used when  
....................    copying from ROM. 
....................  
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    wDest      - Address to write to 
....................    wDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM) 
....................    wSource      - Address to copy from 
....................    wLength      - Number of bytes to copy 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    Copying to a destination region that overlaps with the source address  
....................    is supported only if the destination start address is at a lower memory  
....................    address (closer to 0x0000) than the source pointer. 
....................     
....................    This function is aliased to TCPRAMCopy on non-PIC18 platforms. 
....................   ***************************************************************************/ 
.................... #if defined(__18CXX) 
.................... static void TCPRAMCopyROM(PTR_BASE wDest, BYTE wDestType, ROM BYTE* wSource, WORD wLength) 
.................... { 
....................    BYTE vBuffer[16]; 
....................    WORD w; 
....................     
....................    switch(wDestType) 
....................    { 
....................       case TCP_PIC_RAM: 
....................          memcpypgm2ram((void*)(BYTE*)wDest, (ROM void*)wSource, wLength); 
....................          break; 
....................     
....................       case TCP_ETH_RAM: 
....................          if(wDest!=(PTR_BASE)-1) 
....................             MACSetWritePtr(wDest); 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             MACPutArray(vBuffer, w); 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................     
....................       #if defined(SPIRAM_CS_TRIS) 
....................       case TCP_SPI_RAM: 
....................          w = sizeof(vBuffer); 
....................          while(wLength) 
....................          { 
....................             if(w > wLength) 
....................                w = wLength; 
....................              
....................             // Read and write a chunk    
....................             memcpypgm2ram(vBuffer, (ROM void*)wSource, w); 
....................             SPIRAMPutArray(wDest, vBuffer, w); 
....................             wDest += w; 
....................             wSource += w; 
....................             wLength -= w; 
....................          } 
....................          break; 
....................       #endif 
....................    } 
.................... } 
.................... #endif 
....................  
.................... /**************************************************************************** 
....................   Section: 
....................    SSL Functions 
....................   ***************************************************************************/ 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    host      - Expected host name on certificate (currently ignored) 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClient(TCP_SOCKET hTCP, BYTE* host) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, BYTE * buffer, BYTE suppDataType) 
....................  
....................   Summary: 
....................    Begins an SSL client session. 
....................  
....................   Description: 
....................    This function escalates the current connection to an SSL secured  
....................    connection by initiating an SSL client handshake. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP         - TCP connection to secure 
....................    host         - Expected host name on certificate (currently ignored) 
....................    buffer         - Buffer for supplementary data return 
....................    suppDataType    - Type of supplementary data to copy 
....................  
....................   Return Values: 
....................    TRUE       - an SSL connection was initiated 
....................    FALSE       - Insufficient SSL resources (stubs) were available 
....................  
....................   Remarks: 
....................    The host parameter is currently ignored and is not validated. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_CLIENT) 
.................... BOOL TCPStartSSLClientEx(TCP_SOCKET hTCP, BYTE* host, void * buffer, BYTE suppDataType) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, buffer, suppDataType); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Begins an SSL server session. 
....................  
....................   Description: 
....................    This function sets up an SSL server session when a new connection is 
....................    established on an SSL port. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is already connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................  
....................   Return Values: 
....................    TRUE      - an SSL connection was initiated 
....................    FALSE      - Insufficient SSL resources (stubs) were available 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPStartSSLServer(TCP_SOCKET hTCP) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    SyncTCB(); 
....................     
....................    // Make sure SSL is not established already 
....................    if(MyTCBStub.sslStubID != SSL_INVALID_ID) 
....................       return TRUE; 
....................     
....................    // Try to start the session 
....................    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0); 
....................     
....................    // Make sure a session stub was obtained 
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................  
....................    // Swap the localPort and localSSLPort 
....................    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val; 
....................    MyTCB.localPort.Val = MyTCB.localSSLPort.Val; 
....................    MyTCB.localSSLPort.Val = MyTCBStub.remoteHash.Val;    
....................  
....................    // Mark connection as handshaking and return 
....................    MyTCBStub.sslReqMessage = SSL_NO_MESSAGE; 
....................    MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................    MyTCBStub.sslTxHead = MyTCBStub.txHead; 
....................    MyTCBStub.Flags.bSSLHandshaking = 1; 
....................    for(i = 0; i < 5u; i++) 
....................    {// Skip first 5 bytes in TX for the record header 
....................       if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................          MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................    return TRUE; 
.................... } 
.................... #endif // SSL Client 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
....................  
....................   Summary: 
....................    Listens for SSL connection on a specific port. 
....................  
....................   Description: 
....................    This function adds an additional listening port to a TCP connection.   
....................    Connections made on this alternate port will be secured via SSL. 
....................  
....................   Precondition: 
....................    TCP is initialized and hTCP is listening. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to secure 
....................    port      - SSL port to listen on 
....................  
....................   Return Values: 
....................    TRUE      - SSL port was added. 
....................    FALSE      - The socket was not a listening socket. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL_SERVER) 
.................... BOOL TCPAddSSLListener(TCP_SOCKET hTCP, WORD port) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.smState != TCP_LISTEN) 
....................       return FALSE; 
....................     
....................    SyncTCB(); 
....................     
....................    MyTCB.localSSLPort.Val = port; 
....................    MyTCBStub.sslTxHead = port; 
....................  
....................    return TRUE; 
.................... } 
.................... #endif // SSL Server 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
....................  
....................   Summary: 
....................    Requests an SSL message to be transmitted. 
....................  
....................   Description: 
....................    This function is called to request that a specific SSL message be 
....................    transmitted.  This message should only be called by the SSL module. 
....................     
....................   Precondition: 
....................    TCP is initialized. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to use 
....................    msg         - One of the SSL_MESSAGE types to transmit. 
....................  
....................   Return Values: 
....................    TRUE      - The message was requested. 
....................    FALSE      - Another message is already pending transmission. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPRequestSSLMessage(TCP_SOCKET hTCP, BYTE msg) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(msg == SSL_NO_MESSAGE || MyTCBStub.sslReqMessage == SSL_NO_MESSAGE) 
....................    { 
....................       MyTCBStub.sslReqMessage = msg; 
....................       return TRUE; 
....................    } 
....................     
....................    return FALSE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if an SSL session is still handshaking. 
....................  
....................   Description: 
....................    Call this function after calling TCPStartSSLClient until FALSE is 
....................    returned.  Then your application may continue with its normal data 
....................    transfer (which is now secured). 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - SSL handshake is still progressing 
....................    FALSE      - SSL handshake has completed 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPSSLIsHandshaking(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    return MyTCBStub.Flags.bSSLHandshaking;    
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    BOOL TCPIsSSL(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines if a TCP connection is secured with SSL. 
....................  
....................   Description: 
....................    Call this function to determine whether or not a TCP connection is  
....................    secured with SSL. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Return Values: 
....................    TRUE      - Connection is secured via SSL 
....................    FALSE      - Connection is not secured 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... BOOL TCPIsSSL(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return FALSE; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................     
....................    if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................       return FALSE; 
....................     
....................    return TRUE; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Clears the SSL handshake flag. 
....................  
....................   Description: 
....................    This function clears the flag indicating that an SSL handshake is 
....................    complete. 
....................     
....................   Precondition: 
....................    TCP is initialized and hTCP is connected. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to set 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandshakeComplete(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................    MyTCBStub.Flags.bSSLHandshaking = 0; 
.................... } 
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
....................  
....................   Summary: 
....................    Decrypts and MACs data arriving via SSL. 
....................  
....................   Description: 
....................    This function decrypts data in the TCP buffer and calculates the MAC over 
....................    the data.  All data is left in the exact same location in the TCP buffer. 
....................    It is called to help process incoming SSL records. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to decrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    len       - Number of bytes to crypt 
....................    inPlace      - TRUE to write back in place, FALSE to write at end of 
....................                currently visible data. 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, WORD len) 
.................... { 
....................    PTR_BASE wSrc, wDest, wBlockLen, wTemp; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    wSrc = MyTCBStub.rxTail; 
....................    wDest = wSrc; 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       wBlockLen = sizeof(buffer); 
....................       if(wBlockLen > len) // Don't do more than we should 
....................          wBlockLen = len; 
....................        
....................       // Read those bytes to a buffer 
....................       if(wSrc + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part read 
....................          wTemp = MyTCBStub.bufferEnd - wSrc + 1; 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wTemp); 
....................          TCPRAMCopy((PTR_BASE)buffer+wTemp, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wBlockLen - wTemp); 
....................          wSrc = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wBlockLen); 
....................          wSrc += wBlockLen; 
....................       } 
....................        
....................       // Decrypt and hash 
....................       ARCFOURCrypt(ctx, buffer, wBlockLen); 
....................       SSLMACAdd(buffer, wBlockLen); 
....................        
....................       // Write decrypted bytes back 
....................       if(wDest + wBlockLen > MyTCBStub.bufferEnd) 
....................       {// Two part write 
....................          wTemp = MyTCBStub.bufferEnd - wDest + 1; 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wTemp); 
....................          TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer+wTemp, TCP_PIC_RAM, wBlockLen - wTemp); 
....................          wDest = MyTCBStub.bufferRxStart + wBlockLen - wTemp; 
....................       } 
....................       else 
....................       { 
....................          TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wBlockLen); 
....................          wDest += wBlockLen; 
....................       } 
....................        
....................       // Update the length remaining 
....................       len -= wBlockLen; 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx,  
....................                            BYTE* MACSecret, WORD len) 
....................  
....................   Summary: 
....................    Encrypts and MACs data in place in the TCP TX buffer. 
....................  
....................   Description: 
....................    This function encrypts data in the TCP buffer while calcuating a MAC.   
....................    When encryption is finished, the MAC is appended to the buffer and  
....................    the record will be ready to transmit. 
....................     
....................   Precondition: 
....................    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to encrypt in 
....................    ctx         - ARCFOUR encryption context to use 
....................    MACSecret   - MAC encryption secret to use 
....................    len       - Number of bytes to crypt 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, BYTE* MACSecret, WORD len) 
.................... { 
....................    PTR_BASE pos; 
....................    WORD blockLen; 
....................    BYTE buffer[32]; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................    pos = MyTCBStub.txHead; 
....................    for(blockLen = 0; blockLen < 5u; blockLen++) 
....................    {// Skips first 5 bytes for the header 
....................       if(++pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Handle 32 bytes at a time 
....................    while(len) 
....................    { 
....................       // Determine how many bytes we can read 
....................       blockLen = sizeof(buffer); 
....................       if(blockLen > len) // Don't do more than we should 
....................          blockLen = len; 
....................       if(blockLen > MyTCBStub.bufferRxStart - pos) // Don't pass the end 
....................          blockLen = MyTCBStub.bufferRxStart - pos; 
....................        
....................       // Read those bytes to a buffer 
....................       TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, pos, MyTCBStub.vMemoryMedium, blockLen); 
....................        
....................       // Hash and encrypt 
....................       SSLMACAdd(buffer, blockLen); 
....................       ARCFOURCrypt(ctx, buffer, blockLen); 
....................        
....................       // Put them back 
....................       TCPRAMCopy(pos, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................        
....................       // Update the pointers 
....................       pos += blockLen; 
....................       len -= blockLen; 
....................       if(pos >= MyTCBStub.bufferRxStart) 
....................          pos = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    // Calculate and add the MAC 
....................    SSLMACCalc(MACSecret, buffer); 
....................    ARCFOURCrypt(ctx, buffer, 16); 
....................  
....................    // Write the MAC to the TX FIFO 
....................    // Can't use TCPPutArray here because TCPIsPutReady() saves 16 bytes for the MAC 
....................    // TCPPut* functions use this to prevent writing too much data.  Therefore, the 
....................    // functionality is duplicated here. 
....................     
....................    len = 16; 
....................    blockLen = 0; 
....................    // See if we need a two part put 
....................    if(MyTCBStub.sslTxHead + len >= MyTCBStub.bufferRxStart) 
....................    { 
....................       blockLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead; 
....................       TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen); 
....................       len -= blockLen; 
....................       MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................    } 
....................     
....................    TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&buffer[blockLen], TCP_PIC_RAM, len); 
....................    MyTCBStub.sslTxHead += len; 
....................  
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
....................  
....................   Summary: 
....................    Writes an SSL record header and sends an SSL record. 
....................  
....................   Description: 
....................    This function writes an SSL record header to the pending TCP SSL data,  
....................    then indicates that the data is ready to be sent by moving the txHead 
....................    pointer. 
....................     
....................    If the record is complete, set recDone to TRUE.  The sslTxHead  
....................    pointer will be moved forward 5 bytes to leave space for a future  
....................    record header.  If the record is only partially sent, use FALSE and 
....................    to leave the pointer where it is so that more data can be added 
....................    to the record.  Partial records can only be used for the  
....................    SERVER_CERTIFICATE handshake message. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to write the header and transmit with 
....................    hdr         - Record header (5 bytes) to send or NULL to just  
....................               move the pointerctx 
....................    recDone      - TRUE if the record is done, FALSE otherwise 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, BYTE* hdr, BOOL recDone) 
.................... { 
....................    BYTE i; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Set up the pointers 
....................    SyncTCBStub(hTCP); 
....................     
....................    // Write the header if needed 
....................    if(hdr) 
....................    {// This is a new record, so insert the header 
....................       for(i = 0; i < 5u; i++) 
....................       { 
....................          TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)hdr+i, TCP_PIC_RAM, sizeof(BYTE)); 
....................          if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.txHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
....................     
....................    // Move the txHead pointer to indicate what data is ready 
....................    // Also, flush just the header, then all the data.  This shotguns two  
....................    // packets down the line, therefore causing immediate ACKs by the  
....................    // remote node.  Reconnect handshakes are as much as 60% faster now. 
....................    TCPFlush(hTCP); 
....................    MyTCBStub.txHead = MyTCBStub.sslTxHead; 
....................    TCPFlush(hTCP); 
....................     
....................    // If this record is done, move the sslTxHead forward 
....................    // to accomodate the next record header 
....................    if(recDone) 
....................    { 
....................       for(i = 0; i < 5u; i++) 
....................       {// Skip first 5 bytes in TX for the record header 
....................          if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart) 
....................             MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart; 
....................       } 
....................    } 
.................... }    
.................... #endif // SSL 
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Determines how many bytes are pending for a future SSL record. 
....................  
....................   Description: 
....................    This function determines how many bytes are pending for a future SSL 
....................    record. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL connection. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to check 
....................  
....................   Returns: 
....................    None 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... WORD TCPSSLGetPendingTxSize(TCP_SOCKET hTCP) 
.................... { 
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return 0; 
....................     } 
....................      
....................    SyncTCBStub(hTCP); 
....................  
....................    // Non-SSL connections have no pending SSL data 
....................    //if(MyTCBStub.sslStubID == SSL_INVALID_ID) 
....................    //   return 0; 
....................           
....................    // Determine how many bytes are waiting to be written in this record 
....................    if(MyTCBStub.sslTxHead > MyTCBStub.txHead) 
....................       return MyTCBStub.sslTxHead - MyTCBStub.txHead - 5; 
....................    else 
....................       return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.sslTxHead - 1) - 5; 
.................... } 
.................... #endif 
....................  
....................  
.................... /***************************************************************************** 
....................   Function: 
....................    void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
....................  
....................   Summary: 
....................    Hands newly arrive TCP data to the SSL module for processing. 
....................  
....................   Description: 
....................    This function processes incoming TCP data as an SSL record and  
....................    performs any necessary repositioning and decrypting. 
....................     
....................   Precondition: 
....................    TCP is initialized, and hTCP is connected with an active SSL session. 
....................  
....................   Parameters: 
....................    hTCP      - TCP connection to handle incoming data on 
....................  
....................   Returns: 
....................    None 
....................  
....................   Remarks: 
....................    This function should never be called by an application.  It is used  
....................    only by the SSL module itself. 
....................   ***************************************************************************/ 
.................... #if defined(STACK_USE_SSL) 
.................... void TCPSSLHandleIncoming(TCP_SOCKET hTCP) 
.................... { 
....................    PTR_BASE prevRxTail, nextRxHead, startRxTail, wSrc, wDest; 
....................    WORD wToMove, wLen, wSSLBytesThatPoofed, wDecryptedBytes; 
....................     
....................    if(hTCP >= TCP_SOCKET_COUNT) 
....................     { 
....................         return; 
....................     } 
....................      
....................    // Sync the stub 
....................    SyncTCBStub(hTCP); 
....................  
....................    // If new data is waiting 
....................    if(MyTCBStub.sslRxHead != MyTCBStub.rxHead) 
....................    { 
....................       // Reconfigure pointers for SSL use 
....................       prevRxTail = MyTCBStub.rxTail; 
....................       nextRxHead = MyTCBStub.rxHead; 
....................       MyTCBStub.rxTail = MyTCBStub.rxHead; 
....................       MyTCBStub.rxHead = MyTCBStub.sslRxHead; 
....................        
....................       do 
....................       { 
....................          startRxTail = MyTCBStub.rxTail; 
....................  
....................          // Handle incoming data.  This function performs deframing of the  
....................          // SSL records, decryption, and MAC verification. 
....................          wSSLBytesThatPoofed = TCPIsGetReady(hTCP); 
....................          wDecryptedBytes = SSLRxRecord(hTCP, MyTCBStub.sslStubID); 
....................          wSSLBytesThatPoofed -= TCPIsGetReady(hTCP); 
....................  
....................          // Now need to move data to fill the SSL header/MAC/padding hole,  
....................          // if there is one 
....................          if(wSSLBytesThatPoofed) 
....................          {    
....................             // Sync the TCP so we can see if there is a TCP hole 
....................             SyncTCB(); 
....................  
....................             // Calculate how big the SSL hole is 
....................             if(MyTCB.sHoleSize == -1) 
....................             {// Just need to move pending SSL data 
....................                wToMove = TCPIsGetReady(hTCP); 
....................             } 
....................             else 
....................             {// A TCP hole exists, so move all data 
....................                wToMove = TCPIsGetReady(hTCP) + MyTCB.sHoleSize + MyTCB.wFutureDataSize; 
....................             } 
....................              
....................             // Start with the destination as the startRxTail and source as current rxTail 
....................             wDest = startRxTail; 
....................             wSrc = MyTCBStub.rxTail; 
....................              
....................             // If data exists between the end of the buffer and  
....................             // the destination, then move it forward 
....................             if(wSrc > wDest) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wSrc + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest += wLen; 
....................                wSrc = MyTCBStub.bufferRxStart; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data remains to be moved, fill in to end of buffer 
....................             if(wToMove) 
....................             { 
....................                wLen = MyTCBStub.bufferEnd - wDest + 1; 
....................                if(wLen > wToMove) 
....................                   wLen = wToMove; 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,  
....................                         wSrc, MyTCBStub.vMemoryMedium, wLen); 
....................                wDest = MyTCBStub.bufferRxStart; 
....................                wSrc += wLen; 
....................                wToMove -= wLen; 
....................             } 
....................              
....................             // If data still remains, copy from from front + len to front 
....................             if(wToMove) 
....................             { 
....................                TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, 
....................                         wSrc, MyTCBStub.vMemoryMedium, wToMove); 
....................             } 
....................  
....................             // Since bytes poofed, we need to move the head pointers  
....................             // backwards by an equal amount. 
....................             MyTCBStub.rxHead -= wSSLBytesThatPoofed; 
....................             if(MyTCBStub.rxHead < MyTCBStub.bufferRxStart) 
....................                MyTCBStub.rxHead += MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................             MyTCBStub.sslRxHead = MyTCBStub.rxHead; 
....................          } 
....................              
....................          // Move tail pointer forward by the number of decrypted bytes ready  
....................          // for the application (but not poofed bytes) 
....................          MyTCBStub.rxTail = startRxTail + wDecryptedBytes; 
....................          if(MyTCBStub.rxTail > MyTCBStub.bufferEnd) 
....................             MyTCBStub.rxTail -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................          nextRxHead += wDecryptedBytes; 
....................           
....................          // Loop until SSLRxRecord() runs out of data and stops doing  
....................          // anything 
....................       } while(wSSLBytesThatPoofed || (startRxTail != MyTCBStub.rxTail)); 
....................  
....................       // Restore TCP buffer pointers to point to the decrypted application data  
....................       // only 
....................       if(nextRxHead > MyTCBStub.bufferEnd) 
....................          nextRxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1; 
....................       MyTCBStub.rxTail = prevRxTail; 
....................       MyTCBStub.rxHead = nextRxHead; 
....................    } 
.................... }    
.................... #endif 
....................  
....................  
.................... #endif //#if defined(STACK_USE_TCP) 
....................  
....................     
....................    void TCPTouch(TCP_SOCKET s) 
....................    { 
....................       SyncTCBStub(s); 
....................       if(MyTCBStub.smState == TCP_ESTABLISHED) 
....................       { 
....................          MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT; 
....................          SyncTCB(); 
....................       } 
....................    } 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
....................    #include "_DNS.c" //ccs had to rename this driver to not conflict an s7600 driver in the default include path - a bug in the compiler 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS) 
....................    #include "MPFS.c" 
.................... /********************************************************************* 
....................  * 
....................  *   Microchip File System (MPFS) File Access API 
....................  *  Module for Microchip TCP/IP Stack 
....................  *    -Provides single API for accessing web pages and other files  
....................  *    from internal program memory or an external serial EEPROM memory 
....................  *    -Reference: AN833 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MPFS.c 
....................  * Dependencies:    SPIEEPROM 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *               Microchip C30 v3.12 or higher 
....................  *               Microchip C18 v3.30 or higher 
....................  *               HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *      ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *      used in conjunction with a Microchip ethernet controller for 
....................  *      the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01     Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     3/31/05      Changed MPFS_ENTRY and mpfs_Flags for C30 
....................  * Darren Rook/CCS      4/13/11     When using CCS and program memory,  
....................                                        MPFS_Start[] is not defined/extern'd. 
....................                                        Instead CCS will use #import. 
....................  * Darren Rook/CCS      4/13/11     typedefing MPFS as rom* is causing CCS 
....................                                        compiler problems.  So it was 
....................                                        typedef'd to __address__.  That means 
....................                                        places where it was dereferencing MPFS 
....................                                        was replaced with read_program_memory(). 
....................  * Darren Rook/CCS      4/13/11     MPFSFormat() not included if using program 
....................                                        memory. 
....................  * Darren Rook/CCS      4/13/11     Added MPFS_RETURN_OFFSET option. 
....................  * Darren Rook/CCS      4/13/11     MPFSPutEnd() added SPIFlashStopWrite(). 
....................  * Darren Rook/CCS      5/18/11     When using PCD, not using  
....................  *                                     ReadProgramMemory() algo because 
....................  *                                     CCS is using #import() and the  
....................  *                                     data gets aligned differently. 
.................... ********************************************************************/ 
.................... #ifndef __MPFS_C 
.................... #define __MPFS_C 
....................  
.................... #include "TCPIP Stack/TCPIP.h" 
.................... /********************************************************************* 
....................  * 
....................  *  Microchip TCP/IP Stack Include File 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCPIP.h 
....................  * Dependencies:     
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F, PIC32 
....................  * Compiler:        Microchip C32 v1.05 or higher 
....................  *					Microchip C30 v3.12 or higher 
....................  *					Microchip C18 v3.30 or higher 
....................  *					HI-TECH PICC-18 PRO 9.63PL2 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * Copyright (C) 2002-2009 Microchip Technology Inc.  All rights 
....................  * reserved. 
....................  * 
....................  * Microchip licenses to you the right to use, modify, copy, and 
....................  * distribute: 
....................  * (i)  the Software when embedded on a Microchip microcontroller or 
....................  *      digital signal controller product ("Device") which is 
....................  *      integrated into Licensee's product; or 
....................  * (ii) ONLY the Software driver source files ENC28J60.c, ENC28J60.h, 
....................  *		ENCX24J600.c and ENCX24J600.h ported to a non-Microchip device 
....................  *		used in conjunction with a Microchip ethernet controller for 
....................  *		the sole purpose of interfacing with the ethernet controller. 
....................  * 
....................  * You should refer to the license agreement accompanying this 
....................  * Software for additional information regarding your rights and 
....................  * obligations. 
....................  * 
....................  * THE SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT 
....................  * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT 
....................  * LIMITATION, ANY WARRANTY OF MERCHANTABILITY, FITNESS FOR A 
....................  * PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL 
....................  * MICROCHIP BE LIABLE FOR ANY INCIDENTAL, SPECIAL, INDIRECT OR 
....................  * CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF 
....................  * PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY OR SERVICES, ANY CLAIMS 
....................  * BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE 
....................  * THEREOF), ANY CLAIMS FOR INDEMNITY OR CONTRIBUTION, OR OTHER 
....................  * SIMILAR COSTS, WHETHER ASSERTED ON THE BASIS OF CONTRACT, TORT 
....................  * (INCLUDING NEGLIGENCE), BREACH OF WARRANTY, OR OTHERWISE. 
....................  * 
....................  * 
....................  * V5.36 ---- STACK_USE_MPFS has been removed. 
....................  ********************************************************************/ 
.................... #ifndef __TCPIP_HITECH_WORKAROUND_H 
.................... #define __TCPIP_HITECH_WORKAROUND_H 
....................  
.................... #define TCPIP_STACK_VERSION 		"v5.42"		// TCP/IP stack version 
....................  
.................... #include <string.h> 
.................... #include <stdlib.h> 
.................... #include "GenericTypeDefs.h" 
.................... #include "Compiler.h" 
.................... #include "HardwareProfile.h" 
....................  
.................... // RESERVED FEATURE -- do not change from current value of 1u as this is not  
.................... // fully implemented yet. 
.................... // Defines the number of different network interfaces to support (ex: 2 for  
.................... // Wifi and Ethernet simultaneously). 
.................... #define NETWORK_INTERFACES		(1u)	 
....................  
.................... /******************************************************************* 
....................  * Memory Configuration 
....................  *   The following section sets up the memory types for use by 
....................  *   this application. 
....................  *******************************************************************/ 
.................... 	// Represents data stored in Ethernet buffer RAM 
.................... 	#define TCP_ETH_RAM	0u 
.................... 	// The base address for TCP data in Ethernet RAM 
.................... 	#define TCP_ETH_RAM_BASE_ADDRESS			(BASE_TCB_ADDR) 
.................... 	// Represents data stored in local PIC RAM 
.................... 	#define TCP_PIC_RAM	1u 
.................... 	// The base address for TCP data in PIC RAM 
.................... 	#define TCP_PIC_RAM_BASE_ADDRESS			((PTR_BASE)&TCPBufferInPIC[0]) 
.................... 	// Represents data stored in external SPI RAM 
.................... 	#define TCP_SPI_RAM	2u 
....................  
.................... /******************************************************************* 
....................  * User Configuration 
....................  *   Load the user-specific configuration from TCPIPConfig.h 
....................  *******************************************************************/ 
.................... #include "TCPIPConfig.h" 
....................  
.................... /******************************************************************* 
....................  * Configuration Rules Enforcement 
....................  *   The following section enforces requirements for modules based  
....................  *   on configurations selected in TCPIPConfig.h 
....................  *******************************************************************/ 
....................  
.................... #ifndef STACK_USE_MDD 
....................  
.................... 	 
.................... 	 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) || defined(STACK_USE_FTP_SERVER) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMPV3_SERVER) && !defined (STACK_USE_SNMP_SERVER) 
.................... 		#define STACK_USE_SNMP_SERVER 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) //&& !defined(STACK_USE_MPFS) && !defined(STACK_USE_MPFS2) 
.................... 		#define STACK_USE_MPFS2 
.................... 	#endif 
....................  
.................... 	#if defined(STACK_USE_SNMP_SERVER) && defined (STACK_USE_SNMPV3_SERVER) 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 	#endif 
.................... #endif 
.................... 	 
.................... 	// FTP is not supported in MPFS2 or when MPFS is stored in internal program  
.................... 	// memory (instead of external EEPROM). 
.................... 	#if ( (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) || defined(STACK_USE_MPFS2) ) && defined(STACK_USE_FTP) 
.................... 		#error FTP server is not supported with HTTP2 / MPFS2, or with internal Flash memory storage 
.................... 	#endif 
.................... 	 
.................... 	// When IP Gleaning is enabled, ICMP must also be enabled. 
.................... 	#if defined(STACK_USE_IP_GLEANING) 
.................... 	    #if !defined(STACK_USE_ICMP_SERVER) 
.................... 	        #define STACK_USE_ICMP_SERVER 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Include modules required by specific HTTP demos 
.................... 	#if !defined(STACK_USE_HTTP2_SERVER) 
.................... 		#undef STACK_USE_HTTP_EMAIL_DEMO 
.................... 		#undef STACK_USE_HTTP_MD5_DEMO 
.................... 		#undef STACK_USE_HTTP_APP_RECONFIG 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_EMAIL_DEMO) 
.................... 		#if !defined(STACK_USE_SMTP_CLIENT) 
.................... 			#error HTTP E-mail Demo requires SMTP_CLIENT and HTTP2 
.................... 		#endif 
.................... 	#endif 
.................... 	#if defined(STACK_USE_HTTP_MD5_DEMO) 
.................... 		#if !defined(STACK_USE_MD5) 
.................... 			#define STACK_USE_MD5 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Can't do MPFS upload without POST or external memory 
.................... 	#if defined(HTTP_MPFS_UPLOAD) 
.................... 		#if !defined(HTTP_USE_POST) || (!defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH)) 
.................... 			#undef HTTP_MPFS_UPLOAD 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that the DNS client is enabled if services require it 
.................... 	#if defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_AUTOUPDATE_TCPCLIENT) 
.................... 	    #if !defined(STACK_USE_DNS) 
.................... 	        #define STACK_USE_DNS 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_CLIENT_MODE is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ICMP_CLIENT) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
....................         defined(STACK_USE_AUTO_IP) 
.................... 		#if !defined(STACK_CLIENT_MODE) 
.................... 		    #define STACK_CLIENT_MODE 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_TCP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_UART2TCP_BRIDGE) || \ 
.................... 		defined(STACK_USE_HTTP2_SERVER) || \ 
.................... 		defined(STACK_USE_FTP_SERVER) || \ 
.................... 		defined(STACK_USE_TELNET_SERVER) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_CLIENT_EXAMPLE) || \ 
.................... 		defined(STACK_USE_GENERIC_TCP_SERVER_EXAMPLE) || \ 
.................... 		defined(STACK_USE_SMTP_CLIENT) || \ 
.................... 		defined(STACK_USE_TCP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_DYNAMICDNS_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) || \ 
.................... 		defined(STACK_USE_SSL_CLIENT) || \ 
.................... 		defined(STACK_USE_SSL_SERVER) 
.................... 	    #if !defined(STACK_USE_TCP) 
.................... 	        #define STACK_USE_TCP 
.................... 	    #endif 
.................... 	#endif 
.................... 	 
.................... 	// If TCP is not enabled, clear all memory allocations 
.................... 	#if !defined(STACK_USE_TCP) 
.................... 		#undef TCP_ETH_RAM_SIZE 
.................... 		#undef TCP_PIC_RAM_SIZE 
.................... 		#undef TCP_SPI_RAM_SIZE 
.................... 		#define TCP_ETH_RAM_SIZE 0u 
.................... 		#define TCP_PIC_RAM_SIZE 0u 
.................... 		#define TCP_SPI_RAM_SIZE 0u 
.................... 	#endif 
.................... 	 
.................... 	// If PIC RAM is used to store TCP socket FIFOs and TCBs,  
.................... 	// let's allocate it so the linker dynamically chooses  
.................... 	// where to locate it and prevents other variables from  
.................... 	// overlapping with it 
.................... 	#if defined(__TCP_C) && TCP_PIC_RAM_SIZE > 0u 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata TCPSocketMemory 
.................... 		#endif 
.................... 		static BYTE TCPBufferInPIC[TCP_PIC_RAM_SIZE] __attribute__((far)); 
.................... 		#if defined(__18CXX) && !defined(HI_TECH_C) 
.................... 			#pragma udata 
.................... 		#endif 
.................... 	#endif 
.................... 	 
.................... 	// Make sure that STACK_USE_UDP is defined if a service  
.................... 	// depends on it 
.................... 	#if defined(STACK_USE_DHCP_CLIENT) || \ 
.................... 		defined(STACK_USE_DHCP_SERVER) || \ 
.................... 		defined(STACK_USE_DNS) || \ 
.................... 		defined(STACK_USE_NBNS) || \ 
.................... 		defined(STACK_USE_SNMP_SERVER) || \ 
.................... 		defined(STACK_USE_TFTP_CLIENT) || \ 
.................... 		defined(STACK_USE_ANNOUNCE) || \ 
.................... 		defined(STACK_USE_UDP_PERFORMANCE_TEST) || \ 
.................... 		defined(STACK_USE_SNTP_CLIENT) || \ 
.................... 		defined(STACK_USE_BERKELEY_API) 
.................... 	    #if !defined(STACK_USE_UDP) 
.................... 	        #define STACK_USE_UDP 
.................... 	    #endif 
.................... 	#endif 
....................  
.................... 	// When using SSL server, enable RSA decryption 
.................... 	#if defined(STACK_USE_SSL_SERVER) 
.................... 		#define STACK_USE_RSA_DECRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
.................... 	 
.................... 	// When using SSL client, enable RSA encryption 
.................... 	#if defined(STACK_USE_SSL_CLIENT) 
.................... 		#define STACK_USE_RSA_ENCRYPT 
.................... 		#define STACK_USE_SSL 
.................... 	#endif 
....................  
.................... 	// If using SSL (either), include the rest of the support modules 
.................... 	#if defined(STACK_USE_SSL) 
.................... 		#define STACK_USE_ARCFOUR 
.................... 		#define STACK_USE_MD5 
.................... 		#define STACK_USE_SHA1 
.................... 		#define STACK_USE_RANDOM 
.................... 	#endif 
....................  
.................... 	// When using either RSA operation, include the RSA module 
.................... 	#if defined(STACK_USE_RSA_ENCRYPT) || defined(STACK_USE_RSA_DECRYPT) 
.................... 		#define STACK_USE_RSA 
.................... 		#define STACK_USE_BIGINT 
.................... 	#endif 
....................  
.................... 	// Enable the LCD if configured in the hardware profile 
.................... 	#if defined(LCD_DATA_IO) || defined(LCD_DATA0_IO) 
.................... 		#define USE_LCD 
.................... 	#endif 
.................... 	 
.................... 	// SPI Flash MPFS images must start on a block boundary 
.................... 	#if (defined(STACK_USE_MPFS2)) && \ 
.................... 		defined(MPFS_USE_SPI_FLASH) && ((MPFS_RESERVE_BLOCK & 0x0fff) != 0) 
.................... 		#error MPFS_RESERVE_BLOCK must be a multiple of 4096 for SPI Flash storage 
.................... 	#endif 
.................... 	 
.................... 	// HTTP2 requires 2 MPFS2 handles per connection, plus one spare 
.................... 	#if defined(STACK_USE_HTTP2_SERVER) 
.................... 		#if MAX_MPFS_HANDLES < ((MAX_HTTP_CONNECTIONS * 2) + 1) 
.................... 			#error HTTP2 requires 2 MPFS2 file handles per connection, plus one additional. 
.................... 		#endif 
.................... 	#endif 
....................  
.................... #include "TCPIP Stack/StackTsk.h" 
.................... #include "TCPIP Stack/Helpers.h" 
.................... #include "TCPIP Stack/Delay.h" 
.................... #include "TCPIP Stack/Tick.h" 
.................... #include "TCPIP Stack/MAC.h" 
.................... #include "TCPIP Stack/IP.h" 
.................... #include "TCPIP Stack/ARP.h" 
....................  
.................... #if defined(STACK_USE_BIGINT) 
.................... 	#include "TCPIP Stack/BigInt.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RSA) 
.................... 	#include "TCPIP Stack/RSA.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ARCFOUR) 
.................... 	#include "TCPIP Stack/ARCFOUR.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_AUTO_IP) 
....................     #include "TCPIP Stack/AutoIP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_RANDOM) 
.................... 	#include "TCPIP Stack/Random.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MD5) || defined(STACK_USE_SHA1) 
.................... 	#include "TCPIP Stack/Hashes.h" 
.................... #endif 
....................  
.................... 	#include "TCPIP Stack/XEEPROM.h" 
.................... 	#include "TCPIP Stack/SPIFlash.h" 
.................... 	#include "TCPIP Stack/SPIRAM.h" 
....................  
.................... #if defined(STACK_USE_UDP) 
.................... 	#include "TCPIP Stack/UDP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP) 
.................... 	#include "TCPIP Stack/TCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_BERKELEY_API) 
.................... 	#include "TCPIP Stack/BerkeleyAPI.h" 
.................... #endif 
....................  
.................... #if defined(USE_LCD) 
.................... 	#include "TCPIP Stack/LCDBlocking.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART2TCP_BRIDGE) 
.................... 	#include "TCPIP Stack/UART2TCPBridge.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UART) 
.................... 	#include "TCPIP Stack/UART.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DHCP_CLIENT) || defined(STACK_USE_DHCP_SERVER) 
.................... 	#include "TCPIP Stack/DHCP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) || defined(STACK_USE_DNS_SERVER) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
.................... 	#include "TCPIP Stack/MPFS2.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_FTP_SERVER) 
.................... 	#include "TCPIP Stack/FTP.h" 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_HTTP2_SERVER) 
.................... 	#ifdef STACK_USE_MDD 
.................... 		#include "TCPIP Stack/FileSystem.h" 
.................... 		#include "TCPIP Stack/_HTTP2.h" 
.................... 	#else 
.................... 		#include "TCPIP Stack/HTTP2.h" 
.................... 	#endif 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT) 
.................... 	#include "TCPIP Stack/ICMP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) 
.................... 	#include "TCPIP Stack/Announce.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNMP_SERVER) 
.................... 	#include "TCPIP Stack/SNMP.h" 
.................... 	#include "mib.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_NBNS) 
.................... 	#include "TCPIP Stack/NBNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DNS) 
.................... 	#include "TCPIP Stack/DNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_DYNAMICDNS_CLIENT) 
.................... 	#include "TCPIP Stack/DynDNS.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TELNET_SERVER) 
.................... 	#include "TCPIP Stack/Telnet.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP_CLIENT) 
.................... 	#include "TCPIP Stack/SMTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
.................... 	#include "TCPIP Stack/TFTPc.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_REBOOT_SERVER) 
.................... 	#include "TCPIP Stack/Reboot.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
.................... 	#include "TCPIP Stack/SNTP.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_UDP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/UDPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TCP_PERFORMANCE_TEST) 
.................... 	#include "TCPIP Stack/TCPPerformanceTest.h" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SSL) 
.................... 	#include "TCPIP Stack/SSL.h" 
.................... #endif 
....................  
.................... #if defined(WF_CS_TRIS) 
....................     #include "TCPIP Stack/WFMac.h" 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #if defined(STACK_USE_MPFS) 
....................  
.................... #ifndef debug_mpfs 
....................    #define debug_mpfs(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t) 
....................    #define debug_mpfs_putc(c) 
.................... #endif 
....................  
.................... // This file system supports short file names i.e. 8 + 3. 
.................... #define MAX_FILE_NAME_LEN   (12u) 
....................  
.................... #define MPFS_DATA          (0x00u) 
.................... #define MPFS_DELETED       (0x01u) 
.................... #define MPFS_DLE           (0x03u) 
.................... #define MPFS_ETX           (0x04u) 
....................  
.................... /* 
....................    If you want the entries in the MPFS .bin file to not have any offset, and 
....................    instead have MPFSOpen() return the entry with MPFS_Start start added to it, 
....................    then define MPFS_RETURN_OFFSET.  CCS added this option so that a universal 
....................    .bin could be created that would be portable to several different memory 
....................    types. 
....................     
....................    If you do not define this option, then you have to use the /r option with 
....................    the MPFS generator tool to add the offset in entry. 
.................... */ 
.................... #define MPFS_RETURN_OFFSET 
....................  
.................... /* 
....................  * MPFS Structure: 
....................  * 
....................  * MPFS_Start: 
....................  *      <MPFS_DATA><Address1><FileName1> 
....................  *      <MPFS_DATA><Address2><FileName2> 
....................  *      ... 
....................  *      <MPFS_ETX><Addressn><FileNamen> 
....................  * Address1: 
....................  *      <Data1>[<Data2>...<Datan>]<MPFS_ETX><MPFS_INVALID> 
....................  *      ... 
....................  * 
....................  * Note: If File data contains either MPFS_DLE or MPFS_ETX 
....................  *       extra MPFS_DLE is stuffed before that byte. 
....................  */ 
.................... #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH) || defined(__PCD__) 
....................    /* __CCS__ __PCD__ change - when using program memory also pack it, i  
....................       am guessing their tool for putting image into const array in C/progmemory 
....................       also stores it unpacked */ 
....................  #if defined(__PCD__) //__PCH__ __PCD__ __CCS__ change 
....................    typedef struct __attribute__((__packed__)) _MPFS_ENTRY 
....................    { 
....................        BYTE Flag; 
....................        MPFS Address; 
....................        BYTE Name[MAX_FILE_NAME_LEN]; 
....................    } MPFS_ENTRY; 
....................    static DWORD ReadProgramMemory(DWORD address); 
....................  #else 
....................    typedef struct  _MPFS_ENTRY 
....................    { 
....................        BYTE Flag __attribute__((__packed__)); 
....................        MPFS Address __attribute__((__packed__)); 
....................        BYTE Name[MAX_FILE_NAME_LEN] __attribute__((__packed__)); 
....................    } MPFS_ENTRY; 
....................  #endif 
.................... #else   //Use program memory 
....................    typedef struct  _MPFS_ENTRY 
....................    { 
....................        BYTE Flag; 
....................        MPFS Address; 
....................        BYTE Name[MAX_FILE_NAME_LEN]; 
....................    } MPFS_ENTRY; 
....................    #if defined(__C30__) 
....................       static DWORD ReadProgramMemory(DWORD address); 
....................    #endif 
.................... #endif 
....................  
.................... static union 
.................... { 
....................     struct 
....................     { 
....................         unsigned char bNotAvailable : 1; 
....................     } bits; 
....................     BYTE Val; 
.................... } mpfsFlags; 
....................  
.................... BYTE mpfsOpenCount; 
....................  
.................... #if !defined(MPFS_USE_EEPROM) && !defined(MPFS_USE_SPI_FLASH) 
....................    // An address where MPFS data starts in program memory. 
....................   #if !defined(__PCH__) && !defined(__PCD__) //ccs will use #import 
....................     extern ROM MPFS_ENTRY MPFS_Start[]; 
....................   #endif 
.................... #else 
....................    #define MPFS_Start     MPFS_RESERVE_BLOCK 
.................... #endif 
....................  
.................... MPFS _currentHandle; 
.................... MPFS _currentFile; 
.................... WORD _currentCount; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE, if MPFS Storage access is initialized and 
....................  *                          MPFS is ready to be used. 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL MPFSInit(void) 
.................... { 
....................    debug_mpfs(debug_mpfs_putc, "\r\nMPFSInit()"); 
....................     mpfsOpenCount = 0; 
....................     mpfsFlags.Val = 0; 
....................  
.................... #if defined(MPFS_USE_EEPROM) 
....................     // Initialize the EEPROM access routines. 
....................     XEEInit(); 
.................... #elif defined(MPFS_USE_SPI_FLASH) 
....................    // Initialize the SPI Flash access routines. 
....................    SPIFlashInit(); 
.................... #endif 
....................  
....................     return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSOpen(BYTE* file) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           file        - NULL terminated file name. 
....................  * 
....................  * Output:          A handle if file is found 
....................  *                  MPFS_INVALID if file is not found. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... MPFS MPFSOpen(BYTE* file) 
.................... { 
....................     MPFS_ENTRY entry; 
....................     MPFS FAT; 
....................     BYTE fileNameLen; 
....................      
....................     debug_mpfs(debug_mpfs_putc, "\r\nMPFSOpen() '%s' ", file); 
....................  
....................     if( mpfsFlags.bits.bNotAvailable ) 
....................     { 
....................         debug_mpfs(debug_mpfs_putc, "NOT AVAILABLE"); 
....................         return MPFS_NOT_AVAILABLE; 
....................     } 
....................  
.................... #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH) 
....................     FAT = MPFS_Start; 
.................... #else 
....................     FAT = (MPFS)MPFS_Start; 
.................... #endif 
....................  
....................     // If string is empty, do not attempt to find it in FAT. 
....................     if ( *file == '\0' ) 
....................         return MPFS_INVALID; 
....................  
....................     //debug_mpfs("p1='%s'0x%LX ", file, file); 
....................  
....................     file = (BYTE*)strupr((char*)file); 
....................      
....................     //debug_mpfs("p2='%s'0x%LX ", file, file); 
....................  
....................     debug_mpfs(debug_mpfs_putc, "START=0x%LX ", FAT); 
....................  
....................     for(;;) 
....................     { 
....................         // Bring current FAT entry into RAM. 
....................       #if defined(MPFS_USE_EEPROM) 
....................            XEEReadArray(FAT, (unsigned char*)&entry, sizeof(entry)); 
....................       #elif defined(MPFS_USE_SPI_FLASH) 
....................            SPIFlashReadArray(FAT, (BYTE*)&entry, sizeof(entry)); 
....................       #else 
....................          #if defined(__C30__) 
....................               memcpypgm2ram(&entry, (ROM void*)(WORD)FAT, sizeof(entry)); 
....................          #else 
....................               memcpypgm2ram(&entry, (ROM void*)FAT, sizeof(entry)); 
....................          #endif 
....................       #endif 
....................  
....................        debug_mpfs(debug_mpfs_putc, "FLAG=0x%X ", entry.Flag); 
....................  
....................         // Make sure that it is a valid entry. 
....................         if (entry.Flag == MPFS_DATA) 
....................         { 
....................             // Does the file name match ? 
....................             fileNameLen = strlen((char*)file); 
....................              
....................             if ( fileNameLen > MAX_FILE_NAME_LEN ) 
....................                 fileNameLen = MAX_FILE_NAME_LEN; 
....................  
....................             //debug_mpfs("f='%s' (%u) vs '%s' ", entry.Name, fileNameLen, file); 
....................  
....................             if( memcmp((void*)file, (void*)entry.Name, fileNameLen) == 0 ) 
....................             { 
....................              #if defined(__PCD__) 
....................                #warning 4.121 temporary bug fix 
....................                memcpy(&_currentFile, &entry.Address, 4); 
....................               #if defined(MPFS_RETURN_OFFSET) 
....................                 _currentFile += MPFS_Start; 
....................               #endif 
....................                 mpfsOpenCount++; 
....................                 debug_mpfs(debug_mpfs_putc, "found_0x%LX ", _currentFile); 
....................                 return _currentFile; 
....................              #else 
....................               #if defined(MPFS_RETURN_OFFSET) 
....................                 entry.Address += MPFS_Start; 
....................               #endif 
....................                 _currentFile = (MPFS)entry.Address; 
....................                 mpfsOpenCount++; 
....................                 debug_mpfs(debug_mpfs_putc, "found_0x%LX ", _currentFile); 
....................                 return entry.Address; 
....................              #endif 
....................             } 
....................  
....................             // File does not match.  Try next entry... 
....................             FAT += sizeof(entry); 
....................         } 
....................         else if ( entry.Flag == MPFS_ETX ) 
....................         { 
....................             #warning 4.121 temporary bug fix 
....................             unsigned int32 entry_Address; 
....................             memcpy(&entry_Address, &entry.Address, 4); 
....................             if ( entry_Address != (MPFS)MPFS_INVALID ) 
....................             { 
....................                 FAT = (MPFS)entry_Address; //original, doesn't work 4.121 pcd 
....................                 debug_mpfs(debug_mpfs_putc, "(etx 0x%LX) ", FAT); 
....................             } 
....................             else 
....................             { 
....................                 debug_mpfs(debug_mpfs_putc, "invalid_etx "); 
....................                 break; 
....................             } 
....................         } 
....................        else 
....................        { 
....................            debug_mpfs(debug_mpfs_putc, "invalid_flag "); 
....................            return (MPFS)MPFS_INVALID; 
....................        } 
....................     } 
....................     debug_mpfs(debug_mpfs_putc, "not_found "); 
....................     return (MPFS)MPFS_INVALID; 
.................... } 
....................  
.................... MPFS MPFSOpenROM(ROM BYTE* file)  
.................... { 
....................    BYTE nameRAM[MAX_FILE_NAME_LEN+1]; 
....................     
....................    memcpypgm2ram(nameRAM, (ROM void*)file, strlenpgm((ROM char*)file)); 
....................    nameRAM[strlenpgm((ROM char*)file)] = '\0'; 
....................     
....................    return MPFSOpen(nameRAM); 
.................... }    
....................  
.................... /********************************************************************* 
....................  * Function:        void MPFSClose(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           handle      - File handle to be closed 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void MPFSClose(void) 
.................... { 
....................     debug_mpfs(debug_mpfs_putc, "\r\nMPFSClose()"); 
....................     _currentCount = 0; 
....................     mpfsFlags.bits.bNotAvailable = FALSE; 
....................     if ( mpfsOpenCount ) 
....................         mpfsOpenCount--; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSGetBegin(MPFS hFile) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  * 
....................  * Input:           hFile      - handle of file that is to be read 
....................  * 
....................  * Output:          TRUE if successful 
....................  *                  !TRUE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS storage media for subsequent reads. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
.................... BOOL MPFSGetBegin(MPFS hFile) 
.................... { 
....................     _currentHandle = hFile; 
....................     return (XEEBeginRead(hFile) == XEE_SUCCESS); 
.................... } 
.................... #endif 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE MPFSGet(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  *                  MPFSGetBegin() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Data byte from current address. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Reads a byte from current address. 
....................  * 
....................  * Note:            Caller must call MPFSIsEOF() to check for end of 
....................  *                  file condition 
....................  ********************************************************************/ 
.................... BYTE MPFSGet(void) 
.................... { 
....................     BYTE t; 
....................      
....................    #if defined(MPFS_USE_EEPROM) 
....................       t = XEERead(); 
....................       _currentHandle++; 
....................    #elif defined(MPFS_USE_SPI_FLASH) 
....................       //SPIFlashReadArray(_currentHandle++, (BYTE*)&t, 1);  //orig 
....................       SPIFlashReadArray(_currentHandle, (BYTE*)&t, 1);   //ccs workaround 
....................       _currentHandle++; //ccs workaround 
....................    #else 
....................       #if defined(__C30__) && !defined(__PCD__) //__CCS__ change 
....................          { 
....................             DWORD_VAL i; 
....................     
....................             // The uppermost byte, ((DWORD_VAL*)&_currentHandle)->v[3]), is the byte lane to read from. 
....................             // 16 bit PICs have a 24 bit wide Flash program word.  Bytes 0-2 are the actual address, but  
....................             // odd addresses aren't implemented. 
....................             i.Val = ReadProgramMemory(_currentHandle & 0x00FFFFFF); 
....................             t = i.v[((DWORD_VAL*)&_currentHandle)->v[3]++]; 
....................             if(((DWORD_VAL*)&_currentHandle)->v[3] >= 3) 
....................             { 
....................                _currentHandle = (_currentHandle + 2) & 0x00FFFFFF; 
....................             } 
....................          } 
....................       #else 
....................           //t = (BYTE)*_currentHandle; //__ccs__ change because MPFS isn't rom pointer 
....................           memcpypgm2ram(&t, _currentHandle, 1); //__ccs__ change because MPFS isn't rom pointer 
....................           _currentHandle++; 
....................       #endif 
....................    #endif 
....................  
....................     if(t == MPFS_DLE) 
....................     { 
....................       #if defined(MPFS_USE_EEPROM) 
....................           t = XEERead(); 
....................           _currentHandle++; 
....................       #elif defined(MPFS_USE_SPI_FLASH) 
....................          //SPIFlashReadArray(_currentHandle++, (BYTE*)&t, 1); //orig 
....................          SPIFlashReadArray(_currentHandle, (BYTE*)&t, 1);   //ccs workaround 
....................          _currentHandle++; //ccs workaround 
....................       #else 
....................          #if defined(__C30__) && !defined(__PCD__) //__CCS__ change 
....................             { 
....................                DWORD_VAL i; 
....................        
....................             // The uppermost byte, ((DWORD_VAL*)&_currentHandle)->v[3]), is the byte lane to read from. 
....................             // 16 bit PICs have a 24 bit wide Flash program word.  Bytes 0-2 are the actual address, but  
....................             // odd addresses aren't implemented. 
....................             i.Val = ReadProgramMemory(_currentHandle & 0x00FFFFFF); 
....................             t = i.v[((DWORD_VAL*)&_currentHandle)->v[3]++]; 
....................             if(((DWORD_VAL*)&_currentHandle)->v[3] >= 3) 
....................             { 
....................                _currentHandle = (_currentHandle + 2) & 0x00FFFFFF; 
....................             } 
....................             } 
....................          #else 
....................              //t = (BYTE)*_currentHandle; //__ccs__ change because MPFS isn't rom pointer 
....................              memcpypgm2ram(&t, _currentHandle, 1); //__ccs__ change because MPFS isn't rom pointer 
....................              _currentHandle++; 
....................          #endif 
....................       #endif 
....................     } 
....................     else if(t == MPFS_ETX) 
....................     { 
....................         _currentHandle = MPFS_INVALID; 
....................     } 
....................  
....................    //printf(UserPutc, " ret=%X\r\n", t); 
....................     return t; 
.................... } 
....................  
....................  
.................... #if defined(__C30__) && !defined(MPFS_USE_EEPROM) 
.................... /********************************************************************* 
....................  * Function:        static DWORD ReadProgramMemory(DWORD address) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           Program memory address to read from.  Should be  
....................  *               an even number. 
....................  * 
....................  * Output:          Program word at the specified address.  For the  
....................  *               PIC24, dsPIC, etc. which have a 24 bit program  
....................  *               word size, the upper byte is 0x00. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Modifies and restores TBLPAG.  Make sure that if  
....................  *               using interrupts and the PSV feature of the CPU  
....................  *               in an ISR that the TBLPAG register is preloaded  
....................  *               with the correct value (rather than assuming  
....................  *               TBLPAG is always pointing to the .const section. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static DWORD ReadProgramMemory(DWORD address)  
.................... { 
....................    DWORD dwResult; 
....................    WORD wTBLPAGSave; 
....................  
....................    wTBLPAGSave = TBLPAG; 
....................    TBLPAG = ((WORD*)&address)[1]; 
....................    ((WORD*)&dwResult)[1] = __builtin_tblrdh((WORD)address); 
....................    ((WORD*)&dwResult)[0] = __builtin_tblrdl((WORD)address); 
....................    TBLPAG = wTBLPAGSave; 
....................  
.................... //printf("[0x%LX=%LX] ", address, dwResult); 
....................  
....................    return dwResult; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSGetEnd(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() != MPFS_INVALID && 
....................  *                  MPFSGetBegin() = TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current mpfs handle. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Ends on-going read cycle. 
....................  *                  MPFS handle that is returned must be used 
....................  *                  for subsequent begin gets.. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
.................... MPFS MPFSGetEnd(void) 
.................... { 
....................     XEEEndRead(); 
....................     return _currentHandle; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSFormat(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A valid MPFS handle that can be used for MPFSPut 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS image to get re-written 
....................  *                  Declares MPFS as in use. 
....................  * 
....................  * Note:            MPFS will be unaccessible until MPFSClose is 
....................  *                  called. 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH) //ccs added this condition 
.................... MPFS MPFSFormat(void) 
.................... { 
....................    debug_mpfs(debug_mpfs_putc, "\r\nMPFSFormat() "); 
....................     mpfsFlags.bits.bNotAvailable = TRUE; 
....................    #if defined(MPFS_USE_SPI_FLASH) 
....................       SPIFlashBeginWrite(MPFS_RESERVE_BLOCK); 
....................    #endif 
....................     return (MPFS)MPFS_RESERVE_BLOCK; 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSPutBegin(MPFS handle) 
....................  * 
....................  * PreCondition:    MPFSInit() and MPFSFormat() are already called. 
....................  * 
....................  * Input:           handle  - handle to where put to begin 
....................  * 
....................  * Output:          TRUE if successful 
....................  *                  !TRUE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Prepares MPFS image to get re-written 
....................  * 
....................  * Note:            MPFS will be unaccessible until MPFSClose is 
....................  *                  called. 
....................  ********************************************************************/ 
.................... #if defined(MPFS_USE_EEPROM) 
.................... BOOL MPFSPutBegin(MPFS handle) 
.................... { 
....................     //_currentCount = 0; 
....................     _currentHandle = handle; 
....................     _currentCount = (BYTE)handle; 
....................     _currentCount &= (MPFS_WRITE_PAGE_SIZE-1); 
....................     return (XEEBeginWrite(handle) == XEE_SUCCESS); 
.................... } 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSPut(BYTE b) 
....................  * 
....................  * PreCondition:    MPFSFormat() or MPFSCreate() must be called 
....................  *                  MPFSPutBegin() is already called. 
....................  * 
....................  * Input:           b       - data to write. 
....................  * 
....................  * Output:          TRUE if successfull 
....................  *                  !TRUE if failed. 
....................  * 
....................  * Side Effects:    Original MPFS handle is no longer valid. 
....................  *                  Updated MPFS handle must be obtained by calling 
....................  *                  MPFSPutEnd(). 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Actual write may not get started until internal 
....................  *                  write page is full.  To ensure that previously 
....................  *                  data gets written, caller must call MPFSPutEnd() 
....................  *                  after last call to MPFSPut(). 
....................  ********************************************************************/ 
.................... BOOL MPFSPut(BYTE b) 
.................... { 
.................... #if defined(MPFS_USE_EEPROM) 
....................     if ( XEEWrite(b) ) 
....................         return FALSE; 
....................  
....................     _currentCount++; 
....................     _currentHandle++; 
....................     if ( _currentCount >= MPFS_WRITE_PAGE_SIZE ) 
....................     { 
....................         MPFSPutEnd(); 
....................         XEEBeginWrite(_currentHandle); 
....................     } 
.................... #elif defined(MPFS_USE_SPI_FLASH) 
....................    SPIFlashWrite(b); 
.................... #endif 
....................     return TRUE; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSPutEnd(void) 
....................  * 
....................  * PreCondition:    MPFSPutBegin() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Up-to-date MPFS handle 
....................  * 
....................  * Side Effects:    Original MPFS handle is no longer valid. 
....................  *                  Updated MPFS handle must be obtained by calling 
....................  *                  MPFSPutEnd(). 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Actual write may not get started until internal 
....................  *                  write page is full.  To ensure that previously 
....................  *                  data gets written, caller must call MPFSPutEnd() 
....................  *                  after last call to MPFSPut(). 
....................  ********************************************************************/ 
.................... MPFS MPFSPutEnd(void) 
.................... { 
....................    debug_mpfs(debug_mpfs_putc, "\r\nMPFSPutEnd() "); 
.................... #if defined(MPFS_USE_EEPROM) 
....................     _currentCount = 0; 
....................     XEEEndWrite(); 
....................     while(XEEIsBusy()); 
.................... #elif defined(MPFS_USE_SPI_FLASH) 
....................    SPIFlashStopWrite(); 
.................... #endif 
....................     return _currentHandle; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSSeek(MPFS offset) 
....................  * 
....................  * PreCondition:    MPFSGetBegin() is already called. 
....................  * 
....................  * Input:           offset      - Offset from current pointer 
....................  * 
....................  * Output:          New MPFS handle located to given offset 
....................  * 
....................  * Side Effects:    None. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None. 
....................  ********************************************************************/ 
.................... MPFS MPFSSeek(MPFS offset) 
.................... { 
....................     MPFS i; 
....................  
....................     MPFSGetBegin(_currentFile); 
....................  
....................     i = (MPFS)0; 
....................     while(i++ != offset) 
....................         MPFSGet(); 
....................  
....................     MPFSGetEnd(); 
....................  
....................     return _currentHandle; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL MPFSGetLong(DWORD *ul) 
....................  * 
....................  * PreCondition:    MPFSOpen() and MPFSBeginGet() 
....................  * 
....................  * Input:           ul: pointer to an DWORD to read 
....................  * 
....................  * Output:          TRUE on success 
....................  *               FALSE on EOF 
....................  *  
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Reads an DWORD value from an MPFS file 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL MPFSGetLong(DWORD *ul) 
.................... { 
....................    BYTE* b = (BYTE*)ul; 
....................    *(b) = MPFSGet();    
....................    if(MPFSIsEOF()) 
....................       return FALSE; 
....................    *(b+1) = MPFSGet();    
....................    *(b+2) = MPFSGet();    
....................    *(b+3) = MPFSGet();    
....................  
....................    return TRUE; 
.................... } 
....................  
.................... #endif //#if defined(STACK_USE_MPFS) 
.................... #endif //__MPFS_C 
....................  
.................... #endif 
....................  
.................... #if (defined(STACK_USE_HTTP2) || defined(STACK_USE_HTTP2_SERVER)) && !defined(__HTTP2_C) 
....................     #include "HTTP2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_HTTP) || defined(STACK_USE_HTTP_SERVER) 
....................     #include "HTTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP1_SERVER) 
....................    #include "ccs_HTTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_HTTP2_SERVER) 
....................    #include "ccs_HTTP2.c" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///                              HTTP2.C 
.................... /// 
.................... /// Simple webserver for the Microchip TCP/IP stack. Using web pages 
.................... /// stored on a MultiMediaCard. 
.................... /// NOTE: THIS IS A DIFFERENT HTTP.C THAN WHAT MICROCHIP PROVIDES 
.................... /// 
.................... /// **** CONFIGURATION **** 
.................... /// 
.................... /// STACK_USE_HTTP - Define this to be true before you include stacktsk.c 
.................... ///        in your application.  Defining this to be true will cause 
.................... ///        the stack to include the HTTP portion and execute the init 
.................... ///        and process any HTTP tasks. 
.................... /// 
.................... /// 
.................... /// STACK_USE_HTTP2 - Same as STACK_USE_HTTP except this will cause 
.................... ///         web pages to be loaded from files stored on the MMC, not 
.................... ///        stored in program memory. 
.................... /// 
.................... /// HTTP_USE_AUTHENTICATION - If set to TRUE (default is FALSE), you can 
.................... ///      have some websites password protected.  In your file system (FAT 
.................... ///      or MPFS) create a new file at the root called 'htaccess.txt'.  The 
.................... ///      format of this file should be as follows: 
.................... ///         user|password|file1|file2|file3 
.................... ///      You can password protect entire directories (if your file system  
.................... ///      provides directory support).  To password protect the entire file 
.................... ///      system then use / as your filename.  Even though you can provide a 
.................... ///      user name and password into htaccess.txt file, the HTTP stack will also 
.................... ///      call http_check_authentication() to verify the username and password. 
.................... ///      It will check both locations, and if the username/password from the 
.................... ///      file matches the user input, or http_check_authentication() returns 
.................... ///      TRUE then authentication is granted.  The reason it checks both is in 
.................... ///      case you want ot password protect a file in the field without having 
.................... ///      to re-program the firmware, you just have to modify htaccess.txt to 
.................... ///      add authentication.  If you want to have the HTTP stack ignore the 
.................... ///      username/password from htaccess.txt then leave those fields blank. 
.................... /// 
.................... ///      If authentication fails the webserver will display the error401.htm 
.................... ///      page. 
.................... /// 
.................... /// HTTP_PORT - The TCP/IP port the HTTP server will listen to for HTTP 
.................... ///        connections. 
.................... /// 
.................... /// HTTP_NUM_SOCKETS - Number of sockets the stack will open for the 
.................... ///        HTTP server.  You probably will be fine with just 1.  The 
.................... ///        more sockets you use the more RAM is used to hold buffers 
.................... ///        and state configuration. 
.................... /// 
.................... /// HTTP_GET_PARAM_MAX_SIZE - This defines the maximum size of several 
.................... ///        buffers.  This limits the size of your GET or POST requests 
.................... ///        and all CGI POST data: 
.................... ///            If using GET, then max amount of cgi data is this value 
.................... ///            minus everything else on the initial GET command (which 
.................... ///            also includes the filename).  I believe the max specified 
.................... ///            by W3C is 255. 
.................... ///            If using POST, then this is the maximum size for one 
.................... ///            key=value pair (including the '=' sign). 
.................... ///        These values do not inlude any escape characters. 
.................... /// 
.................... /// HTTP_ESCAPED_STR_SIZE - Size allocated, per socket, for http_format_char() 
.................... ///         results. 
.................... /// 
.................... /// 
.................... /// HTTP_USE_DOUBLE_ESCAPE - If your HTTP pages need more escape 
.................... ///      chars, set this to TRUE.  When set to TRUE your HTTP pages have 
.................... ///      two escape characters after the %.  An example of each: 
.................... ///         If FALSE: %A 
.................... ///         If TRUE: %0A 
.................... /// 
.................... /// 
.................... /// **** HOW IT WORKS **** 
.................... /// 
.................... /// The TCP/IP stack will open sockets to the desired ports.  It will 
.................... /// then listen for GET or POST requests.  When it gets a GET or POST 
.................... /// request it passes the page request to the callback function 
.................... /// http_get_page() which then returns 0 if the page doesn't exist, or 
.................... /// a pointer to the constant memory area that holds the page in program 
.................... /// memory.  If it was a POST request it waits until the HTTP header is 
.................... /// done and then saves the POST data into a buffer, and passes the 
.................... /// buffer to the callback function http_exec_cgi().  http_exec_cgi() will 
.................... /// parse the CGI post data and act upon it.  When done, the HTTP 
.................... /// server then responds by sending the page.  If the page is to have 
.................... /// variable data, it can be represented by an escape code - %0 or %1 
.................... /// for example.  When the HTTP stack sees such an escape code it calls 
.................... /// the callback function http_format_char() to format the escape code 
.................... /// into the needed variable data (such as ADC readings).  After the 
.................... /// HTTP stack is done sending the request it will close the port. 
.................... /// If the page didn't exist it will send a 404 File 
.................... /// not found error.  If there was a problem/timeout parsing the request 
.................... /// the HTTP stack will send a 500 Internal Server Error response. 
.................... /// 
.................... /// **** CALL BACK FUNCTIONS **** 
.................... /// 
.................... /// Your main application must provide the following callback functions to 
.................... /// fill application dependent needs: 
.................... /// 
.................... /// http_exec_cgi(char* file, char *key, char *val); 
.................... ///    A call-back function provided by your application that processes incoming 
.................... ///    CGI commands.  key and val are the incoming key=val CGI pairs.  file is 
.................... ///    the file name. 
.................... /// 
.................... /// int http_format_char(char* file, char id, char *str, int8 max_ret); 
.................... ///    Given an escaped character in the HTML file, convert to 
.................... ///    variable data.  id is the escaped character, *str is where to save the 
.................... ///    result.  max_ret is the maximum amount of bytes you can save to *str. 
.................... ///    Returns the number of bytes written to *str.  file is 
.................... ///    the file name. 
.................... /// 
.................... /// int1 http_check_authentication(char *fileName, char *user, char *pwd); 
.................... ///   If someone has tried to access a password protected file, the http server 
.................... ///   will call this function so the application can determine if the user has 
.................... ///   access.  fileName is the requested file, user is the username the user 
.................... ///   entered, and pwd is the password the user entered.  The function should 
.................... ///   return TRUE if access is granted, FALSE if not.  This function is only 
.................... ///   needed if HTTP_USE_AUTHENTICATION is defined as TRUE. 
.................... /// 
.................... /// **** LIMITATIONS **** 
.................... /// 
.................... /// When creating web pages with forms, keep your form names (keys) simple 
.................... /// because the HTTP stack does not format the escape characters.  For example, 
.................... /// when sending "Pass+Word" the HTTP client will parse it out as "Pass%2bWord". 
.................... /// The HTTP stack will correctly parse out the escape chars when retrieving 
.................... /// the value, but not the key.  Therefore keep your keys simple. 
.................... /// 
.................... /// 
.................... /// **** FILE SUPPORT *** 
.................... /// Two file systems are supported--FAT on an MMC and Microchip's MPFS on the 
.................... /// external eeprom chip. 
.................... ///  
.................... /// Three files must be supplied on the MMC or MPFS image.  Error404.htm will 
.................... /// be called when the file requested in the URL does not exist.Error500.htm will 
.................... /// be called on an internal server error or timeout.  Internet Exploder requires 
.................... /// that custom error pages be greater than 512 bytes in length or the browser 
.................... /// will insert its own error page in its place.  Index.htm will be called 
.................... /// when no file is explicitly specified in the URL. Other files may be included 
.................... /// on the mmc or MPFS image.  File types that are supported are .htm, .html, 
.................... /// .xml, .txt, .jpg, .png, and .gif. Filenames should be in DOS 8.3 format.  
.................... /// 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// * Author         Date           Comment 
.................... /// *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... /// 
.................... /// * Darren Rook    Apr 12 2007    Added HTTP_USE_AUTHENTICATION. 
.................... ///                                 If file system is missing, will display a 
.................... ///                                 500 error file from memory. 
.................... ///                                 If client gets root (/) and index.htm is 
.................... ///                                 missing, show 404 page. 
.................... ///                                 Fixed bug in TCPPutFileParseConst() where 
.................... ///                                 it was checking for EOF after reading a  
.................... ///                                 char, it should check for EOF before reading 
.................... ///                                 from stream. 
.................... /// 
.................... /// * Nick LaBonte   Feb 22 2007    Added support for MPFS 
.................... /// 
.................... /// * Nick LaBonte   Jan 2007       Added MMC file support, removed HTTP_USE_CHUNKS 
.................... /// 
.................... /// * Darren Rook    Oct 05 2006    Bug fix involving POST 
.................... /// 
.................... /// * Darren Rook    Summer 2006    Large parts of this rewritten to fix 
.................... ///                                 many bugs.  The biggest bug is that 
.................... ///                                 it can send pages and receive CGI that 
.................... ///                                 is larger than 1 TCP packet.  Also 
.................... ///                                 added the HTTP_USE_CHUNKS, 
.................... ///                                 HTTP_USE_DOUBLE_ESCAPE and 
.................... ///                                 HTTP_USE_CONTENT_TYPE parameters. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef debug_html 
....................  #define debug_html_putc(c) 
....................  #define debug_html(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... #else 
....................  #define __DO_DEBUG_HTML 
.................... #endif 
....................  
.................... #ifndef debug_mpfs2 
.................... #define debug_mpfs2(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
.................... #error Must define a file system to use 
.................... #endif 
....................  
.................... #ifndef HTTP_ESCAPED_STR_SIZE 
.................... #define HTTP_ESCAPED_STR_SIZE 40 
.................... #endif 
....................  
.................... #ifndef HTTP_SEND_BYTES_PER_CHUNK 
.................... #define HTTP_SEND_BYTES_PER_CHUNK   128 
.................... #endif 
....................  
.................... #ifndef HTTP_INTERRUPT_TASKS 
.................... #define HTTP_INTERRUPT_TASKS() 
.................... #endif 
....................  
.................... #define HTTP_404_ERROR_FNAME "error404.htm" 
.................... #define HTTP_500_ERROR_FNAME "error500.htm" 
.................... #define HTML_INDEX_FNAME "index.htm" 
....................  
.................... #ifndef HTTP_SERVER_HTACCESS_FILE 
.................... #define HTTP_SERVER_HTACCESS_FILE "htaccess.txt" 
.................... #endif 
....................  
.................... //this will be displayed if the http_500_error[] file cannot be found on the 
.................... //file system.  useful if the file system has crashed. 
.................... #define HTML_500_FILE_CONTENTS "<html><body><h1>500 Error</h1><hr><p>Internal server error.</p></body></html>" 
....................  
.................... /* 
.................... Very similar to standard strncpy(), but it adds a null termination on n+1, and n 
.................... is the entire size of the string including null termination. 
.................... */ 
.................... void _strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................    strncpy(s1,s2,n-1); 
....................    s1[n-1]=0; 
.................... } 
....................  
.................... //static int1 FTPWriteMMC = 0; 
....................  
.................... //key=val pair string, & delimited 
.................... void http_parse_cgi_str(char* file, char *cgistr); 
....................  
.................... unsigned int8 http_socket[HTTP_NUM_SOCKETS]; 
....................  
.................... enum { 
....................    HTTP_IGNORE = 0, 
....................    HTTP_LISTEN_WAIT, 
....................    HTTP_CONNECTED, 
....................    HTTP_GET_HEADERS, 
....................    HTTP_CHECK_AUTHENTICATION, 
....................    HTTP_GET_POST, 
....................    HTTP_GET_POST_CONTINUE, 
....................    HTTP_SEND_RESPONSE, 
....................    HTTP_SEND_RESPONSE_CONTINUE, 
....................    HTTP_CLOSE, 
....................    HTTP_CLOSE_WAITING, 
....................    HTTP_CLOSED, 
....................    HTTP_DISABLED = 0xFF, 
.................... } http_state[HTTP_NUM_SOCKETS]; 
....................  
.................... unsigned int FileExists(char *file) 
.................... { 
....................    unsigned int ret=FALSE; 
....................    MPFS handle; 
....................   
....................    handle=MPFSOpen(file); 
....................    if (handle != MPFS_INVALID) 
....................    { 
....................       ret=TRUE; 
....................       MPFSGetEnd();  
....................       MPFSClose(); 
....................    } 
....................   
....................    return(ret); 
.................... } 
....................  
.................... #if HTTP_USE_AUTHENTICATION 
....................    char http_401_error[]="error401.htm"; 
....................  
....................  
.................... /* 
.................... src holds a string in base64 (null terminated), this will convert that string  
.................... to ascii and save to dest (null terminated).  if src is NULL, then it will use 
.................... dest for the source and save the result over source. 
.................... */ 
.................... void Base64ToString(char *dest, char *src) 
.................... { 
....................    unsigned int32 j; 
....................    unsigned int8 i,scr; 
....................     
....................    if (!src) 
....................       src=dest; 
....................     
....................    while(*src) 
....................    { 
....................       j=0; 
....................       for (i=0;i<4;i++) 
....................       { 
....................          scr=*src; 
....................          //printf("'%c'->",scr); 
....................          if (scr) 
....................             src++; 
....................          if ((scr>='A')&&(scr<='Z')) 
....................             scr-='A'; 
....................          else if ((scr>='a')&&(scr<='z')) 
....................             scr+=26-'a'; 
....................          else if ((scr>='0')&&(scr<='9')) 
....................             scr+=52-'0'; 
....................          else if (scr==' ') 
....................             scr=62; 
....................          else if (scr=='/') 
....................             scr=63; 
....................          else 
....................             scr=0; 
....................              
....................          j *= (int32)64; //bit shift left 6 times 
....................          j &= (int32)0xFFFFFFC0; 
....................          j |= scr; 
....................          //printf("%U [%LX]\r\n", scr,j); 
....................       } 
....................       dest[0]=make8(j,2); 
....................       dest[1]=make8(j,1); 
....................       dest[2]=make8(j,0); 
....................       //printf("APPEND: '%c%c%c'\r\n", dest[0],dest[1],dest[2]); 
....................       dest+=3; 
....................    } 
....................    *dest=0; 
.................... } 
....................  
.................... /* 
.................... Reads the htaccess file (already opened in fHandle), saving max chars to 
.................... *result.  If it reads a '|' then it returns FALSE, if it hits EOF then it  
.................... returns TRUE.  If result is NULL then it won't save, it will just point the  
.................... file to the next element. 
.................... */ 
.................... static unsigned int8 HTTPParseHtaccess(MPFS *pFHandle, char *result, unsigned int16 max) 
.................... { 
....................    char c; 
....................    unsigned int8 ret=FALSE; 
....................     
....................    max--;   //save one for null termination 
....................     
....................    do 
....................    { 
....................       if (MPFSIsEOF()) 
....................       { 
....................          ret=TRUE; 
....................          break; 
....................       } 
....................       c =  MPFSGet(); 
....................       if (result && max && (c!='|') && (c>=' ')) 
....................       { 
....................          *result++ = c; 
....................          max--; 
....................       } 
....................    } while(c!='|'); 
....................     
....................    if (result) 
....................       *result = 0; 
....................     
....................    return(ret); 
.................... }    
....................  
.................... /* 
.................... Upon request of a file, this function should be called before serving the file 
.................... to the user.  It checks to see if the file requires authentication, and if it 
.................... does it sees if the user provided username/password combination passes.  *page 
.................... contains the requested page, *user contains the username/password combination 
.................... from the HTTP header (in base64).  If the user hasn't provided a  
.................... username/password then user will be set to NULL.  This function will return  
.................... TRUE if authentication fails, in which case the server will respond with  
.................... Error 401. 
.................... If you are using MPFS, it must be free at this time and be able to open a file 
.................... else the results will be TRUE.   
.................... If the htaccess format is not valid this will always return TRUE. 
.................... If it cannot find htaccess file it will assume that no file requires  
.................... authentication. 
.................... */ 
.................... unsigned int8 HTTPRequiresAuthentication(char *page, char *user) 
.................... { 
....................    static char htaccess[] = HTTP_SERVER_HTACCESS_FILE; 
....................    static char token[]=":"; 
....................    char *pwd; 
....................    MPFS fHandle; 
....................    char userFromFile[30], pwdFromFile[30], fileToCheck[30]; 
....................    unsigned int8 eof,i; 
....................    unsigned int8 ret=TRUE; 
....................  
....................  
....................    //printf("\r\nCHECK FILE '%s'\r\n", page); 
....................    
....................   //#if STACK_USE_MPFS 
....................   #if 0 
....................    if (MPFSIsInUse()) 
....................    { 
....................       //printf("\r\nMPFSINUSE\r\n"); 
....................       return(TRUE); 
....................    } 
....................   #endif 
....................     
....................    fHandle = MPFSOpen(htaccess); 
....................    if (fHandle == MPFS_INVALID) 
....................    { 
....................       //printf("\r\nNOHTACCESS '%s'\r\n", htaccess); 
....................       return(FALSE); 
....................    } 
....................     
....................    MPFSGetBegin(fHandle); 
....................     
....................    if (HTTPParseHtaccess(&fHandle, userFromFile, sizeof(userFromFile))) 
....................       goto __HTTPRequiresAuthentication_Cleanup; 
....................    if (HTTPParseHtaccess(&fHandle, pwdFromFile, sizeof(pwdFromFile))) 
....................       goto __HTTPRequiresAuthentication_Cleanup; 
....................    
....................    for(;;) 
....................    { 
....................       //printf("\r\nFINDING FILE\r\n"); 
....................       eof = HTTPParseHtaccess(&fHandle, fileToCheck, sizeof(fileToCheck)); 
....................             
....................       strupr(fileToCheck); 
....................        
....................       //strip any any whitespace chars at the end of the file 
....................       i=strlen(fileToCheck); 
....................       while(i--) 
....................       { 
....................          if (fileToCheck[i] <= ' ') 
....................             fileToCheck[i]=0; 
....................          else 
....................             break; 
....................       } 
....................  
....................       //printf("\r\nFILE (%U) = '%s'\r\n", eof, fileToCheck); 
....................       if ( 
....................             (fileToCheck[0] == '*') || //wildcard, match all files 
....................             (strcmp(fileToCheck, page)==0) ||  //file is a perfect match 
....................             (  //check for subdirectory 
....................                (fileToCheck[i]=='/') &&   //if file ends in /, it is a directory 
....................                (strstr(page, fileToCheck)==page) 
....................             ) 
....................          ) 
....................       { 
....................          //printf("\r\nCONVERTING 64: '%s'->", user); 
....................          Base64ToString(user, NULL);          
....................          //printf("'%s'\r\n", user); 
....................          user=strtok(user,token); 
....................          pwd=strtok(0,token); 
....................          return 
....................             ( 
....................                !( 
....................                   ( 
....................                      strlen(userFromFile) &&  
....................                      strlen(pwdFromFile) &&  
....................                      (stricmp(userFromFile,user)==0) && 
....................                      (stricmp(pwdFromFile,pwd)==0) 
....................                   ) || 
....................                   http_check_authentication(page,user,pwd) 
....................                 ) 
....................             ); 
....................          //if (user && pwd && (strcmp(user,validUser)==0) && (strcmp(pwd,validPwd)==0)) 
....................          //   ret=FALSE; 
....................          break; 
....................       } 
....................        
....................       if (eof) 
....................       { 
....................          ret=FALSE; 
....................          break; 
....................       }       
....................    } 
....................  
.................... __HTTPRequiresAuthentication_Cleanup: 
....................    MPFSGetEnd(); 
....................    MPFSClose(); 
....................    return(ret); 
.................... } 
.................... #endif //HTTP_USE_AUTHENTICATION 
....................  
.................... //strips out any escape characters that the HTTP client may have inserted. 
.................... // (+ is replaced with space) 
.................... // (%xx is replaced with character representation of xx) 
.................... void http_escape_chars(char *str) 
.................... { 
....................    char new[3]; 
....................    char c; 
....................    char val; 
....................  
....................    new[2]=0; 
....................  
....................    while((c=*str) != 0) 
....................    { 
....................       if (c=='+') 
....................          *str++=' '; 
....................       else if (c=='%') 
....................       { 
....................          memcpy(new, str + 1, 2); 
....................          val = strtoul(new, 0, 16); 
....................          *str++ = val; 
....................          memmove(str, str + 2, strlen(str) - 1); 
....................       } 
....................       else 
....................          str++; 
....................    } 
.................... } 
....................  
.................... void http_parse_cgi_string(char* file, char *ptr) 
.................... { 
....................    char *pKey, *pValue, c; 
....................  
....................    pKey=ptr; 
....................  
....................    for(;;) 
....................    { 
....................       c = *ptr; 
....................       if ((c=='&') || (c==0)) 
....................       { 
....................          *ptr=0; 
....................          http_escape_chars(pKey); 
....................          http_escape_chars(pValue); 
....................          http_exec_cgi(file, pKey, pValue); 
....................          pKey=ptr+1; 
....................          if (c==0) 
....................             break; 
....................       } 
....................       else if (c=='=') 
....................       { 
....................          *ptr=0; 
....................          pValue=ptr+1; 
....................       } 
....................       ptr++; 
....................    } 
.................... } 
....................  
.................... unsigned int8 g_HttpCurrSocket; 
.................... unsigned int8 g_HttpCurrConn; 
....................  
.................... #define tcp_http_tx_left()  TCPIsPutReady(g_HttpCurrSocket) 
....................  
.................... unsigned int tcp_http_putc(char c) 
.................... { 
....................    //putc(c); 
....................    return(TCPPut(g_HttpCurrSocket,c)); 
.................... } 
....................  
.................... MPFS lastHTTPPutConstPos[HTTP_NUM_SOCKETS]; 
.................... char * lastHTTPPutVarPos[HTTP_NUM_SOCKETS]; 
....................  
.................... typedef enum 
.................... { 
....................    MIME_TYPE_HTM, 
....................    MIME_TYPE_HTML, 
....................    MIME_TYPE_TXT, 
....................    MIME_TYPE_XML, 
....................    MIME_TYPE_GIF, 
....................    MIME_TYPE_JPG, 
....................    MIME_TYPE_PNG, 
....................    MIME_TYPE_ICO 
.................... } MIME_T; 
....................  
.................... //static int1 is_image[HTTP_NUM_SOCKETS]; 
.................... MIME_T g_HTTPMimeType[HTTP_NUM_SOCKETS]; 
.................... #if HTTP_LAST_MODIFIED_CHECK 
....................  int1 g_lastModifiedCheck[HTTP_NUM_SOCKETS]; 
.................... #endif 
.................... #define IsImage(t)   (g_HTTPMimeType[t]>=MIME_TYPE_GIF) 
....................  
.................... #define HTTP_NUM_MIME_TYPES   8 
....................  
.................... ROM char gc_MimeTypes[HTTP_NUM_MIME_TYPES][5] =  //filename extensions 
.................... { 
....................    "htm", 
....................    "html", 
....................    "txt", 
....................    "xml", 
....................    "gif", 
....................    "jpg", 
....................    "png", 
....................    "ico" 
.................... }; 
....................  
.................... ROM char gc_MimeTypesHeader[HTTP_NUM_MIME_TYPES][13] = 
.................... { 
....................    "text/html", 
....................    "text/html", 
....................    "text/plain", 
....................    "text/xml", 
....................    "image/gif", 
....................    "image/jpeg", 
....................    "image/png", 
....................    "image/x-icon" 
.................... }; 
....................  
.................... MIME_T HTTPFindMimeType(char *fname) 
.................... { 
....................    unsigned int8 i; 
....................    char str[5]; 
....................    char extension[5]; 
....................  
....................    if(strlen(strchr(fname,'.'))<6) 
....................    { 
....................       strncpy (extension, (strchr(fname,  '.'))+1,  4); 
....................    } 
....................    else 
....................       extension[0] = 0; 
....................  
....................  
....................    for (i=0; i<HTTP_NUM_MIME_TYPES; i++) 
....................    { 
....................       //sprintf(str, "%s", gc_MimeTypes[i]); 
....................       strcpypgm2ram(str, &gc_MimeTypes[i][0]); 
....................       debug_html(debug_html_putc, "\r\nHTML Ext check %u '%s' '%s' vs '%s'(0x%LX) ", i, fname, extension, str, &gc_MimeTypes[i][0]); 
....................       if (stricmp(str, extension) == 0) 
....................          return(i); 
....................    } 
....................     
....................    return(MIME_TYPE_TXT); 
.................... } 
....................  
.................... typedef enum 
.................... { 
....................    TCP_PUT_CONST_EC_FINISH = 0, 
....................    TCP_PUT_CONST_EC_CONTINUE, 
....................    TCP_PUT_CONST_EC_ESCAPE 
.................... } TCP_PUT_CONST_EC; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileVarChunk(ptr) 
.................... // 
.................... // send a chunked response from ram 
.................... // 
.................... // ptr - data to send (well be sent as an http/1.1 chunk).  It will be updated 
.................... //          with the continue position before exit. 
.................... // 
.................... // Returns a status code: 
.................... //    TCP_PUT_CONST_EC_FINISH - The whole chunk was completed 
.................... //    TCP_PUT_CONST_EC_CONTINUE - The chunk needs to be continued 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //TCP_PUT_CONST_EC TCPPutFileVarChunk(char **retPtr) 
.................... //because of a compiler error this had to be a double pointer an int16, when 
.................... //it should be a char. 
....................  
.................... TCP_PUT_CONST_EC TCPPutFileVarChunk(unsigned int16 **retPtr) 
.................... { 
....................    unsigned int16 txLeft, n; 
....................    char *ptr, ec; 
....................  
....................    ptr=*retPtr; 
....................  
....................    n=strlen(ptr); 
....................     
....................    if (!n){ 
....................       return(TCP_PUT_CONST_EC_FINISH); 
....................    } 
....................  
....................    txLeft = tcp_http_tx_left(); 
....................    
....................    if (n > txLeft) 
....................       ec = TCP_PUT_CONST_EC_CONTINUE;    
....................    else 
....................    { 
....................       txLeft = n; 
....................       ec = TCP_PUT_CONST_EC_FINISH; 
....................    } 
....................  
....................    //TCPPutFileChunkStart(txLeft); 
....................  
....................    while (txLeft--) 
....................       tcp_http_putc(*(ptr++)); 
....................  
....................    //TCPPutFileChunkStop(); 
....................  
....................    *retPtr=ptr; 
....................  
....................    return(ec); 
.................... } 
....................  
....................  
.................... /* 
....................    Allows negative seek offset. 
.................... */ 
.................... void myMPFSSeek(MPFS *handle, signed int16 offset) 
.................... { 
....................     MPFSGetBegin(*handle); 
....................     if(offset < 0){ 
....................       while(offset++!=0){ 
....................           _currentHandle--; 
....................           _currentCount--; 
....................        } 
....................     }else if(offset >0){ 
....................       while(offset--!=0){ 
....................          _currentHandle++; 
....................          _currentCount++; 
....................       } 
....................     } 
....................  
....................    *handle = MPFSGetEnd(); 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        MPFS MPFSFileTell(void) 
....................  * 
....................  * PreCondition:    MPFSOpen() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          beginning of current file 
....................  * 
....................  * Side Effects:    None. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None. 
....................  ********************************************************************/ 
.................... #define MPFSFileTell()  (_currentFile) 
....................  
.................... //Now these are global--not initialized to 0 
.................... //save a couple hundred bytes of ROM this way 
.................... char HTTPbuffer[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
.................... MPFS http_page_req[HTTP_NUM_SOCKETS]; 
....................  
.................... #if HTTP_USE_AUTHENTICATION 
....................  char http_get_cache[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
....................  char http_auth_user[HTTP_NUM_SOCKETS][HTTP_GET_PARAM_MAX_SIZE]; 
.................... #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileParseConst(fstream, n, doSend) 
.................... // 
.................... // Reads file from mmc.  Stops when it reaches an escape sequence, 
.................... // n chars or an end of file 
.................... // 
.................... // fstream - file sream to read (will be sent as an http/1.1 chunk).  The stream 
.................... //        will be updated for the next call. 
.................... // 
.................... // n - max number of chars to read from file.  will save the total number 
.................... //    of chars passed to this pointer. 
.................... // 
.................... // doSend - if TRUE, then send data to TCP socket 
.................... // 
.................... // returns the last char read 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... #if 0 //original slow 
.................... char TCPPutFileParseConst(MPFS *fstream, unsigned int16 *n, int8 doSend, int1 isPix) 
.................... { 
....................    char stopC, checkC; 
....................    unsigned int16 fileSize = 1, max; 
....................    int1 premature = TRUE; 
....................    max = *n; 
....................    MPFSGetBegin(*fstream); 
....................    while (TRUE) 
....................    { 
....................       if(MPFSIsEOF())//EOF 
....................       { 
....................          premature = FALSE; 
....................          break;    
....................       } 
....................       stopC= MPFSGet(); 
....................       if (stopC == '%'&&!isPix) 
....................       { 
....................          checkC= MPFSGet(); 
....................          if (checkC == '%') 
....................          { 
....................             if (fileSize < max) 
....................             { 
....................                if (doSend) 
....................                   tcp_http_putc('%'); 
....................                fileSize++; 
....................             } 
....................             else 
....................                break; 
....................          } 
....................          else 
....................             break;   //ESCAPE 
....................       } 
....................       else 
....................       { 
....................          if (MPFSIsEOF()) 
....................          { 
....................             premature = FALSE; 
....................             break; 
....................          } 
....................          if (((fileSize) < max)) 
....................          { 
....................             //if (doSend&&!fateof(fstream)) 
....................             if (doSend) 
....................             { 
....................                tcp_http_putc(stopC); 
....................             } 
....................             fileSize++; 
....................          } 
....................          else 
....................             break; 
....................       } 
....................       /* 
....................       if(fateof(fstream))//EOF 
....................       { 
....................          premature = FALSE; 
....................          break;    
....................       } 
....................       */ 
....................    } 
....................     
....................    *fstream = MPFSGetEnd(); 
....................    if (premature==TRUE){ 
....................       myMPFSSeek(fstream, -1);  //addy--; 
....................    } 
....................   
....................    *n = fileSize; 
....................    *fstream = MPFSGetEnd(); 
....................    return(stopC); 
.................... } 
.................... #endif 
.................... //new fast 
.................... char TCPPutFileParseConst(MPFS *fstream, unsigned int16 max, int1 isPix) 
.................... { 
....................    char c; 
....................    unsigned int8 *p; 
....................    unsigned int16 readCount; 
....................    int1 escape = FALSE; 
....................     
....................    debug_mpfs2(debug_putc, "\r\nTCPPutFileParseConst() c=%X max=%LX f=%LX p=%U ", g_HttpCurrConn, max, *fstream, isPix); 
....................     
....................    /*  
....................       this will cause httpTask() to only process 128 bytes at 
....................       a time and allow other processes to run while reading 
....................       page from EE. 
....................    */ 
....................    if (max > (unsigned int16)HTTP_SEND_BYTES_PER_CHUNK) 
....................       max = HTTP_SEND_BYTES_PER_CHUNK; 
....................     
....................    MPFSGetBegin(*fstream); 
....................  
....................    while (max && !escape && !MPFSIsEOF()) 
....................    { 
....................       p = &HTTPbuffer[g_HttpCurrConn][0]; 
....................     
....................       readCount = MIN(max, HTTP_GET_PARAM_MAX_SIZE); 
....................     
....................       readCount = MPFSGetBytes(p, readCount); 
....................        
....................       debug_mpfs2(debug_putc, "r=%LX ", readCount); 
....................           
....................       while (readCount && !escape) 
....................       { 
....................          readCount--; 
....................          c = *p++; 
....................          if ((c == '%') && !isPix) 
....................          { 
....................             debug_mpfs2(debug_putc, "+%%="); 
....................             if (readCount) 
....................             { 
....................                readCount--; 
....................                c = *p++; 
....................             } 
....................             else 
....................             { 
....................                c = MPFSGet(); 
....................             } 
....................             debug_mpfs2(debug_putc, "%X", c); 
....................             if (c != '%') 
....................             { 
....................                escape = TRUE; 
....................                debug_mpfs2(debug_putc, "e"); 
....................             } 
....................             debug_mpfs2(debug_putc, " "); 
....................          } 
....................          if (!escape) 
....................          { 
....................             tcp_http_putc(c); 
....................             max--; 
....................          } 
....................       } 
....................       HTTP_INTERRUPT_TASKS(); 
....................    } 
....................        
....................    *fstream = MPFSGetEnd(); 
....................     
....................    if (escape) 
....................    {   
....................       debug_mpfs2(debug_putc, "f1=%LX ", *fstream); 
....................       *fstream = _MpfsEofLoc; 
....................       debug_mpfs2(debug_putc, "fe=%LX ", *fstream); 
....................       c = '%'; 
....................       readCount++; 
....................       myMPFSSeek(fstream, -readCount);  //addy--; 
....................       debug_mpfs2(debug_putc, "r=%LX fr=%LX ", readCount, *fstream); 
....................    } 
....................    else 
....................    { 
....................       c = 0; 
....................    } 
....................  
....................    debug_mpfs2(debug_putc, "c=%X e=%U ", c, escape); 
....................   
....................    return(c); 
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // TCPPutFileConstChunk(*addy) 
.................... // 
.................... // send a chunked response from mmc 
.................... // 
.................... // addy - data to send (well be sent as an http/1.1 chunk).  This address 
.................... //        will be updated for the next call. 
.................... // 
.................... // returns a response: 
.................... //    TCP_PUT_CONST_EC_CONTINUE: we ran out of space to put more data, continue 
.................... //                            from this position on next call. 
.................... //    TCP_PUT_CONST_EC_ESCAPE:   an escape character 
.................... //    TCP_PUT_CONST_EC_FINISH:   we finished reading the chunk, end of file. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... TCP_PUT_CONST_EC TCPPutFileConstChunk(MPFS *retAddy, int1 isPix) 
.................... { 
....................    char stopC; 
....................    unsigned int16 txLeft; 
....................    TCP_PUT_CONST_EC ec; 
....................    MPFSGetBegin(*retAddy); 
....................    txLeft = tcp_http_tx_left(); 
....................  
....................    if (!txLeft) 
....................    { 
....................       debug_mpfs2(debug_putc, "\r\nTCPPutFileConstChunk() txleft=0 "); 
....................       return(TCP_PUT_CONST_EC_CONTINUE); 
....................    } 
....................     
....................    stopC=TCPPutFileParseConst(retAddy, txLeft, isPix); 
....................     
....................    if (stopC == '%'&&!isPix) 
....................    { 
....................       ec = TCP_PUT_CONST_EC_ESCAPE; 
....................    } 
....................    else 
....................    { 
....................       ec = TCP_PUT_CONST_EC_CONTINUE; 
....................    } 
....................     
....................    if(MPFSIsEOF())//EOF 
....................    { 
....................       ec = TCP_PUT_CONST_EC_FINISH; 
....................    } 
....................     
....................    debug_mpfs2(debug_putc, "\r\nTCPPutFileConstChunk() stop=%X isPix=%U ec=%X eof=%U ", stopC, isPix, ec, MPFSIsEOF()); 
....................     
....................    *retAddy = MPFSGetEnd(); 
....................     
....................    return(ec); 
.................... } 
....................  
....................  
.................... #if HTTP_USE_TRIPLE_ESCAPE 
.................... unsigned int16 
.................... #else 
.................... unsigned int8 
.................... #endif 
.................... TCPPutFileConstGetEscape(MPFS* fstream) 
.................... { 
.................... #if HTTP_USE_TRIPLE_ESCAPE 
....................    char str[4]; 
....................    uint16_t ret; 
....................    MPFSGetBegin(*fstream); 
....................    str[0]=MPFSGet(); 
....................    str[1]=MPFSGet(); 
....................    str[2]=MPFSGet(); 
....................    str[3] = 0; 
....................    ret = strtol(str, 0, 16); 
.................... #elif HTTP_USE_DOUBLE_ESCAPE 
....................    char str[3]; 
....................    unsigned int ret; 
....................    MPFSGetBegin(*fstream); 
....................    str[0]=MPFSGet(); 
....................    str[1]=MPFSGet(); 
....................    //myfatseek(fstream, -2); 
....................  
....................    str[2] = 0; 
....................    ret = strtol(str, 0, 16); 
.................... #else 
....................    char ret; 
....................    //printf(UserPutc, "\r\nTCPPutFileConstGetEscape() st=%LX ", *fstream); 
....................    MPFSGetBegin(*fstream); 
....................    ret=MPFSGet(); 
....................    //MPFSGetEnd(fstream); 
....................    //myfatseek(fstream, -1);//"replace" that char to the stream 
.................... #endif 
....................    *fstream = MPFSGetEnd(); 
....................    //printf(UserPutc, "ret=%X end=%LX ", ret, *fstream); 
....................    return(ret); 
.................... } 
....................  
.................... int1 tcp_http_put_file(unsigned int16 errorCode, MPFS* MMCfile, char* fname) 
.................... { 
....................    static char str[HTTP_NUM_SOCKETS][HTTP_ESCAPED_STR_SIZE]; 
....................    char ec; 
....................   #if HTTP_USE_TRIPLE_ESCAPE 
....................    unsigned int16 escaped; 
....................   #else 
....................    unsigned int8 escaped; 
....................   #endif 
....................  
....................    MPFS position;    
....................  
....................    static enum 
....................    { 
....................       HTTP_PUT_FILE_INIT = 0, 
....................       HTTP_PUT_FILE_CONTINUE, 
....................       HTTP_PUT_FILE_CHUNK_END, 
....................       HTTP_PUT_FILE_DONE 
....................    } status[HTTP_NUM_SOCKETS]; 
....................     
....................    MPFSGetBegin(*MMCfile);  
....................       
....................    position = MPFSTell()-MPFSFileTell(); 
....................  
....................    debug_html(debug_html_putc, "\r\n** PUT FILE W%U/S%U '%s' EC=%LU MRK=%LX POS=%LX LASTVAR=%LX STATUS=%U ", g_HttpCurrConn, g_HttpCurrSocket, fname, errorCode, *MMCfile, position, lastHTTPPutVarPos[g_HttpCurrConn], status[g_HttpCurrConn]); 
....................    if(position == 0) 
....................    { 
....................       lastHTTPPutVarPos[g_HttpCurrConn] = 0; 
....................       lastHTTPPutConstPos[g_HttpCurrConn] = *MMCfile; 
....................       status[g_HttpCurrConn] = HTTP_PUT_FILE_CONTINUE; 
....................  
....................     #if HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode); 
....................     #else 
....................       printf(tcp_http_putc,"HTTP/1.1 %LU ", errorCode); 
....................     #endif 
....................  
....................       switch(errorCode) 
....................       { 
....................          case 200: 
....................             printf(tcp_http_putc,"OK"); 
....................             break; 
....................         #if HTTP_LAST_MODIFIED_CHECK 
....................          case 304: 
....................             printf(tcp_http_putc, "Not Modified"); 
....................             break; 
....................         #endif 
....................          case 401: 
....................             printf(tcp_http_putc,"Authorization Required"); 
....................             break; 
....................          case 404: 
....................             printf(tcp_http_putc,"Not Found"); 
....................             break; 
....................          case 500: 
....................             printf(tcp_http_putc,"Server Error"); 
....................             break; 
....................          default: 
....................             break; 
....................       } 
....................       printf(tcp_http_putc, "\r\n"); 
....................        
....................      #if HTTP_USE_AUTHENTICATION 
....................       if (errorCode==401) 
....................          printf(tcp_http_putc, "WWW-Authenticate: Basic realm=\"Authorization Required\"\r\n"); 
....................      #endif 
....................  
....................       printf(tcp_http_putc, "Content-Type: "); 
....................       strcpypgm2ram(&str[g_HttpCurrConn][0], &gc_MimeTypesHeader[g_HTTPMimeType[g_HttpCurrConn]][0]); 
....................       printf(tcp_http_putc, "%s\r\n", str[g_HttpCurrConn]); 
....................        
....................       debug_html(debug_html_putc, " content='%s'(%u) ", str[g_HttpCurrConn], g_HTTPMimeType[g_HttpCurrConn]); 
....................        
....................       if (IsImage(g_HttpCurrConn)) 
....................       { 
....................          printf(tcp_http_putc, "Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT\r\n"); 
....................       } 
....................       else 
....................       { 
....................          printf(tcp_http_putc, "Cache-Control: no-cache\r\n"); 
....................       } 
....................  
....................      #if !HTTP_USE_CHUNKS 
....................       printf(tcp_http_putc, "Connection: close\r\n"); 
....................      #endif 
....................  
....................       printf(tcp_http_putc, "\r\n"); 
....................    } 
....................     
....................   #if HTTP_LAST_MODIFIED_CHECK 
....................    if (errorCode == 304) 
....................    { 
....................       TCPFlush(socket); 
....................       return(TRUE); 
....................    } 
....................   #endif 
....................     
....................    if (errorCode==500) 
....................    { 
....................       sprintf(fname, "%s", HTTP_500_ERROR_FNAME); 
....................       if(!FileExists(fname)) 
....................       { 
....................          printf(tcp_http_putc, "%s", HTML_500_FILE_CONTENTS); 
....................          TCPFlush(g_HttpCurrSocket); 
....................          return(TRUE); 
....................       } 
....................    } 
....................  
....................    debug_mpfs2(debug_putc, "\r\nVAR START ST=%X ", status[g_HttpCurrConn]); 
....................  
....................    if (lastHTTPPutVarPos[g_HttpCurrConn]!=0) 
....................    { 
....................       TCPPutFileVarChunk(&lastHTTPPutVarPos[g_HttpCurrConn]); 
....................       lastHTTPPutVarPos[g_HttpCurrConn] = 0; 
....................    } 
....................  
....................    debug_mpfs2(debug_putc, "\r\nPUT START ST=%X ", status[g_HttpCurrConn]); 
....................  
....................    if (status[g_HttpCurrConn] == HTTP_PUT_FILE_CONTINUE) 
....................    { 
....................       for(;;) 
....................       { 
....................          //printf(UserPutc, "\r\nHTTP Put Const st=%LX ", lastHTTPPutConstPos[g_HttpCurrConn]); 
....................          ec = TCPPutFileConstChunk(&lastHTTPPutConstPos[g_HttpCurrConn], IsImage(g_HttpCurrConn)); 
....................          //printf(UserPutc, "end=%LX\r\n", lastHTTPPutConstPos[g_HttpCurrConn]); 
....................          if (ec == TCP_PUT_CONST_EC_ESCAPE)//&is_image 
....................          { 
....................             HTTP_INTERRUPT_TASKS(); 
....................             escaped = TCPPutFileConstGetEscape(&lastHTTPPutConstPos[g_HttpCurrConn]);//// 
....................             http_format_char(fname, escaped, &str[g_HttpCurrConn][0], (sizeof(str)/HTTP_NUM_SOCKETS)-1); 
....................             lastHTTPPutVarPos[g_HttpCurrConn] = &str[g_HttpCurrConn][0]; 
....................             ec = TCPPutFileVarChunk(&lastHTTPPutVarPos[g_HttpCurrConn]); 
....................             //printf(UserPutc, "\r\n** HTTP PUT VAR ec=%U escape=0x%LX str='%s' start=0x%LX end=0x%LX status=%U", 
....................             debug_html(debug_html_putc, "\r\n** HTTP PUT VAR ec=%U escape=0x%LX str='%s' start=0x%LX end=0x%LX status=%U", 
....................                   ec, 
....................                   escaped, 
....................                   str[g_HttpCurrConn], 
....................                   &str[g_HttpCurrConn][0], 
....................                   lastHTTPPutVarPos[g_HttpCurrConn], 
....................                   status[g_HttpCurrConn] 
....................                ); 
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
....................                lastHTTPPutVarPos[g_HttpCurrConn] = 0; 
....................             else 
....................                break; 
....................          } 
....................          else 
....................          { 
....................             if (ec == TCP_PUT_CONST_EC_FINISH) 
....................                status[g_HttpCurrConn] = HTTP_PUT_FILE_CHUNK_END; 
....................             break; 
....................          } 
....................          //debug_printf(debug_putc, "\r\nHTTP INTR "); 
....................          HTTP_INTERRUPT_TASKS(); 
....................          //debug_printf(debug_putc "DONE "); 
....................          break; 
....................       } 
....................    } 
....................     
....................    debug_mpfs2(debug_putc, "\r\nPUT END ST=%X ", status[g_HttpCurrConn]); 
....................  
....................    if (status[g_HttpCurrConn] == HTTP_PUT_FILE_CHUNK_END) 
....................    { 
....................      #if HTTP_USE_CHUNKS 
....................       if (tcp_http_tx_left() > 8) 
....................       { 
....................          TCPPutFileChunkStart(0); 
....................          TCPPutFileChunkStop(); 
....................          status[which] = HTTP_PUT_FILE_DONE; 
....................       } 
....................      #else 
....................       status[g_HttpCurrConn] = HTTP_PUT_FILE_DONE; 
....................      #endif 
....................    } 
....................  
....................    *MMCfile = MPFSGetEnd(); 
....................    //printf("\r\nFLUSH W%u/S%u/T%u", which,socket,_httpPutcSocket); 
....................    //printf(" RETURN=%U\r\n", ec); 
....................    debug_html(debug_html_putc, "\r\nHTML Flush status=%U ", status[g_HttpCurrConn]); 
....................     
....................    if (status[g_HttpCurrConn] == HTTP_PUT_FILE_DONE) 
....................    { 
....................       TCPFlush(g_HttpCurrSocket); 
....................       return(TRUE); 
....................    } 
....................    else 
....................    { 
....................       return(FALSE); 
....................    } 
.................... } 
....................  
.................... //initializes the HTTP state machine.  called automatically by the TCP/IP stack 
.................... void HTTPInit(void) { 
....................    int8 i; 
....................    //fprintf(USER,"\r\nHTTP OPENING"); 
....................    if (HTTP_PORT != 0) 
....................    { 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
*
1426:  MOVLB  3
1428:  CLRF   x7B
142A:  BTFSC  x7B.7
142C:  BRA    1434
142E:  MOVF   x7B,W
1430:  SUBLW  00
1432:  BNC   14A8
....................       { 
....................          http_state[i]=HTTP_DISABLED; 
1434:  CLRF   03
1436:  MOVF   x7B,W
1438:  ADDLW  08
143A:  MOVWF  FE9
143C:  MOVLW  02
143E:  ADDWFC 03,W
1440:  MOVWF  FEA
1442:  SETF   FEF
....................           
....................          http_socket[i]=TCPOpen(0, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER); 
1444:  CLRF   03
1446:  MOVF   x7B,W
1448:  ADDLW  07
144A:  MOVWF  01
144C:  MOVLW  02
144E:  ADDWFC 03,F
1450:  MOVFF  01,37C
1454:  MOVFF  03,37D
1458:  CLRF   x81
145A:  CLRF   x80
145C:  CLRF   x7F
145E:  CLRF   x7E
1460:  CLRF   x82
1462:  CLRF   x84
1464:  MOVLW  50
1466:  MOVWF  x83
1468:  MOVLW  08
146A:  MOVWF  x85
146C:  MOVLB  0
146E:  BRA    13AE
1470:  MOVFF  37D,FEA
1474:  MOVFF  37C,FE9
1478:  MOVFF  01,FEF
....................          //fprintf(USER,"\r\nHTTP SOCKET=%X", http_socket[i]); 
....................          if (http_socket[i]!=INVALID_SOCKET) 
147C:  CLRF   03
147E:  MOVLB  3
1480:  MOVF   x7B,W
1482:  ADDLW  07
1484:  MOVWF  FE9
1486:  MOVLW  02
1488:  ADDWFC 03,W
148A:  MOVWF  FEA
148C:  MOVF   FEF,W
148E:  SUBLW  FE
1490:  BZ    14A4
....................          { 
....................             http_state[i]=HTTP_LISTEN_WAIT; 
1492:  CLRF   03
1494:  MOVF   x7B,W
1496:  ADDLW  08
1498:  MOVWF  FE9
149A:  MOVLW  02
149C:  ADDWFC 03,W
149E:  MOVWF  FEA
14A0:  MOVLW  01
14A2:  MOVWF  FEF
....................          } 
14A4:  INCF   x7B,F
14A6:  BRA    142A
....................       } 
....................    } 
....................    else 
....................    { 
....................       //fprintf(USER,"\r\nHTTP DISABLED"); 
....................       for (i=0;i<HTTP_NUM_SOCKETS;i++) 
....................       { 
....................             http_state[i]=HTTP_DISABLED; 
....................       } 
....................    } 
14A8:  MOVLB  0
14AA:  GOTO   1508 (RETURN)
.................... } 
....................  
.................... #DEFINE HTTP_INDEX_PAGE_EC 0x01 
.................... #DEFINE HTTP_FILE_PAGE_EC    0x02 
.................... #DEFINE HTTP_404_PAGE_EC    0x00 
.................... #DEFINE HTTP_401_PAGE_EC    0xFE 
.................... #DEFINE HTTP_500_PAGE_EC    0xFF 
....................  
.................... void HTTPServer(void) { 
....................    static char tokens_header[]=" "; 
....................    static char tokens_get[]="?"; 
....................    static char http_get_str[]="GET"; 
....................    static char http_post_str[]="POST"; 
....................    static char http_len_str[]="Content-Length:"; 
....................    unsigned int8 j =0, l=0; 
....................     
....................    char index[]="/"; 
....................    static char page[HTTP_NUM_SOCKETS][20]; 
....................    MPFS fstream; 
....................    
....................   #if defined(__DO_DEBUG_HTML) 
....................    static unsigned int8 debug; 
....................   #endif 
....................  
....................    //static char http_keepalive_str[]="keep-alive"; 
....................    //static char http_connection_str[]="Connection"; 
....................  
....................  
....................  
....................    static unsigned int8 i[HTTP_NUM_SOCKETS]; 
....................    static enum {HTTP_REQ_GET=1, HTTP_REQ_POST=2, HTTP_REQ_UNKOWN=0} http_cmd[HTTP_NUM_SOCKETS]; 
....................     
....................    static unsigned int16 http_error_code[HTTP_NUM_SOCKETS]; 
....................    static unsigned int16 http_post_len[HTTP_NUM_SOCKETS]; 
....................    static TICK http_timer[HTTP_NUM_SOCKETS]; 
....................   
....................  #if HTTP_USE_AUTHENTICATION 
....................    static char http_auth_str[]="Authorization:"; 
....................  #endif 
....................  
....................    int1 doneSend, postContinue; 
....................  
....................    char c, *pKey, *pValue; 
....................    //unsigned int8 hs, currSocket; 
....................  
....................    for (g_HttpCurrConn=0; g_HttpCurrConn<HTTP_NUM_SOCKETS; g_HttpCurrConn++) 
....................    {      
....................       if (http_state[g_HttpCurrConn]==HTTP_DISABLED) 
....................          return; 
....................  
....................       g_HttpCurrSocket = http_socket[g_HttpCurrConn]; 
....................  
....................       if (!TCPIsConnected(g_HttpCurrSocket)) 
....................          http_state[g_HttpCurrConn]=HTTP_LISTEN_WAIT; 
....................  
....................       switch(http_state[g_HttpCurrConn]) 
....................       { 
....................          case HTTP_LISTEN_WAIT: 
....................             if (!TCPIsConnected(g_HttpCurrSocket)) 
....................                break; 
.................... //            fprintf(USER,"HTTP %U CONNECTED\r\n", hs); 
....................  
....................          //wait until we get '\r\n\r\n', which marks the end of the HTTP request header 
....................          case HTTP_CONNECTED: 
.................... //            fprintf(USER,"HTTP %U LISTENING\r\n", hs); 
....................             /* 
....................             printf("\r\nHTTP OPEN %U/%U ", hs, currSocket); 
....................                ui_disp_ip_user(&TCB[currSocket].remote.IPAddr) 
....................                printf(" MAC="); 
....................                ui_disp_mac_user(&TCB[currSocket].remote.MACAddr);; 
....................                printf("\r\n"); 
....................                */ 
....................                 
....................             HTTPbuffer[g_HttpCurrConn][0]=0; 
....................             i[g_HttpCurrConn]=0; 
....................             http_state[g_HttpCurrConn]=HTTP_GET_HEADERS; 
....................             http_timer[g_HttpCurrConn]=TickGet(); 
....................             http_page_req[g_HttpCurrConn]=0; 
....................             http_post_len[g_HttpCurrConn]=0; 
....................            #if HTTP_USE_AUTHENTICATION 
....................             http_auth_user[g_HttpCurrConn][0]=0; 
....................            #endif 
....................            #if HTTP_LAST_MODIFIED_CHECK 
....................             g_lastModifiedCheck[g_HttpCurrConn] = FALSE; 
....................            #endif 
....................            debug_html(debug_html_putc, "\r\nHTML Connected %u ", g_HttpCurrConn); 
....................             //http_got_headers[hs]=FALSE; 
....................             //http_isKeepAlive[hs]=FALSE; 
....................  
....................          case HTTP_GET_HEADERS: 
....................             if(mpfsFlags.bits.bNotAvailable) 
....................                break; 
....................             postContinue=FALSE; 
....................             while (TCPIsGetReady(g_HttpCurrSocket) && TCPGet(g_HttpCurrSocket, &c)) 
....................             { 
....................                //http_got_headers[hs]=TRUE; 
....................                if ( (c >= 0x20) && (i[g_HttpCurrConn] < HTTP_GET_PARAM_MAX_SIZE - 2) ) 
....................                { 
....................                   HTTPbuffer[g_HttpCurrConn][i[g_HttpCurrConn]++]=c; 
....................                } 
....................                if (c=='\n') 
....................                { 
....................                   HTTPbuffer[g_HttpCurrConn][i[g_HttpCurrConn]]=0; 
....................                   if ( 
....................                        ( ( pKey = strtok(&HTTPbuffer[g_HttpCurrConn][0], tokens_header) ) !=0 ) && 
....................                        ( ( pValue = strtok(0, tokens_header) ) !=0 ) 
....................                      ) 
....................                   { 
....................                      debug_html(debug_html_putc, "\r\nHTML Key/Pair '%s'/'%s' ", pKey, pValue); 
....................                      if ( (strcmp(pKey, http_get_str)==0) || (strcmp(pKey, http_post_str)==0) ) 
....................                      { 
....................                         if (strcmp(pKey, http_get_str)==0){ 
....................                            http_cmd[g_HttpCurrConn]=HTTP_REQ_GET; 
....................                         } 
....................                         else{ 
....................                            http_cmd[g_HttpCurrConn]=HTTP_REQ_POST; 
....................                         } 
....................                                            
....................                         pValue=strtok(pValue, tokens_get);  //chop the file after a ? 
....................                         http_escape_chars(pValue); 
....................  
....................                         if (stricmp(pValue,index)==0) 
....................                         { 
....................                            sprintf(pValue, "%s", HTML_INDEX_FNAME); 
....................                            debug_html(debug_html_putc, "index='%s' ", pValue);                            
....................                         } 
....................                         else 
....................                         { 
....................                            if (pValue[0] == '/') 
....................                                                          pValue++;   //skip leading / 
....................                            j=strlen(pValue); 
....................                            l=j; 
....................                            while(pValue[--j] == 47&& j!=0){//strip out trailing '/' chars 
....................                               pValue[j] = 0;   //this may have to be changed if 
....................                            }               //we want to process directories 
....................                         } 
....................                          
....................                         debug_html(debug_html_putc, "page='%s' ", pValue); 
....................                          
....................                         //TODO: do i need the following 2 lines? 
....................                         fstream = MPFSGetEnd(); 
....................  
....................                         MPFSClose(); 
....................  
....................                         if (FileExists(pValue)) 
....................                         { 
....................                            _strncpy(&page[g_HttpCurrConn][0], pValue, sizeof(page)/HTTP_NUM_SOCKETS); 
....................                            http_error_code[g_HttpCurrConn]=200; 
....................                            debug_html(debug_html_putc, "FOUND "); 
....................                         } 
....................                         else 
....................                         { 
....................                            sprintf(&page[g_HttpCurrConn][0], "%s", HTTP_404_ERROR_FNAME); 
....................                            http_error_code[g_HttpCurrConn]=404; 
....................                            debug_html(debug_html_putc, "MISSING "); 
....................                         } 
....................  
.................... //                      fprintf(USER,"HTTP %U PVALUE: %s FILE OPENED: %s, handle:%LX\r\n", hs, pValue, page, fstream); 
....................                         pValue=strtok(0, tokens_get); 
....................                        #if HTTP_USE_AUTHENTICATION 
....................                        //we cant execute this until we authorize 
....................                         _strncpy(&http_get_cache[g_HttpCurrConn][0],pValue,(sizeof(http_get_cache)/HTTP_NUM_SOCKETS)); 
....................                        #else 
....................                         if (pValue && (http_error_code[g_HttpCurrConn]==200)) 
....................                         { 
....................                            http_parse_cgi_string(&page[g_HttpCurrConn][0], pValue); 
....................                         } 
....................                        #endif 
....................                      } 
....................                      else if (http_cmd[g_HttpCurrConn] != HTTP_REQ_UNKOWN)   //we processed a GET or POST 
....................                      { 
....................                         //if you want to parse HTTP headers, do it here. 
....................                         //pKey and pVal hold the individual headers. 
....................  
....................                         //parse the Content-Length header. 
....................                         if (strcmp(pKey, http_len_str)==0) 
....................                            http_post_len[g_HttpCurrConn]=atol(pValue); 
....................                       #if HTTP_LAST_MODIFIED_CHECK 
....................                         if (strstr(pKey, "If-Modified-Since") != 0) 
....................                            g_lastModifiedCheck[g_HttpCurrConn] = TRUE; 
....................                       #endif 
....................                       #if HTTP_USE_AUTHENTICATION                         
....................                         //parse the Authorization header. 
....................                         if (strcmp(pKey, http_auth_str)==0) 
....................                         { 
....................                            _strncpy(http_auth_user, pValue+6,(sizeof(http_auth_user)/HTTP_NUM_SOCKETS)); 
....................                            //printf("\r\nAuth Attempt '%s'->'%s'\r\n", pValue, &http_auth_user[hs][0]); 
....................                         } 
....................                       #endif 
....................                      } 
....................                   } 
....................                   else if (i[g_HttpCurrConn] == 0) 
....................                   { 
....................                      //got a double \r\n 
....................                      //fprintf(USER,"HTTP %U GET HEADER DONE\r\n", hs); 
....................                      if (http_cmd[g_HttpCurrConn] == HTTP_REQ_POST) 
....................                      { 
....................                       #if HTTP_USE_AUTHENTICATION 
....................                         http_state[g_HttpCurrConn]=HTTP_CHECK_AUTHENTICATION; 
....................                       #else 
....................                         http_state[g_HttpCurrConn]=HTTP_GET_POST; 
....................                       #endif 
....................                         postContinue=TRUE; 
....................                      } 
....................                      else 
....................                      { 
....................                       #if HTTP_USE_AUTHENTICATION 
....................                         http_state[g_HttpCurrConn]=HTTP_CHECK_AUTHENTICATION; 
....................                       #else 
....................                         http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
....................                       #endif 
....................                         TCPDiscard(g_HttpCurrSocket); 
....................                      } 
....................                      break;   //break out of read from ethernet loop 
....................                   } 
....................                   i[g_HttpCurrConn]=0; 
....................                } 
....................             } 
....................             if (TickGetDiff(TickGet(),http_timer[g_HttpCurrConn]) > TICKS_PER_SECOND*20) 
....................             { 
....................                   debug_html(debug_html_putc, "\r\nHTTP %U GET HEADER TIMEOUT ", g_HttpCurrConn); 
....................                   sprintf(&page[g_HttpCurrConn][0], "%s", HTTP_500_ERROR_FNAME); 
....................                   http_error_code[g_HttpCurrConn]=500; 
....................                   http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
....................             } 
....................             if (!postContinue) 
....................                break; 
....................  
....................       #if HTTP_USE_AUTHENTICATION 
....................          case HTTP_CHECK_AUTHENTICATION: 
....................             http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
....................             postContinue=FALSE; 
....................             if (HTTPRequiresAuthentication(&page[g_HttpCurrConn][0], &http_auth_user[g_HttpCurrConn][0])) 
....................             { 
....................                //printf("\r\nAUTH REQUIRED\r\n"); 
....................                _strncpy(&page[g_HttpCurrConn][0], http_401_error, sizeof(page)/HTTP_NUM_SOCKETS); 
....................                http_error_code[g_HttpCurrConn]=401; 
....................             } 
....................             else if (http_cmd[g_HttpCurrConn] == HTTP_REQ_POST) 
....................             { 
....................                http_state[g_HttpCurrConn]=HTTP_GET_POST; 
....................                postContinue=TRUE; 
....................             } 
....................             else 
....................             { 
....................                debug_html(debug_html_putc, "\r\n!! AUTH OK !!\r\n"); 
....................                http_parse_cgi_string(&page[g_HttpCurrConn][0], &http_get_cache[g_HttpCurrConn][0]); 
....................             } 
....................             if (!postContinue) 
....................                break; 
....................       #endif 
....................  
....................          case HTTP_GET_POST: 
.................... //            fprintf(USER,"HTTP %U GET POST %LU\r\n", hs, http_post_len[hs]); 
....................             http_state[g_HttpCurrConn]=HTTP_GET_POST_CONTINUE; 
....................             http_timer[g_HttpCurrConn]=TickGet(); 
....................             i[g_HttpCurrConn]=0; 
....................  
....................          case HTTP_GET_POST_CONTINUE: 
....................             while ( 
....................                      TCPIsGetReady(g_HttpCurrSocket) && 
....................                      TCPGet(g_HttpCurrSocket, &c) && 
....................                      (http_post_len[g_HttpCurrConn] != 0) 
....................                   ) 
....................             { 
....................                http_post_len[g_HttpCurrConn] -= 1; 
....................  
....................                if (c!='&') 
....................                { 
....................                   HTTPbuffer[g_HttpCurrConn][i[g_HttpCurrConn]++]=c; 
....................                } 
....................  
....................                if ( (c=='&') || (http_post_len[g_HttpCurrConn] == 0) ) 
....................                { 
....................                   HTTPbuffer[g_HttpCurrConn][i[g_HttpCurrConn]]=0; 
....................  
....................                   //fprintf(USER,"%lu - %s\r\n", http_post_len[hs], &HTTPbuffer[hs][0]); 
....................  
....................                   http_parse_cgi_string(&page[g_HttpCurrConn][0], &HTTPbuffer[g_HttpCurrConn][0]); 
....................                   if (http_post_len[g_HttpCurrConn] == 0) 
....................                   { 
....................                      http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
....................                      TCPDiscard(g_HttpCurrSocket); 
....................                      break; 
....................                   } 
....................                   else 
....................                      i[g_HttpCurrConn]=0; 
....................                } 
....................             } 
....................             if (TickGetDiff(TickGet(),http_timer[g_HttpCurrConn]) > TICKS_PER_SECOND*20) 
....................             { 
....................                debug_html(debug_html_putc, "\r\nHTTP %U GET POST TIMEOUT ", g_HttpCurrConn); 
....................                sprintf(&page[g_HttpCurrConn][0], HTTP_500_ERROR_FNAME); 
....................                http_error_code[g_HttpCurrConn]=500; 
....................                http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE; 
....................             } 
....................             break; 
....................  
....................          case HTTP_SEND_RESPONSE: 
....................             //putc('.'); 
....................             if(mpfsFlags.bits.bNotAvailable) 
....................                break; 
.................... //            fprintf(USER,"HTTP %U SEND RESPONSE\r\n", hs); 
....................             //putc('*'); 
....................             g_HTTPMimeType[g_HttpCurrConn] = HTTPFindMimeType(&page[g_HttpCurrConn][0]); 
....................            #if HTTP_LAST_MODIFIED_CHECK 
....................             if (IsImage(g_HttpCurrConn) && g_lastModifiedCheck[g_HttpCurrConn]) 
....................             { 
....................                http_error_code[g_HttpCurrConn] = 304; 
....................             } 
....................            #endif 
....................             fstream = MPFSOpen(page); 
....................             if (fstream == MPFS_INVALID) 
....................             { 
....................                sprintf(page, HTTP_500_ERROR_FNAME); 
....................                http_error_code[g_HttpCurrConn]=500; 
....................                fstream = MPFSOpen(page); 
....................             } 
....................             MPFSGetBegin(fstream); 
....................             http_page_req[g_HttpCurrConn]=fstream; 
....................             lastHTTPPutConstPos[g_HttpCurrConn]=0; 
....................             http_state[g_HttpCurrConn]=HTTP_SEND_RESPONSE_CONTINUE; 
....................  
....................          case HTTP_SEND_RESPONSE_CONTINUE: 
....................             TCPDiscard(g_HttpCurrSocket); 
....................             //putc('@'); 
....................              if (TCPIsPutReady(g_HttpCurrSocket)) 
....................             { 
....................                //printf("\r\nPut Page Segment %U/%U EC=%LU '%s' %LX ", hs, currSocket, http_error_code[hs], page, http_page_req[hs]); 
....................                /* 
....................                ui_disp_mac_user(&TCB[currSocket].remote.MACAddr); 
....................                printf(" MAC="); 
....................                ui_disp_ip_user(&TCB[currSocket].remote.IPAddr); 
....................                printf("\r\n"); 
....................                */ 
....................                http_timer[g_HttpCurrConn]=TickGet(); 
....................                 
.................... //               fprintf(USER,"\r\nPUTTING HTTP SEG\r\n"); 
....................                doneSend=tcp_http_put_file(http_error_code[g_HttpCurrConn], &http_page_req[g_HttpCurrConn], &page[g_HttpCurrConn][0]); 
....................                if (doneSend!=0) 
....................                { 
....................                   debug_html(debug_html_putc, "\r\nHTML Done sending page "); 
....................                   //if (http_isKeepAlive[hs]) 
....................                   //   http_state[hs]=HTTP_CONNECTED; 
....................                   //else 
....................                   //   http_state[hs]=HTTP_CLOSE; 
....................                   http_state[g_HttpCurrConn] = HTTP_CLOSE; 
....................                    
....................                   fstream = MPFSGetEnd();  
....................                   MPFSClose(); 
.................... //                  fprintf(USER,"HTTP %U RESPONSE SENT\r\n", hs); 
....................                } 
....................             } 
....................             if ((TickGet() - http_timer[g_HttpCurrConn]) >= (TICK)15*TICKS_PER_SECOND) 
....................             { 
....................                http_state[g_HttpCurrConn] = HTTP_CLOSE; 
....................             } 
....................             break; 
....................  
....................          case HTTP_CLOSE: 
....................             //since we set connection: close in the header, the client 
....................             //should automatically close.  but after so many seconds we 
....................             //shall kill the connection 
....................             /* 
....................             printf("\r\nClosing HTTP %U/%U.... ", hs, currSocket); 
....................                ui_disp_mac_user(&TCB[currSocket].remote.MACAddr); 
....................                printf(" MAC="); 
....................                ui_disp_ip_user(&TCB[currSocket].remote.IPAddr); 
....................                printf("\r\n"); 
....................                */ 
....................              
....................             http_state[g_HttpCurrConn]=HTTP_CLOSE_WAITING; 
....................             http_timer[g_HttpCurrConn]=TickGet(); 
....................              
....................          case HTTP_CLOSE_WAITING: 
....................             TCPDiscard(g_HttpCurrSocket); 
....................             if (   
....................                   (TCPGetTxFIFOFull(g_HttpCurrSocket) == 0) || 
....................                   (TickGetDiff(TickGet(),http_timer[g_HttpCurrConn]) > (TICKS_PER_SECOND*8)) 
....................                ) 
....................             { 
....................                if (TCPGetTxFIFOFull(g_HttpCurrSocket) != 0) 
....................                { 
....................                   //socket is messed up.  just kill it by calling TCPDisconnect() twice. 
....................                   TCPDisconnect(g_HttpCurrSocket); 
....................                } 
....................                TCPDisconnect(g_HttpCurrSocket); 
....................                http_state[g_HttpCurrConn]=HTTP_CLOSED; 
....................             } 
....................             break; 
....................  
....................          case HTTP_CLOSED: //do nothing until socket actually closes 
....................          default: 
....................             break; 
....................       } 
....................        
....................      #if defined(__DO_DEBUG_HTML) 
....................       //HTTP_NUM_SOCKETS 
....................       if (debug != http_state[g_HttpCurrConn]) 
....................       { 
....................          debug_html(debug_html_putc, "\r\nHTML %U %X->%X ", g_HttpCurrConn, debug, http_state[g_HttpCurrConn]); 
....................          debug = http_state[g_HttpCurrConn]; 
....................       } 
....................      #endif 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #if defined(STACK_USE_SMTP) && !defined(__SMTP_C) 
....................    #include "smtp.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SMTP) 
....................    #include "ccs_SMTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_SNTP_CLIENT) 
....................    #include "SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_SNTP_CLIENT) 
....................    #include "ccs_SNTP.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TWITTER) 
....................    #include "ccs_twitter.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_TFTP_CLIENT) 
....................    #include "TFTPc.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_TFTP_SERVER) 
....................    #include "ccs_TFTPs.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_ANNOUNCE) && !defined(__ANNOUNCE_C) 
....................    #include "Announce.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_MPFS2) 
....................    #include "MPFS2.c" 
.................... #endif 
....................  
.................... #if defined(STACK_USE_CCS_GRATUITOUS_ARP) 
....................    #include "ccs_gratarp.c" 
.................... #endif 
....................  
.................... #if defined(__18CXX) 
....................    #include "p18cxxx.c" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_C__ 
.................... #define __P18CXXXX_C__ 
....................  
.................... #include "p18cxxx.h" 
.................... // CCS PCH C Compiler to Microchip C18 Compiler compatability layer. 
....................  
.................... #ifndef __P18CXXXX_H__ 
.................... #define __P18CXXXX_H__ 
....................  
.................... #ifndef __18CXX 
.................... #define __18CXX 
.................... #endif 
....................  
.................... //#zero_local_ram 
.................... #zero_ram 
....................  
....................  
.................... #device PASS_STRINGS=IN_RAM 
.................... #device CONST=READ_ONLY 
....................  
.................... #case 
.................... #type signed 
.................... #type short=16 int=16 long=32 
....................  
.................... #define _asm #asm 
.................... #define _endasm #endasm 
....................  
.................... /* usualy 
.................... #define GetSystemClock()      getenv("CLOCK") 
.................... #define GetInstructionClock()   (GetSystemClock()/4) 
.................... #define GetPeripheralClock()   (unsigned int32)GetInstructionClock() 
.................... */ 
....................  
.................... #if getenv("DEVICE") == "PIC18F97J60" 
....................  #define __18F97J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F96J65" 
....................  #define __18F96J65) 
.................... #elif getenv("DEVICE") == "PIC18F96J60" 
....................  #define __18F96J60 
.................... #elif getenv("DEVICE") == "PIC18F87J60" 
....................  #define __18F87J60 
....................  #include "PIC18F87J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J65" 
....................  #define __18F86J65 
.................... #elif getenv("DEVICE") == "PIC18F86J60" 
....................  #define __18F86J60 
.................... #elif getenv("DEVICE") == "PIC18F67J60" 
....................  #define __18F67J60 
....................  #include "PIC18F67J60_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F66J65" 
....................  #define __18F66J65 
.................... #elif getenv("DEVICE") == "PIC18F66J60" 
....................  #define __18F66J60 
.................... #elif getenv("DEVICE") == "PIC18F67K22" 
....................  #define __18F67K22 
....................  #include "PIC18F67K22_registers.h" 
.................... #elif getenv("DEVICE") == "PIC18F4620" 
....................  #define __18F4620 
....................  #include "PIC18F4620_registers.h" 
.................... #else 
....................  #include "PIC18F4585_registers.h" 
.................... #endif 
....................  
.................... #if defined(__18F97J60) || defined(__18F96J65) || defined(__18F96J60) || defined(__18F87J60) || defined(__18F86J65) || defined(__18F86J60) || defined(__18F67J60) || defined(__18F66J65) || defined(__18F66J60) 
....................    #reserve 0xE80:0xEFF 
....................    #reserve 0xF00:0xFFF 
.................... #endif 
....................  
.................... #if defined(TRUE) 
....................    #undef TRUE 
.................... #endif 
....................  
.................... #if defined(FALSE) 
....................    #undef FALSE 
.................... #endif 
....................  
.................... #if defined(BYTE) 
....................    #undef BYTE 
.................... #endif 
....................  
....................       #define Reset()            reset_cpu() 
....................         #define far 
....................         #define ClrWdt()         restart_wdt() 
....................       #define Nop()            delay_cycles(1) 
....................  
.................... #define __CCS__ 
....................  
.................... //signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n); 
.................... signed int8 strcmppgm2ram(char *s1, __ADDRESS__ s2); 
.................... char *strchrpgm(rom char *s, unsigned int8 c); 
.................... char *strstrrampgm(char *s1, __ADDRESS__ s2); 
.................... unsigned int8 strlenpgm(__ADDRESS__ s); 
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n); 
.................... //char* strupr(char *s);   now in string.h 
.................... void strcpypgm2ram(char *d, __ADDRESS__ s); 
.................... #endif 
....................  
.................... /* STRING.H already has this exact function 
.................... signed int8 memcmppgm2ram(void * s1, rom char *s2, unsigned int8 n) 
.................... { 
....................   #if 1 
....................    char *su1; 
....................    rom char *su2; 
....................     
....................    for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
....................    { 
....................       if(*su1!=*su2) 
....................          return ((*su1<*su2)?-1:+1); 
....................    } 
....................    return 0; 
....................   #else 
....................    #error///warning memcmppgm2ram disabled 
....................   #endif 
.................... }*/ 
....................  
.................... #if 0 //this is in string.h and helpers.c 
.................... char* strupr(char *s) 
.................... { 
....................    char *p; 
....................     
....................    p=s; 
....................     
....................    while(*p) 
....................    { 
....................       *p = toupper(*p++); 
....................    } 
....................    return(s); 
.................... } 
.................... #endif 
....................  
.................... void memcpypgm2ram(unsigned int8 *d, __ADDRESS__ s, unsigned int16 n) 
.................... { 
....................    //printf("ROM_0x%LX-to-0x%LX ", d, s); 
....................   #if (getenv("PROGRAM_MEMORY") > 0x10000) 
....................    #warning temporary ccs bug fix 
....................    s |= 0x10000; 
....................   #endif 
....................    read_program_memory(s, d, n); 
.................... } 
....................  
.................... void strcpypgm2ram(char *d, __ADDRESS__ s) 
.................... { 
....................    char c; 
....................    do 
....................    { 
....................       memcpypgm2ram(&c, s++, 1); 
....................       *d++ = c; 
....................    } while(c); 
.................... } 
....................  
.................... #if 0 
.................... signed int8 strcmppgm2ram(char *s1, rom char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... #endif 
....................  
.................... char *strchrpgm(rom char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
....................  
.................... char *strstrrampgm(char *s1,__ADDRESS__ s2) 
.................... { 
....................    char *s; 
....................    rom char *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... unsigned int8 strlenpgm( __ADDRESS__ s) 
.................... { 
....................    char c; 
....................    char counter = 0; 
....................    do{ 
....................       memcpypgm2ram(&c,s++,1); 
....................       counter++; 
....................    }while(c != 0); 
....................    return(counter - 1); 
.................... } 
.................... //#endif   //if 0 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... int1 DHCPBoundOrDisabled(void) 
.................... { 
....................   #if defined(STACK_USE_DHCP_CLIENT) 
....................    return(!DHCPIsEnabled(0) || DHCPIsBound(0)); 
....................   #else 
....................    return(TRUE); 
....................   #endif 
.................... } 
....................  
.................... int1 IsLinked(void) 
.................... { 
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       return(MACIsLinked() && g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................     
....................    return(MACIsLinked() && DHCPBoundOrDisabled()); 
.................... } 
....................  
.................... #if defined(STACK_USE_MPFS) 
.................... MPFS _MpfsEofLoc; 
....................  
.................... unsigned int16 MPFSGetBytes(unsigned int8 *pDest, unsigned int16 n) 
.................... { 
....................    unsigned int16 ret = 0; 
....................    unsigned int16 i; 
....................    unsigned int8 *p; 
....................    int1 escaped = FALSE; 
....................     
....................    p = pDest; 
....................     
....................    debug_mpfs2(debug_putc, "\r\nMPFSGetBytes() START %LX ", _currentHandle); 
....................     
....................    while(n) 
....................    { 
....................       HTTP_INTERRUPT_TASKS(); 
....................        
....................       debug_mpfs2(debug_putc, "n=%LX ", n); 
....................        
....................       _MpfsEofLoc = _currentHandle; 
....................      #if defined(MPFS_USE_SPI_FLASH) 
....................       SPIFlashReadArray(_currentHandle, pDest, n); 
....................      #else 
....................       memcpypgm2ram(pDest, _currentHandle, n); //__ccs__ change because MPFS isn't rom pointer 
....................      #endif 
....................  
....................       _currentHandle += n; 
....................  
....................       //debug_array("START", pDest, n); 
....................  
....................       i = n; 
....................       n = 0; 
....................        
....................       while(i--) 
....................       { 
....................          _MpfsEofLoc++; 
....................          if (escaped || (*pDest == MPFS_DLE)) 
....................          { 
....................             if (!escaped) 
....................             { 
....................                n++; 
....................             } 
....................              
....................             if (escaped || i) 
....................             { 
....................                if (!escaped) 
....................                { 
....................                   debug_mpfs2(debug_putc, "! "); 
....................                   memmove(pDest, pDest+1, i); 
....................                   _MpfsEofLoc++; 
....................                   i--; 
....................                } 
....................                ret++; 
....................                escaped = FALSE; 
....................             } 
....................             else 
....................             { 
....................                escaped = TRUE; 
....................                pDest--; //counter pDest++ below, since we need to start saving new bytes here 
....................             } 
....................          } 
....................          else if(*pDest == MPFS_ETX) 
....................          { 
....................             _MpfsEofLoc--; 
....................             debug_mpfs2(debug_putc, "EOF %LX ", _MpfsEofLoc); 
....................             _currentHandle = MPFS_INVALID; 
....................             n = 0; 
....................             break; 
....................          } 
....................          else 
....................          { 
....................             ret++; 
....................          } 
....................          pDest++; 
....................       } 
....................    } 
....................    //debug_array("STOP", p, ret);    
....................  
....................    return(ret); 
.................... } 
.................... #ENDIF 
....................  
.................... #if STACK_USE_WIFI 
....................  
.................... //extern int1 g_WifiTempDisFlag; 
.................... //extern TICK g_WifiTempDisTick; 
.................... //extern int1 g_wifiConnected; 
.................... extern int1 g_WifiConnectFail; 
....................  
.................... // see StackTsk2.h for documentation 
.................... #if 0 
.................... int1 MyWFisConnected(void) 
.................... { 
....................    int1 ret = FALSE; 
....................  
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................       return(g_WifiAdhocIsConn); 
....................    } 
....................   #endif 
....................  
....................    if (g_wifiConnected) 
....................    { 
....................       ret = TRUE; 
....................    } 
....................    else if (!g_WifiConnectFail) 
....................    { 
....................       if (g_WifiTempDisFlag) 
....................       { 
....................          if ((TickGet() - g_WifiTempDisTick) < ((TICK)5*TICKS_PER_SECOND)) 
....................          { 
....................             ret = TRUE; 
....................          } 
....................          else 
....................          { 
....................             g_WifiTempDisFlag = FALSE; 
....................          } 
....................       } 
....................    } 
....................  
....................    return(ret); 
.................... } 
.................... #endif 
....................  
.................... unsigned int8 g_connectionProfileID = 0xFF;  //used to communicate with the connection profile on the WiFi module 
....................  
.................... unsigned int8 WIFI_channelList[16]; 
.................... unsigned int8 WIFI_numChannelsInList; 
.................... unsigned int8 WIFI_region; 
....................  
.................... // this option will force the connection profile to be closed and reopened 
.................... // if we do not get a connection within this time.  might fix an errata that 
.................... // says WPA/WPA2 will lockup instead of sending an event. 
.................... #define WIFI_FORCE_RECONNECT_TICK   (TICK)(TICKS_PER_SECOND * 120)  //might be too short for WPA/WPA2 phrase 
....................  
.................... #if defined(WIFI_GET_VERSION_INFO) 
.................... tWFDeviceInfo WIFI_GET_VERSION_INFO; 
.................... #endif 
....................  
.................... void WIFIConnectInitStates(void) 
.................... { 
....................    //wf_debug_printf(wf_debug_putc, "\r\nWIFIConnectInitStates"); 
....................     
....................    g_connectionProfileID = 0xFF; 
....................     
....................    g_WifiConnectFail = FALSE;    
....................     
....................   #if defined(STACK_USE_CCS_SCAN_TASK) 
....................    WIFIScanInit(); 
....................   #endif 
....................  
....................         #if defined(WIFI_GET_VERSION_INFO) 
....................          WF_GetDeviceInfo(&WIFI_GET_VERSION_INFO); 
....................         #endif  
....................  
....................          WF_CASetScanType(MY_DEFAULT_SCAN_TYPE);   // was WF_ACTIVE_SCAN 
....................  
....................          WF_CASetChannelList(WIFI_channelList, WIFI_numChannelsInList); //was AppConfig.channelList, AppConfig.numChannelsInList 
....................  
....................          WF_SetRegionalDomain(WIFI_region);  //was AppConfig.region 
....................           
....................          WF_CASetListRetryCount(MY_DEFAULT_LIST_RETRY_COUNT);  // was WF_RETRY_FOREVER 
....................           
....................          WF_CASetEventNotificationAction(MY_DEFAULT_EVENT_NOTIFICATION_LIST); // was WF_NOTIFY_ALL_EVENTS 
....................           
....................          WF_CASetBeaconTimeout(MY_DEFAULT_BEACON_TIMEOUT); 
....................  
....................          WF_CASetBeaconTimeoutAction(WF_ATTEMPT_TO_RECONNECT); 
....................           
....................          WF_CASetDeauthAction(WF_ATTEMPT_TO_RECONNECT); 
....................  
....................        #if defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................            if (AppConfig.SecurityMode == WF_SECURITY_WPA_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA2_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) { 
....................                WF_ConvPassphrase2Key(AppConfig.SecurityKeyLength, AppConfig.SecurityKey, 
....................                    AppConfig.SsidLength, AppConfig.MySSID); 
....................                AppConfig.SecurityMode--; 
....................                AppConfig.SecurityKeyLength = 32; 
....................            } 
....................        #if defined (MRF24WG) 
....................            else if (AppConfig.SecurityMode == WF_SECURITY_WPS_PUSH_BUTTON 
....................                        || AppConfig.SecurityMode == WF_SECURITY_WPS_PIN) { 
....................                WF_YieldPassphrase2Host();     
....................            } 
....................        #endif    // defined (MRF24WG) 
....................        #endif    // defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................  
....................        #ifndef WF_FORCE_NO_PS_POLL 
....................        #if MY_DEFAULT_PS_POLL == WF_ENABLED 
....................            WF_PsPollEnable(TRUE); 
....................        #if !defined(MRF24WG)  
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableDeferredPowerSave(); 
....................        #endif    // !defined(MRF24WG) 
....................        #else     // MY_DEFAULT_PS_POLL != WF_ENABLED 
....................            WF_PsPollDisable(); 
....................        #endif    // MY_DEFAULT_PS_POLL == WF_ENABLED 
....................     
....................        #ifdef WF_AGGRESSIVE_PS 
....................        #if !defined(MRF24WG) 
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableAggressivePowerSave(); 
....................        #endif 
....................        #endif 
....................        #endif  
.................... } 
....................  
.................... int1 g_WIFIConnectStart = TRUE; 
....................  
.................... void WIFIConnectStop(void) 
.................... { 
....................    if (!MACIsLinked() || (g_connectionProfileID == 0xFF)) 
....................    { 
....................       //wf_debug_printf(wf_debug_putc, "\r\n\n*** Reset of MAC because WIFIConnectStop()\r\n"); 
....................       MACInit(); 
....................    } 
....................   #if defined(WF_DEBUG) 
....................    else 
....................    { 
....................       //wf_debug_printf(wf_debug_putc, "\r\nWIFIConnectStop"); 
....................    } 
....................   #endif 
....................     
....................    g_WIFIConnectStart = FALSE; 
.................... } 
....................  
.................... void WIFIConnectStart(void) 
.................... { 
....................    //wf_debug_printf(wf_debug_putc, "\r\nWIFIConnectStart"); 
....................     
....................    g_WIFIConnectStart = TRUE; 
.................... } 
....................  
.................... // this was based off of WF_Connect() in Microchip's demo application. 
.................... void WIFIConnectTask(void) 
.................... { 
....................    #if !defined(APP_GENERIC_SCRATCH) 
....................       char WIFIConnectTask_Scratch[6]; 
....................    #else 
....................       #define WIFIConnectTask_Scratch  APP_GENERIC_SCRATCH 
....................    #endif 
....................     
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    static TICK fTick; 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) || defined(LED_ACTIVITY_ON) 
....................    static TICK l; 
....................    // if you have both LED_CONNECTION_ON and LED_ACTIVITY_ON (2 WIFI LEDs),  
....................    //    then one LED is used for flickering on traffic and another is used to  
....................    //    show connection state. 
....................    // if you only have LED_CONNECTION_ON (only 1 WIFI LED), then WIFI  
....................    //    connection status and wifi traffic flickering is shared on the same 
....................    //    LED. 
....................    // this routine below handles the traffic led flickering.  the LED was 
....................    //    turned off in the TCP/IP stack, this routine turns it back on every 
....................    //    200ms. 
....................    if ((TickGet() - l) >= TICKS_PER_SECOND/5) 
....................    { 
....................       l = TickGet(); 
....................        
....................      #if defined(LED_ACTIVITY_ON) 
....................       LED_ACTIVITY_OFF(); 
....................      #else 
....................       if (IsLinked()) 
....................       { 
....................          LED_CONNECTION_ON(); 
....................       } 
....................       else 
....................       { 
....................          LED_CONNECTION_OFF(); 
....................       } 
....................      #endif 
....................    } 
....................   #endif 
....................  
....................   #if defined(STACK_USE_CCS_SCAN_TASK) 
....................    WIFIScanTask(); 
....................   #endif 
....................  
....................   #if defined(LED_CONNECTION_ON) && defined(LED_ACTIVITY_ON) 
....................    // handle the connection status LED if you have 2 WIFI LEDs. 
....................    if (IsLinked()) 
....................    { 
....................       LED_CONNECTION_ON(); 
....................    } 
....................    else 
....................    { 
....................       LED_CONNECTION_OFF(); 
....................    } 
....................   #endif 
....................  
....................   #if STACK_USE_WIFI && defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (AppConfig.networkType == WF_ADHOC) 
....................    { 
....................       if ( 
....................             g_WifiAdhocIsConn && 
....................             ((TickGet() - g_WifiAdhocTickConn) > WIFI_ADHOC_CONNECTION_TIMER) 
....................          ) 
....................       { 
....................          g_WifiAdhocIsConn = FALSE; 
....................       } 
....................    } 
....................   #endif 
....................  
....................   #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................    if ( 
....................          (AppConfig.networkType != WF_ADHOC) && 
....................          (g_connectionProfileID != 0xFF) 
....................       ) 
....................    { 
....................       if (IsLinked()) 
....................       { 
....................          fTick = TickGet(); 
....................       } 
....................       else if ((TickGet() - fTick) > WIFI_FORCE_RECONNECT_TICK) 
....................       { 
....................         #if defined(STACK_IS_CCS_EXAMPLE) 
....................          fprintf(STREAM_UI, "\r\nLong WIFI connection timeout, reseting module"); 
....................         #endif 
....................          MACInit(); 
....................         #if defined(WIFI_EXTRA_LINK_STATUS) 
....................          g_LastWifiEvent = 20; 
....................         #endif 
....................       } 
....................    } 
....................   #endif 
....................  
....................    if ((g_connectionProfileID == 0xFF) && g_WIFIConnectStart) 
....................    { 
....................       g_WifiConnectFail = FALSE; 
....................        
....................       WF_CPCreate(&g_connectionProfileID); 
....................        
....................       #if defined(WF_DEBUG) 
....................       wf_debug_printf(wf_debug_putc, "\r\nCreating connect profile... "); 
....................       #endif 
....................        
....................       if (g_connectionProfileID != 0xFF) 
....................       { 
....................          /* 
....................         #if defined(WIFI_GET_VERSION_INFO) 
....................          WF_GetDeviceInfo(&WIFI_GET_VERSION_INFO); 
....................         #endif 
....................         */ 
....................          #if defined(WF_DEBUG) 
....................          wf_debug_printf(wf_debug_putc, "%U ", g_connectionProfileID); 
....................          #endif 
....................  
....................          g_WifiConnectFail = TRUE; 
....................  
....................          WF_CPSetSsid(g_connectionProfileID,  
....................                     AppConfig.MySSID,  
....................                     AppConfig.SsidLength); 
....................           
....................          memset(WIFIConnectTask_Scratch, 0xFF, 6); 
....................          WF_CPSetBssid(g_connectionProfileID, WIFIConnectTask_Scratch); 
....................  
....................          WF_CPSetNetworkType(g_connectionProfileID, AppConfig.networkType); 
....................           
....................          if(AppConfig.networkType == WF_ADHOC) 
....................          { 
....................             WF_CPSetAdHocBehavior(g_connectionProfileID, AppConfig.adhocBehavior); 
....................          } 
....................  
....................          /* 
....................          WF_CASetScanType(MY_DEFAULT_SCAN_TYPE);   // was WF_ACTIVE_SCAN 
....................  
....................          WF_CASetChannelList(WIFI_channelList, WIFI_numChannelsInList); //was AppConfig.channelList, AppConfig.numChannelsInList 
....................  
....................          WF_SetRegionalDomain(WIFI_region);  //was AppConfig.region 
....................           
....................          WF_CASetListRetryCount(MY_DEFAULT_LIST_RETRY_COUNT);  // was WF_RETRY_FOREVER 
....................           
....................          WF_CASetEventNotificationAction(MY_DEFAULT_EVENT_NOTIFICATION_LIST); // was WF_NOTIFY_ALL_EVENTS 
....................           
....................          WF_CASetBeaconTimeout(MY_DEFAULT_BEACON_TIMEOUT); 
....................  
....................          WF_CASetBeaconTimeoutAction(WF_ATTEMPT_TO_RECONNECT); 
....................           
....................          WF_CASetDeauthAction(WF_ATTEMPT_TO_RECONNECT); 
....................  
....................        #if defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................            if (AppConfig.SecurityMode == WF_SECURITY_WPA_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA2_WITH_PASS_PHRASE 
....................                || AppConfig.SecurityMode == WF_SECURITY_WPA_AUTO_WITH_PASS_PHRASE) { 
....................                WF_ConvPassphrase2Key(AppConfig.SecurityKeyLength, AppConfig.SecurityKey, 
....................                    AppConfig.SsidLength, AppConfig.MySSID); 
....................                AppConfig.SecurityMode--; 
....................                AppConfig.SecurityKeyLength = 32; 
....................            } 
....................        #if defined (MRF24WG) 
....................            else if (AppConfig.SecurityMode == WF_SECURITY_WPS_PUSH_BUTTON 
....................                        || AppConfig.SecurityMode == WF_SECURITY_WPS_PIN) { 
....................                WF_YieldPassphrase2Host();     
....................            } 
....................        #endif    // defined (MRF24WG) 
....................        #endif    // defined(DERIVE_KEY_FROM_PASSPHRASE_IN_HOST) 
....................        */ 
....................  
....................          WF_CPSetSecurity(g_connectionProfileID, 
....................                         AppConfig.SecurityMode, 
....................                         0, //AppConfig.WepKeyIndex, //AppConfig.WepKeyIndex,   /* only used if WEP enabled */ 
....................                         AppConfig.SecurityKey, 
....................                         AppConfig.SecurityKeyLength);       
....................   
....................       #if (MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE!=WF_SECURITY_WEP_SHAREDKEY) 
....................         #if !defined(MRF24WG) 
....................          if (gRFModuleVer1209orLater) 
....................         #endif 
....................          { 
....................             // If WEP security is used, set WEP Key Type.  The default WEP Key Type is Shared Key. 
....................             if ((AppConfig.SecurityMode == WF_SECURITY_WEP_40) || (AppConfig.SecurityMode == WF_SECURITY_WEP_104)) 
....................             { 
....................                 WF_CPSetWepKeyType(g_connectionProfileID, MY_DEFAULT_WIFI_SECURITY_WEP_KEYTYPE); 
....................             } 
....................          } 
....................      #endif 
....................  
....................          /* 
....................        #ifndef WF_FORCE_NO_PS_POLL 
....................        #if MY_DEFAULT_PS_POLL == WF_ENABLED 
....................            WF_PsPollEnable(TRUE); 
....................        #if !defined(MRF24WG)  
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableDeferredPowerSave(); 
....................        #endif    // !defined(MRF24WG) 
....................        #else     // MY_DEFAULT_PS_POLL != WF_ENABLED 
....................            WF_PsPollDisable(); 
....................        #endif    // MY_DEFAULT_PS_POLL == WF_ENABLED 
....................     
....................        #ifdef WF_AGGRESSIVE_PS 
....................        #if !defined(MRF24WG) 
....................            if (gRFModuleVer1209orLater) 
....................                WFEnableAggressivePowerSave(); 
....................        #endif 
....................        #endif 
....................        #endif 
....................          */ 
....................       } 
....................    } 
....................  
....................    if(g_WifiConnectFail && g_WIFIConnectStart) 
....................    { 
....................       #if defined(WF_DEBUG) 
....................       wf_debug_printf(wf_debug_putc, "\r\nStart WiFi Connect PROF=%u ", g_connectionProfileID); 
....................       #endif 
....................       
....................      #if defined(STACK_IS_CCS_EXAMPLE) 
....................       fprintf(STREAM_UI, "\r\nStart WiFi Connect"); 
....................      #endif 
....................       
....................      #if defined(WIFI_FORCE_RECONNECT_TICK) 
....................       fTick = TickGet(); 
....................      #endif 
....................  
....................      #if defined(WF_FORCE_NO_PS_POLL) 
....................       WF_CCS_PsPollDisable(); 
....................      #endif 
....................     
....................       WF_CMConnect(g_connectionProfileID); 
....................    } 
....................     
....................    g_WifiConnectFail = 0; 
.................... } 
....................  
.................... void LinkTraffic(int1 isTx) 
.................... { 
....................   #if defined(WIFI_ADHOC_CONNECTION_TIMER) 
....................    if (!isTx && (AppConfig.networkType == WF_ADHOC)) 
....................    { 
....................       g_WifiAdhocIsConn = TRUE; 
....................       g_WifiAdhocTickConn = TickGet(); 
....................    } 
....................   #endif 
....................  
....................    // these LEDs are desribed in WIFIConnectTask() 
....................   #if defined(LED_ACTIVITY_ON) 
....................    LED_ACTIVITY_ON(); 
....................   #elif defined(LED_CONNECTION_ON) 
....................    LED_CONNECTION_OFF(); 
....................   #endif 
.................... } 
....................  
....................  
.................... #if defined(WF_FORCE_NO_PS_POLL) 
.................... #if defined(WF_USE_POWER_SAVE_FUNCTIONS) 
....................    #error dont use both at the same time 
.................... #endif 
.................... typedef struct pwrModeRequestStruct 
.................... { 
....................     UINT8 mode; 
....................     UINT8 wake; 
....................     UINT8 rcvDtims; 
....................     UINT8 reserved;            /* pad byte */ 
.................... } tWFPwrModeReq; 
....................  
.................... static void SendPowerModeMsg(tWFPwrModeReq *p_powerMode) 
.................... { 
....................     UINT8 hdr[2]; 
....................      
....................     hdr[0] = WF_MGMT_REQUEST_TYPE; 
....................     hdr[1] = WF_SET_POWER_MODE_SUBTYPE; 
....................  
....................     SendMgmtMsg(hdr, 
....................                 sizeof(hdr), 
....................                (UINT8 *)p_powerMode, 
....................                sizeof(tWFPwrModeReq)); 
....................  
....................     /* wait for mgmt response, free buffer after it comes in (no data to read) */ 
....................    WaitForMgmtResponse(WF_SET_POWER_MODE_SUBTYPE, FREE_MGMT_BUFFER); 
....................      
.................... }  
....................  
.................... void WF_CCS_PsPollDisable(void) 
.................... { 
....................    tWFPwrModeReq   pwrModeReq; 
....................      
....................     pwrModeReq.mode     = 1;  //PS_POLL_DISABLED; 
....................     pwrModeReq.wake     = 1; 
....................     pwrModeReq.rcvDtims = 1; 
....................     SendPowerModeMsg(&pwrModeReq); 
....................  
....................     //SetPowerSaveState(WF_PS_OFF); //not really needed, sets a global for their statemachine 
....................  
....................     WFConfigureLowPowerMode(WF_LOW_POWER_MODE_OFF);  
.................... } 
.................... #endif   //WF_FORCE_NO_PS_POLL 
....................  
.................... #endif //STACK_USE_WIFI 
....................  
.................... #if defined(__DO_DEBUG_MPFS2) 
.................... void debug_array(char *str, char *p, unsigned int16 n) 
.................... { 
....................    char c; 
....................    debug_mpfs2(debug_putc, "\r\n%s %LX ", str, n); 
....................    while(n--) 
....................    { 
....................       c = *p++; 
....................       if ((c >= ' ') && (c <= '}')) 
....................       { 
....................          debug_mpfs2(debug_putc, "%c", c); 
....................       } 
....................       else 
....................       { 
....................          debug_mpfs2(debug_putc, "+%X", c); 
....................       } 
....................    } 
....................    debug_mpfs2(debug_putc, " "); 
.................... } 
.................... #else 
.................... #define debug_array(str, p, n) 
.................... #endif 
....................  
.................... // if you call TickGet() from an ISR, this may be a lock-up condition. 
.................... // this is a morph of GetTickCopy() and TickUpdate() that works from an ISR. 
.................... // only works on PIC18. 
.................... #if defined(__PCH__) 
.................... TICK TickGetSafe(void) 
.................... { 
....................    BYTE myTickReading[6]; 
....................    do 
....................    { 
....................       if(INTCONbits.TMR0IF) 
....................       { 
....................          dwInternalTicks++; 
....................          INTCONbits.TMR0IF = 0; 
....................       } 
....................       myTickReading[0] = TMR0L; 
....................       myTickReading[1] = TMR0H; 
....................       *((DWORD*)&myTickReading[2]) = dwInternalTicks; 
....................    } while(INTCONbits.TMR0IF); 
....................     
....................    return *((DWORD*)&myTickReading[0]); 
.................... } 
.................... #endif 
....................  
.................... // this used to be called GenerateRandomBYTE() in an older CCS port of Helpers.c 
.................... BYTE GenerateRandomByteFromTimers(void) 
.................... { 
....................    BYTE rand; 
....................     
....................   #if getenv("TIMER0") && !defined(__PCD__) 
....................    rand+=get_timer0(); 
....................   #endif 
....................    
....................   #if getenv("TIMER1") 
....................    rand+=get_timer1(); 
....................   #endif 
....................    
....................   #if getenv("TIMER2") 
....................    rand+=get_timer2(); 
....................   #endif 
....................    
....................   #if getenv("TIMER3") 
....................    rand+=get_timer3(); 
....................   #endif 
....................    
....................   #if getenv("TIMER4") 
....................    rand+=get_timer4(); 
....................   #endif 
....................    
....................   #if getenv("TIMER5") 
....................    rand+=get_timer5(); 
....................   #endif 
....................    
....................    return(rand); 
.................... } 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define LCD_ENABLE_PIN PIN_D1 
.................... #define LCD_RS_PIN PIN_D0 
.................... #define LCD_RW_PIN PIN_D2 
.................... #define LCD_DATA4 PIN_D4 
.................... #define LCD_DATA5 PIN_D5 
.................... #define LCD_DATA6 PIN_D6 
.................... #define LCD_DATA7 PIN_D7 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
15A6:  BSF    F95.4
....................    output_float(LCD_DATA5); 
15A8:  BSF    F95.5
....................    output_float(LCD_DATA6); 
15AA:  BSF    F95.6
....................    output_float(LCD_DATA7); 
15AC:  BSF    F95.7
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
15AE:  BSF    F8C.2
15B0:  BCF    F95.2
....................    delay_cycles(1); 
15B2:  NOP   
....................    lcd_output_enable(1); 
15B4:  BSF    F8C.1
15B6:  BCF    F95.1
....................    delay_cycles(1); 
15B8:  NOP   
....................    high = lcd_read_nibble(); 
15BA:  RCALL  1550
15BC:  MOVFF  01,39B
....................        
....................    lcd_output_enable(0); 
15C0:  BCF    F8C.1
15C2:  BCF    F95.1
....................    delay_cycles(1); 
15C4:  NOP   
....................    lcd_output_enable(1); 
15C6:  BSF    F8C.1
15C8:  BCF    F95.1
....................    delay_us(1); 
15CA:  BRA    15CC
....................    low = lcd_read_nibble(); 
15CC:  RCALL  1550
15CE:  MOVFF  01,39A
....................        
....................    lcd_output_enable(0); 
15D2:  BCF    F8C.1
15D4:  BCF    F95.1
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
15D6:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
15D8:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
15DA:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
15DC:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
15DE:  MOVLB  3
15E0:  SWAPF  x9B,W
15E2:  MOVWF  00
15E4:  MOVLW  F0
15E6:  ANDWF  00,F
15E8:  MOVF   00,W
15EA:  IORWF  x9A,W
15EC:  MOVWF  01
15EE:  MOVLB  0
15F0:  GOTO   1600 (RETURN)
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
1550:  MOVLB  3
1552:  CLRF   x9C
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
1554:  BSF    F95.4
1556:  MOVLW  00
1558:  BTFSC  F83.4
155A:  MOVLW  01
155C:  IORWF  x9C,F
....................    n |= input(LCD_DATA5) << 1; 
155E:  BSF    F95.5
1560:  MOVLW  00
1562:  BTFSC  F83.5
1564:  MOVLW  01
1566:  MOVWF  00
1568:  BCF    FD8.0
156A:  RLCF   00,F
156C:  MOVF   00,W
156E:  IORWF  x9C,F
....................    n |= input(LCD_DATA6) << 2; 
1570:  BSF    F95.6
1572:  MOVLW  00
1574:  BTFSC  F83.6
1576:  MOVLW  01
1578:  MOVWF  00
157A:  RLCF   00,F
157C:  RLCF   00,F
157E:  MOVLW  FC
1580:  ANDWF  00,F
1582:  MOVF   00,W
1584:  IORWF  x9C,F
....................    n |= input(LCD_DATA7) << 3; 
1586:  BSF    F95.7
1588:  MOVLW  00
158A:  BTFSC  F83.7
158C:  MOVLW  01
158E:  MOVWF  00
1590:  RLCF   00,F
1592:  RLCF   00,F
1594:  RLCF   00,F
1596:  MOVLW  F8
1598:  ANDWF  00,F
159A:  MOVF   00,W
159C:  IORWF  x9C,F
....................     
....................    return(n); 
159E:  MOVFF  39C,01
....................   #else 
15A2:  MOVLB  0
15A4:  RETURN 0
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
150C:  MOVLB  3
150E:  BTFSC  x9B.0
1510:  BRA    1516
1512:  BCF    F8C.4
1514:  BRA    1518
1516:  BSF    F8C.4
1518:  BCF    F95.4
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
151A:  BTFSC  x9B.1
151C:  BRA    1522
151E:  BCF    F8C.5
1520:  BRA    1524
1522:  BSF    F8C.5
1524:  BCF    F95.5
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
1526:  BTFSC  x9B.2
1528:  BRA    152E
152A:  BCF    F8C.6
152C:  BRA    1530
152E:  BSF    F8C.6
1530:  BCF    F95.6
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
1532:  BTFSC  x9B.3
1534:  BRA    153A
1536:  BCF    F8C.7
1538:  BRA    153C
153A:  BSF    F8C.7
153C:  BCF    F95.7
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
153E:  NOP   
....................    lcd_output_enable(1); 
1540:  BSF    F8C.1
1542:  BCF    F95.1
....................    delay_us(2); 
1544:  BRA    1546
1546:  BRA    1548
....................    lcd_output_enable(0); 
1548:  BCF    F8C.1
154A:  BCF    F95.1
154C:  MOVLB  0
154E:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
15F4:  BCF    F95.1
....................    lcd_rs_tris(); 
15F6:  BCF    F95.0
....................    lcd_rw_tris(); 
15F8:  BCF    F95.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
15FA:  BCF    F8C.0
15FC:  BCF    F95.0
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
15FE:  BRA    15A6
1600:  MOVFF  01,39A
1604:  MOVLB  3
1606:  BTFSS  01.7
1608:  BRA    160E
160A:  MOVLB  0
160C:  BRA    15FE
....................    lcd_output_rs(address); 
160E:  MOVF   x98,F
1610:  BNZ   1616
1612:  BCF    F8C.0
1614:  BRA    1618
1616:  BSF    F8C.0
1618:  BCF    F95.0
....................    delay_cycles(1); 
161A:  NOP   
....................    lcd_output_rw(0); 
161C:  BCF    F8C.2
161E:  BCF    F95.2
....................    delay_cycles(1); 
1620:  NOP   
....................    lcd_output_enable(0); 
1622:  BCF    F8C.1
1624:  BCF    F95.1
....................    lcd_send_nibble(n >> 4); 
1626:  SWAPF  x99,W
1628:  MOVWF  x9A
162A:  MOVLW  0F
162C:  ANDWF  x9A,F
162E:  MOVFF  39A,39B
1632:  MOVLB  0
1634:  RCALL  150C
....................    lcd_send_nibble(n & 0xf); 
1636:  MOVLB  3
1638:  MOVF   x99,W
163A:  ANDLW  0F
163C:  MOVWF  x9A
163E:  MOVWF  x9B
1640:  MOVLB  0
1642:  RCALL  150C
1644:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
1646:  MOVLW  28
1648:  MOVLB  3
164A:  MOVWF  x7C
164C:  MOVLW  0C
164E:  MOVWF  x7D
1650:  MOVLW  01
1652:  MOVWF  x7E
1654:  MOVLW  06
1656:  MOVWF  x7F
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
1658:  BCF    F8C.1
165A:  BCF    F95.1
....................    lcd_output_rs(0); 
165C:  BCF    F8C.0
165E:  BCF    F95.0
....................    lcd_output_rw(0); 
1660:  BCF    F8C.2
1662:  BCF    F95.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
1664:  BCF    F95.4
....................    output_drive(LCD_DATA5); 
1666:  BCF    F95.5
....................    output_drive(LCD_DATA6); 
1668:  BCF    F95.6
....................    output_drive(LCD_DATA7); 
166A:  BCF    F95.7
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
166C:  BCF    F95.1
....................    lcd_rs_tris(); 
166E:  BCF    F95.0
....................    lcd_rw_tris(); 
1670:  BCF    F95.2
....................  #endif 
....................      
....................    delay_ms(15); 
1672:  MOVLW  0F
1674:  MOVWF  x94
1676:  MOVLB  0
1678:  CALL   051A
....................    for(i=1;i<=3;++i) 
167C:  MOVLW  01
167E:  MOVLB  3
1680:  MOVWF  x7B
1682:  MOVF   x7B,W
1684:  SUBLW  03
1686:  BNC   16A2
....................    { 
....................        lcd_send_nibble(3); 
1688:  MOVLW  03
168A:  MOVWF  x9B
168C:  MOVLB  0
168E:  RCALL  150C
....................        delay_ms(5); 
1690:  MOVLW  05
1692:  MOVLB  3
1694:  MOVWF  x94
1696:  MOVLB  0
1698:  CALL   051A
169C:  MOVLB  3
169E:  INCF   x7B,F
16A0:  BRA    1682
....................    } 
....................     
....................    lcd_send_nibble(2); 
16A2:  MOVLW  02
16A4:  MOVWF  x9B
16A6:  MOVLB  0
16A8:  RCALL  150C
....................    delay_ms(5); 
16AA:  MOVLW  05
16AC:  MOVLB  3
16AE:  MOVWF  x94
16B0:  MOVLB  0
16B2:  CALL   051A
....................    for(i=0;i<=3;++i) 
16B6:  MOVLB  3
16B8:  CLRF   x7B
16BA:  MOVF   x7B,W
16BC:  SUBLW  03
16BE:  BNC   16E2
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
16C0:  CLRF   03
16C2:  MOVF   x7B,W
16C4:  ADDLW  7C
16C6:  MOVWF  FE9
16C8:  MOVLW  03
16CA:  ADDWFC 03,W
16CC:  MOVWF  FEA
16CE:  MOVFF  FEF,380
16D2:  CLRF   x98
16D4:  MOVFF  380,399
16D8:  MOVLB  0
16DA:  RCALL  15F4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
16DC:  MOVLB  3
16DE:  INCF   x7B,F
16E0:  BRA    16BA
16E2:  MOVLB  0
16E4:  GOTO   7BFC (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
170A:  MOVLB  3
170C:  DECFSZ x95,W
170E:  BRA    1712
1710:  BRA    1718
....................       address=LCD_LINE_TWO; 
1712:  MOVLW  40
1714:  MOVWF  x96
1716:  BRA    171A
....................    else 
....................       address=0; 
1718:  CLRF   x96
....................       
....................    address+=x-1; 
171A:  MOVLW  01
171C:  SUBWF  x94,W
171E:  ADDWF  x96,F
....................    lcd_send_byte(0,0x80|address); 
1720:  MOVF   x96,W
1722:  IORLW  80
1724:  MOVWF  x97
1726:  CLRF   x98
1728:  MOVWF  x99
172A:  MOVLB  0
172C:  RCALL  15F4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
172E:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
1730:  MOVLB  3
1732:  MOVF   x93,W
1734:  XORLW  07
1736:  MOVLB  0
1738:  BZ    1748
173A:  XORLW  0B
173C:  BZ    1756
173E:  XORLW  06
1740:  BZ    1770
1742:  XORLW  02
1744:  BZ    1780
1746:  BRA    178E
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
1748:  MOVLW  01
174A:  MOVLB  3
174C:  MOVWF  x94
174E:  MOVWF  x95
1750:  MOVLB  0
1752:  RCALL  170A
1754:  BRA    179C
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
1756:  MOVLB  3
1758:  CLRF   x98
175A:  MOVLW  01
175C:  MOVWF  x99
175E:  MOVLB  0
1760:  RCALL  15F4
....................                      delay_ms(2); 
1762:  MOVLW  02
1764:  MOVLB  3
1766:  MOVWF  x94
1768:  MOVLB  0
176A:  CALL   051A
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
176E:  BRA    179C
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
1770:  MOVLW  01
1772:  MOVLB  3
1774:  MOVWF  x94
1776:  MOVLW  02
1778:  MOVWF  x95
177A:  MOVLB  0
177C:  RCALL  170A
177E:  BRA    179C
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
1780:  MOVLB  3
1782:  CLRF   x98
1784:  MOVLW  10
1786:  MOVWF  x99
1788:  MOVLB  0
178A:  RCALL  15F4
178C:  BRA    179C
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
178E:  MOVLW  01
1790:  MOVLB  3
1792:  MOVWF  x98
1794:  MOVFF  393,399
1798:  MOVLB  0
179A:  RCALL  15F4
....................      #endif 
....................    } 
179C:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
*
16E8:  MOVLB  3
16EA:  MOVF   x7B,F
16EC:  BZ    16FC
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
16EE:  CLRF   x98
16F0:  MOVLW  0F
16F2:  MOVWF  x99
16F4:  MOVLB  0
16F6:  RCALL  15F4
....................    } 
16F8:  BRA    1706
16FA:  MOVLB  3
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
16FC:  CLRF   x98
16FE:  MOVLW  0C
1700:  MOVWF  x99
1702:  MOVLB  0
1704:  RCALL  15F4
....................    } 
1706:  GOTO   7C08 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... TCP_SOCKET mySocket; 
....................  
.................... //Automatically generated functions to do ethernet 
.................... void IPAddressInit(void) 
.................... { 
....................    AppConfig.Flags.bIsDHCPEnabled = TRUE; 
*
0272:  BSF    4E.6
....................    DHCPEnable(0); //enable nicWide stack support. 
0274:  MOVLB  3
0276:  CLRF   x7B
0278:  MOVLB  0
027A:  BRA    0260
....................  
....................    //MAC address of this unit 
....................    MY_MAC_BYTE1=MY_DEFAULT_MAC_BYTE1; 
027C:  CLRF   4F
....................    MY_MAC_BYTE2=MY_DEFAULT_MAC_BYTE2; 
027E:  MOVLW  20
0280:  MOVWF  50
....................    MY_MAC_BYTE3=MY_DEFAULT_MAC_BYTE3; 
0282:  MOVLW  30
0284:  MOVWF  51
....................    MY_MAC_BYTE4=MY_DEFAULT_MAC_BYTE4; 
0286:  MOVLW  40
0288:  MOVWF  52
....................    MY_MAC_BYTE5=MY_DEFAULT_MAC_BYTE5; 
028A:  MOVLW  50
028C:  MOVWF  53
....................    MY_MAC_BYTE6=MY_DEFAULT_MAC_BYTE6; 
028E:  MOVLW  60
0290:  MOVWF  54
0292:  GOTO   7BEC (RETURN)
.................... } 
....................  
.................... /////////////////////////////////////////////// 
....................  
.................... //functions of the server 
....................  
.................... void output_digital(){ 
*
740A:  MOVLB  3
740C:  CLRF   x7B
.................... unsigned char done=0; 
.................... unsigned char buffer[1]={0}; 
740E:  CLRF   x7C
.................... unsigned char bit[1]={0}; 
7410:  CLRF   x7D
.................... while(!done){ 
7412:  MOVF   x7B,F
7414:  BTFSS  FD8.2
7416:  BRA    76BC
....................    StackTask(); 
7418:  MOVLB  0
741A:  RCALL  6D1C
....................    TCPGetArray(mySocket,buffer,1); 
741C:  MOVFF  376,392
7420:  MOVLW  03
7422:  MOVLB  3
7424:  MOVWF  x94
7426:  MOVLW  7C
7428:  MOVWF  x93
742A:  CLRF   x96
742C:  MOVLW  01
742E:  MOVWF  x95
7430:  MOVLB  0
7432:  RCALL  71EA
....................    switch (buffer[0]){ 
7434:  MOVLW  41
7436:  MOVLB  3
7438:  SUBWF  x7C,W
743A:  ADDLW  FB
743C:  BTFSC  FD8.0
743E:  BRA    76BA
7440:  ADDLW  05
7442:  MOVLB  0
7444:  GOTO   76C2
....................          case 'A':TCPGetArray(mySocket,buffer,1);TCPGetArray(mySocket,bit,1);buffer[0]-=48;output_bit(31744+buffer[0],bit[0]-48);done=1;break; 
7448:  MOVFF  376,392
744C:  MOVLW  03
744E:  MOVLB  3
7450:  MOVWF  x94
7452:  MOVLW  7C
7454:  MOVWF  x93
7456:  CLRF   x96
7458:  MOVLW  01
745A:  MOVWF  x95
745C:  MOVLB  0
745E:  RCALL  71EA
7460:  MOVFF  376,392
7464:  MOVLW  03
7466:  MOVLB  3
7468:  MOVWF  x94
746A:  MOVLW  7D
746C:  MOVWF  x93
746E:  CLRF   x96
7470:  MOVLW  01
7472:  MOVWF  x95
7474:  MOVLB  0
7476:  RCALL  71EA
7478:  MOVLW  30
747A:  MOVLB  3
747C:  SUBWF  x7C,F
747E:  MOVFF  37C,37E
7482:  MOVLW  7C
7484:  MOVWF  x7F
7486:  MOVLW  30
7488:  SUBWF  x7D,W
748A:  BNZ   7490
748C:  MOVLW  00
748E:  BRA    7492
7490:  MOVLW  01
7492:  MOVFF  37E,380
7496:  MOVWF  x81
7498:  MOVLW  0F
749A:  MOVWF  x83
749C:  MOVLW  89
749E:  MOVWF  x82
74A0:  MOVLB  0
74A2:  RCALL  73C8
74A4:  MOVFF  37E,380
74A8:  MOVLB  3
74AA:  CLRF   x81
74AC:  MOVLW  0F
74AE:  MOVWF  x83
74B0:  MOVLW  92
74B2:  MOVWF  x82
74B4:  MOVLB  0
74B6:  RCALL  73C8
74B8:  MOVLW  01
74BA:  MOVLB  3
74BC:  MOVWF  x7B
74BE:  BRA    76BA
....................          case 'B':TCPGetArray(mySocket,buffer,1);TCPGetArray(mySocket,bit,1);buffer[0]-=48;output_bit(31752+buffer[0],bit[0]-48);done=1;break; 
74C0:  MOVFF  376,392
74C4:  MOVLW  03
74C6:  MOVLB  3
74C8:  MOVWF  x94
74CA:  MOVLW  7C
74CC:  MOVWF  x93
74CE:  CLRF   x96
74D0:  MOVLW  01
74D2:  MOVWF  x95
74D4:  MOVLB  0
74D6:  RCALL  71EA
74D8:  MOVFF  376,392
74DC:  MOVLW  03
74DE:  MOVLB  3
74E0:  MOVWF  x94
74E2:  MOVLW  7D
74E4:  MOVWF  x93
74E6:  CLRF   x96
74E8:  MOVLW  01
74EA:  MOVWF  x95
74EC:  MOVLB  0
74EE:  RCALL  71EA
74F0:  MOVLW  30
74F2:  MOVLB  3
74F4:  SUBWF  x7C,F
74F6:  MOVLW  08
74F8:  ADDWF  x7C,W
74FA:  MOVWF  x7E
74FC:  MOVLW  7C
74FE:  MOVWF  x7F
7500:  BTFSC  FD8.0
7502:  INCF   x7F,F
7504:  MOVLW  30
7506:  SUBWF  x7D,W
7508:  BNZ   750E
750A:  MOVLW  00
750C:  BRA    7510
750E:  MOVLW  01
7510:  MOVFF  37E,380
7514:  MOVWF  x81
7516:  MOVLW  0F
7518:  MOVWF  x83
751A:  MOVLW  89
751C:  MOVWF  x82
751E:  MOVLB  0
7520:  RCALL  73C8
7522:  MOVFF  37E,380
7526:  MOVLB  3
7528:  CLRF   x81
752A:  MOVLW  0F
752C:  MOVWF  x83
752E:  MOVLW  92
7530:  MOVWF  x82
7532:  MOVLB  0
7534:  RCALL  73C8
7536:  MOVLW  01
7538:  MOVLB  3
753A:  MOVWF  x7B
753C:  BRA    76BA
....................          case 'C':TCPGetArray(mySocket,buffer,1);TCPGetArray(mySocket,bit,1);buffer[0]-=48;output_bit(31760+buffer[0],bit[0]-48);done=1;break; 
753E:  MOVFF  376,392
7542:  MOVLW  03
7544:  MOVLB  3
7546:  MOVWF  x94
7548:  MOVLW  7C
754A:  MOVWF  x93
754C:  CLRF   x96
754E:  MOVLW  01
7550:  MOVWF  x95
7552:  MOVLB  0
7554:  RCALL  71EA
7556:  MOVFF  376,392
755A:  MOVLW  03
755C:  MOVLB  3
755E:  MOVWF  x94
7560:  MOVLW  7D
7562:  MOVWF  x93
7564:  CLRF   x96
7566:  MOVLW  01
7568:  MOVWF  x95
756A:  MOVLB  0
756C:  RCALL  71EA
756E:  MOVLW  30
7570:  MOVLB  3
7572:  SUBWF  x7C,F
7574:  MOVLW  10
7576:  ADDWF  x7C,W
7578:  MOVWF  x7E
757A:  MOVLW  7C
757C:  MOVWF  x7F
757E:  BTFSC  FD8.0
7580:  INCF   x7F,F
7582:  MOVLW  30
7584:  SUBWF  x7D,W
7586:  BNZ   758C
7588:  MOVLW  00
758A:  BRA    758E
758C:  MOVLW  01
758E:  MOVFF  37E,380
7592:  MOVWF  x81
7594:  MOVLW  0F
7596:  MOVWF  x83
7598:  MOVLW  89
759A:  MOVWF  x82
759C:  MOVLB  0
759E:  RCALL  73C8
75A0:  MOVFF  37E,380
75A4:  MOVLB  3
75A6:  CLRF   x81
75A8:  MOVLW  0F
75AA:  MOVWF  x83
75AC:  MOVLW  92
75AE:  MOVWF  x82
75B0:  MOVLB  0
75B2:  RCALL  73C8
75B4:  MOVLW  01
75B6:  MOVLB  3
75B8:  MOVWF  x7B
75BA:  BRA    76BA
....................          case 'D':TCPGetArray(mySocket,buffer,1);TCPGetArray(mySocket,bit,1);buffer[0]-=48;output_bit(31768+buffer[0],bit[0]-48);done=1;break; 
75BC:  MOVFF  376,392
75C0:  MOVLW  03
75C2:  MOVLB  3
75C4:  MOVWF  x94
75C6:  MOVLW  7C
75C8:  MOVWF  x93
75CA:  CLRF   x96
75CC:  MOVLW  01
75CE:  MOVWF  x95
75D0:  MOVLB  0
75D2:  RCALL  71EA
75D4:  MOVFF  376,392
75D8:  MOVLW  03
75DA:  MOVLB  3
75DC:  MOVWF  x94
75DE:  MOVLW  7D
75E0:  MOVWF  x93
75E2:  CLRF   x96
75E4:  MOVLW  01
75E6:  MOVWF  x95
75E8:  MOVLB  0
75EA:  RCALL  71EA
75EC:  MOVLW  30
75EE:  MOVLB  3
75F0:  SUBWF  x7C,F
75F2:  MOVLW  18
75F4:  ADDWF  x7C,W
75F6:  MOVWF  x7E
75F8:  MOVLW  7C
75FA:  MOVWF  x7F
75FC:  BTFSC  FD8.0
75FE:  INCF   x7F,F
7600:  MOVLW  30
7602:  SUBWF  x7D,W
7604:  BNZ   760A
7606:  MOVLW  00
7608:  BRA    760C
760A:  MOVLW  01
760C:  MOVFF  37E,380
7610:  MOVWF  x81
7612:  MOVLW  0F
7614:  MOVWF  x83
7616:  MOVLW  89
7618:  MOVWF  x82
761A:  MOVLB  0
761C:  RCALL  73C8
761E:  MOVFF  37E,380
7622:  MOVLB  3
7624:  CLRF   x81
7626:  MOVLW  0F
7628:  MOVWF  x83
762A:  MOVLW  92
762C:  MOVWF  x82
762E:  MOVLB  0
7630:  RCALL  73C8
7632:  MOVLW  01
7634:  MOVLB  3
7636:  MOVWF  x7B
7638:  BRA    76BA
....................          case 'E':TCPGetArray(mySocket,buffer,1);TCPGetArray(mySocket,bit,1);buffer[0]-=48;output_bit(31776+buffer[0],bit[0]-48);done=1;break; 
763A:  MOVFF  376,392
763E:  MOVLW  03
7640:  MOVLB  3
7642:  MOVWF  x94
7644:  MOVLW  7C
7646:  MOVWF  x93
7648:  CLRF   x96
764A:  MOVLW  01
764C:  MOVWF  x95
764E:  MOVLB  0
7650:  RCALL  71EA
7652:  MOVFF  376,392
7656:  MOVLW  03
7658:  MOVLB  3
765A:  MOVWF  x94
765C:  MOVLW  7D
765E:  MOVWF  x93
7660:  CLRF   x96
7662:  MOVLW  01
7664:  MOVWF  x95
7666:  MOVLB  0
7668:  RCALL  71EA
766A:  MOVLW  30
766C:  MOVLB  3
766E:  SUBWF  x7C,F
7670:  MOVLW  20
7672:  ADDWF  x7C,W
7674:  MOVWF  x7E
7676:  MOVLW  7C
7678:  MOVWF  x7F
767A:  BTFSC  FD8.0
767C:  INCF   x7F,F
767E:  MOVLW  30
7680:  SUBWF  x7D,W
7682:  BNZ   7688
7684:  MOVLW  00
7686:  BRA    768A
7688:  MOVLW  01
768A:  MOVFF  37E,380
768E:  MOVWF  x81
7690:  MOVLW  0F
7692:  MOVWF  x83
7694:  MOVLW  89
7696:  MOVWF  x82
7698:  MOVLB  0
769A:  RCALL  73C8
769C:  MOVFF  37E,380
76A0:  MOVLB  3
76A2:  CLRF   x81
76A4:  MOVLW  0F
76A6:  MOVWF  x83
76A8:  MOVLW  92
76AA:  MOVWF  x82
76AC:  MOVLB  0
76AE:  RCALL  73C8
76B0:  MOVLW  01
76B2:  MOVLB  3
76B4:  MOVWF  x7B
76B6:  BRA    76BA
76B8:  MOVLB  3
....................       } 
76BA:  BRA    7412
....................    } 
76BC:  MOVLB  0
76BE:  GOTO   7D86 (RETURN)
.................... } 
....................  
.................... void read_digital(){ 
*
7900:  MOVLB  3
7902:  CLRF   x7B
.................... unsigned char done=0; 
.................... unsigned char buffer[1]={0}; 
7904:  CLRF   x7C
.................... while(!done){ 
7906:  MOVF   x7B,F
7908:  BNZ   798A
....................    StackTask(); 
790A:  MOVLB  0
790C:  CALL   6D1C
....................    TCPGetArray(mySocket,buffer,1); 
7910:  MOVFF  376,392
7914:  MOVLW  03
7916:  MOVLB  3
7918:  MOVWF  x94
791A:  MOVLW  7C
791C:  MOVWF  x93
791E:  CLRF   x96
7920:  MOVLW  01
7922:  MOVWF  x95
7924:  MOVLB  0
7926:  RCALL  71EA
....................    switch (buffer[0]){ 
7928:  MOVLW  41
792A:  MOVLB  3
792C:  SUBWF  x7C,W
792E:  ADDLW  FB
7930:  BC    7988
7932:  ADDLW  05
7934:  MOVLB  0
7936:  GOTO   799A
....................          case 'A':buffer[0]=input_a();done=1;break; 
793A:  SETF   F92
793C:  MOVFF  F80,37C
7940:  MOVLW  01
7942:  MOVLB  3
7944:  MOVWF  x7B
7946:  BRA    7988
....................          case 'B':buffer[0]=input_b();done=1;break; 
7948:  SETF   F93
794A:  MOVFF  F81,37C
794E:  MOVLW  01
7950:  MOVLB  3
7952:  MOVWF  x7B
7954:  BRA    7988
....................          case 'C':buffer[0]=input_c();done=1;break; 
7956:  SETF   F94
7958:  MOVFF  F82,37C
795C:  MOVLW  01
795E:  MOVLB  3
7960:  MOVWF  x7B
7962:  BRA    7988
....................          case 'D':buffer[0]=input_d();done=1;break; 
7964:  SETF   F95
7966:  MOVFF  F83,37C
796A:  MOVLW  01
796C:  MOVLB  3
796E:  MOVWF  x7B
7970:  BRA    7988
....................          case 'E':buffer[0]=input_e();done=1;break; 
7972:  BSF    F96.0
7974:  BSF    F96.1
7976:  BSF    F96.2
7978:  BSF    F96.3
797A:  MOVFF  F84,37C
797E:  MOVLW  01
7980:  MOVLB  3
7982:  MOVWF  x7B
7984:  BRA    7988
7986:  MOVLB  3
....................       } 
7988:  BRA    7906
....................    } 
.................... TCPPut(mySocket,buffer[0]); 
798A:  MOVFF  376,381
798E:  MOVFF  37C,382
7992:  MOVLB  0
7994:  RCALL  77DE
7996:  GOTO   7D86 (RETURN)
.................... } 
....................  
.................... void read_analogue()   //Example of ADC reading value 
*
79C8:  MOVLB  3
79CA:  CLRF   x7B
*
79CE:  CLRF   x7E
79D0:  CLRF   x7D
79D2:  CLRF   x7F
79D4:  CLRF   x80
.................... { 
.................... unsigned char done=0; 
.................... unsigned char buffer[1]={0}; 
*
79CC:  CLRF   x7C
.................... int value=0; 
.................... char l=0; 
.................... char h=0; 
.................... while(!done){ 
*
79D6:  MOVF   x7B,F
79D8:  BNZ   7A56
....................    StackTask(); 
79DA:  MOVLB  0
79DC:  CALL   6D1C
....................    TCPGetArray(mySocket,buffer,1); 
79E0:  MOVFF  376,392
79E4:  MOVLW  03
79E6:  MOVLB  3
79E8:  MOVWF  x94
79EA:  MOVLW  7C
79EC:  MOVWF  x93
79EE:  CLRF   x96
79F0:  MOVLW  01
79F2:  MOVWF  x95
79F4:  MOVLB  0
79F6:  CALL   71EA
....................    if (buffer[0]!=0){ 
79FA:  MOVLB  3
79FC:  MOVF   x7C,F
79FE:  BZ    7A54
....................          set_adc_channel(buffer[0]-48); 
7A00:  MOVLW  30
7A02:  SUBWF  x7C,W
7A04:  MOVWF  x81
7A06:  RLCF   x81,W
7A08:  MOVWF  00
7A0A:  RLCF   00,F
7A0C:  MOVLW  FC
7A0E:  ANDWF  00,F
7A10:  MOVF   FC2,W
7A12:  ANDLW  C3
7A14:  IORWF  00,W
7A16:  MOVWF  FC2
....................          delay_us(100); 
7A18:  MOVLW  42
7A1A:  MOVWF  00
7A1C:  DECFSZ 00,F
7A1E:  BRA    7A1C
7A20:  NOP   
....................          value=read_adc(); 
7A22:  BSF    FC2.1
7A24:  BTFSC  FC2.1
7A26:  BRA    7A24
7A28:  MOVFF  FC3,37D
7A2C:  MOVFF  FC4,37E
....................          l=value; 
7A30:  MOVFF  37D,37F
....................          h=value>>8; 
7A34:  MOVF   x7E,W
7A36:  MOVWF  x80
....................          TCPPut(mySocket,l); 
7A38:  MOVFF  376,381
7A3C:  MOVFF  37F,382
7A40:  MOVLB  0
7A42:  RCALL  77DE
....................          TCPPut(mySocket,h); 
7A44:  MOVFF  376,381
7A48:  MOVFF  380,382
7A4C:  RCALL  77DE
....................          done=1; 
7A4E:  MOVLW  01
7A50:  MOVLB  3
7A52:  MOVWF  x7B
....................       } 
7A54:  BRA    79D6
....................    } 
7A56:  MOVLB  0
7A58:  GOTO   7D86 (RETURN)
.................... } 
....................  
.................... void write_lcd(){ 
7A5C:  MOVLB  3
7A5E:  CLRF   x7B
*
7A8A:  CLRF   x91
.................... unsigned char done=0; 
.................... unsigned char buffer[1]={0}; 
*
7A60:  CLRF   x7C
.................... unsigned char str[20]={0}; 
7A62:  CLRF   x7D
7A64:  CLRF   x7E
7A66:  CLRF   x7F
7A68:  CLRF   x80
7A6A:  CLRF   x81
7A6C:  CLRF   x82
7A6E:  CLRF   x83
7A70:  CLRF   x84
7A72:  CLRF   x85
7A74:  CLRF   x86
7A76:  CLRF   x87
7A78:  CLRF   x88
7A7A:  CLRF   x89
7A7C:  CLRF   x8A
7A7E:  CLRF   x8B
7A80:  CLRF   x8C
7A82:  CLRF   x8D
7A84:  CLRF   x8E
7A86:  CLRF   x8F
7A88:  CLRF   x90
.................... unsigned char counter=0; 
.................... while(!done){ 
*
7A8C:  MOVF   x7B,F
7A8E:  BNZ   7AFE
....................    StackTask(); 
7A90:  MOVLB  0
7A92:  CALL   6D1C
....................    TCPGetArray(mySocket,buffer,1); 
7A96:  MOVFF  376,392
7A9A:  MOVLW  03
7A9C:  MOVLB  3
7A9E:  MOVWF  x94
7AA0:  MOVLW  7C
7AA2:  MOVWF  x93
7AA4:  CLRF   x96
7AA6:  MOVLW  01
7AA8:  MOVWF  x95
7AAA:  MOVLB  0
7AAC:  CALL   71EA
....................    if (buffer[0]!=0){ 
7AB0:  MOVLB  3
7AB2:  MOVF   x7C,F
7AB4:  BZ    7AFC
....................       //buffer[0]-=48; 
....................       TCPGetArray(mySocket,str,buffer[0]); 
7AB6:  MOVFF  376,392
7ABA:  MOVLW  03
7ABC:  MOVWF  x94
7ABE:  MOVLW  7D
7AC0:  MOVWF  x93
7AC2:  CLRF   x96
7AC4:  MOVFF  37C,395
7AC8:  MOVLB  0
7ACA:  CALL   71EA
....................       while (counter<buffer[0]){ 
7ACE:  MOVLB  3
7AD0:  MOVF   x7C,W
7AD2:  SUBWF  x91,W
7AD4:  BC    7AF8
....................          lcd_putc(str[counter]); 
7AD6:  CLRF   03
7AD8:  MOVF   x91,W
7ADA:  ADDLW  7D
7ADC:  MOVWF  FE9
7ADE:  MOVLW  03
7AE0:  ADDWFC 03,W
7AE2:  MOVWF  FEA
7AE4:  MOVFF  FEF,392
7AE8:  MOVFF  392,393
7AEC:  MOVLB  0
7AEE:  CALL   1730
....................          counter++; 
7AF2:  MOVLB  3
7AF4:  INCF   x91,F
7AF6:  BRA    7AD0
....................       } 
....................       done=1; 
7AF8:  MOVLW  01
7AFA:  MOVWF  x7B
....................    } 
7AFC:  BRA    7A8C
.................... } 
7AFE:  MOVLB  0
7B00:  GOTO   7D86 (RETURN)
.................... } 
....................  
.................... char print_my_ip(){ 
.................... if (MY_IP_BYTE1==0) return 0; 
*
6F2A:  MOVF   22,F
6F2C:  BNZ   6F34
6F2E:  MOVLW  00
6F30:  MOVWF  01
6F32:  BRA    7134
.................... lcd_putc(MY_IP_BYTE1/100+48); 
6F34:  MOVFF  22,37C
6F38:  MOVLW  64
6F3A:  MOVLB  3
6F3C:  MOVWF  x7D
6F3E:  MOVLB  0
6F40:  RCALL  6EFE
6F42:  MOVLW  30
6F44:  ADDWF  01,W
6F46:  MOVLB  3
6F48:  MOVWF  x7B
6F4A:  MOVWF  x93
6F4C:  MOVLB  0
6F4E:  CALL   1730
.................... lcd_putc((MY_IP_BYTE1%100)/10+48); 
6F52:  MOVFF  22,37C
6F56:  MOVLW  64
6F58:  MOVLB  3
6F5A:  MOVWF  x7D
6F5C:  MOVLB  0
6F5E:  RCALL  6EFE
6F60:  MOVFF  00,37C
6F64:  MOVLW  0A
6F66:  MOVLB  3
6F68:  MOVWF  x7D
6F6A:  MOVLB  0
6F6C:  RCALL  6EFE
6F6E:  MOVLW  30
6F70:  ADDWF  01,W
6F72:  MOVLB  3
6F74:  MOVWF  x7B
6F76:  MOVWF  x93
6F78:  MOVLB  0
6F7A:  CALL   1730
.................... lcd_putc((MY_IP_BYTE1%100)%10+48); 
6F7E:  MOVFF  22,37C
6F82:  MOVLW  64
6F84:  MOVLB  3
6F86:  MOVWF  x7D
6F88:  MOVLB  0
6F8A:  RCALL  6EFE
6F8C:  MOVFF  00,37C
6F90:  MOVLW  0A
6F92:  MOVLB  3
6F94:  MOVWF  x7D
6F96:  MOVLB  0
6F98:  RCALL  6EFE
6F9A:  MOVLW  30
6F9C:  ADDWF  00,W
6F9E:  MOVLB  3
6FA0:  MOVWF  x7B
6FA2:  MOVWF  x93
6FA4:  MOVLB  0
6FA6:  CALL   1730
.................... lcd_putc('.'); 
6FAA:  MOVLW  2E
6FAC:  MOVLB  3
6FAE:  MOVWF  x93
6FB0:  MOVLB  0
6FB2:  CALL   1730
.................... lcd_putc(MY_IP_BYTE2/100+48); 
6FB6:  MOVFF  23,37C
6FBA:  MOVLW  64
6FBC:  MOVLB  3
6FBE:  MOVWF  x7D
6FC0:  MOVLB  0
6FC2:  RCALL  6EFE
6FC4:  MOVLW  30
6FC6:  ADDWF  01,W
6FC8:  MOVLB  3
6FCA:  MOVWF  x7B
6FCC:  MOVWF  x93
6FCE:  MOVLB  0
6FD0:  CALL   1730
.................... lcd_putc((MY_IP_BYTE2%100)/10+48); 
6FD4:  MOVFF  23,37C
6FD8:  MOVLW  64
6FDA:  MOVLB  3
6FDC:  MOVWF  x7D
6FDE:  MOVLB  0
6FE0:  RCALL  6EFE
6FE2:  MOVFF  00,37C
6FE6:  MOVLW  0A
6FE8:  MOVLB  3
6FEA:  MOVWF  x7D
6FEC:  MOVLB  0
6FEE:  RCALL  6EFE
6FF0:  MOVLW  30
6FF2:  ADDWF  01,W
6FF4:  MOVLB  3
6FF6:  MOVWF  x7B
6FF8:  MOVWF  x93
6FFA:  MOVLB  0
6FFC:  CALL   1730
.................... lcd_putc((MY_IP_BYTE2%100)%10+48); 
7000:  MOVFF  23,37C
7004:  MOVLW  64
7006:  MOVLB  3
7008:  MOVWF  x7D
700A:  MOVLB  0
700C:  RCALL  6EFE
700E:  MOVFF  00,37C
7012:  MOVLW  0A
7014:  MOVLB  3
7016:  MOVWF  x7D
7018:  MOVLB  0
701A:  RCALL  6EFE
701C:  MOVLW  30
701E:  ADDWF  00,W
7020:  MOVLB  3
7022:  MOVWF  x7B
7024:  MOVWF  x93
7026:  MOVLB  0
7028:  CALL   1730
.................... lcd_putc('.'); 
702C:  MOVLW  2E
702E:  MOVLB  3
7030:  MOVWF  x93
7032:  MOVLB  0
7034:  CALL   1730
.................... lcd_putc(MY_IP_BYTE3/100+48); 
7038:  MOVFF  24,37C
703C:  MOVLW  64
703E:  MOVLB  3
7040:  MOVWF  x7D
7042:  MOVLB  0
7044:  RCALL  6EFE
7046:  MOVLW  30
7048:  ADDWF  01,W
704A:  MOVLB  3
704C:  MOVWF  x7B
704E:  MOVWF  x93
7050:  MOVLB  0
7052:  CALL   1730
.................... lcd_putc((MY_IP_BYTE3%100)/10+48); 
7056:  MOVFF  24,37C
705A:  MOVLW  64
705C:  MOVLB  3
705E:  MOVWF  x7D
7060:  MOVLB  0
7062:  RCALL  6EFE
7064:  MOVFF  00,37C
7068:  MOVLW  0A
706A:  MOVLB  3
706C:  MOVWF  x7D
706E:  MOVLB  0
7070:  RCALL  6EFE
7072:  MOVLW  30
7074:  ADDWF  01,W
7076:  MOVLB  3
7078:  MOVWF  x7B
707A:  MOVWF  x93
707C:  MOVLB  0
707E:  CALL   1730
.................... lcd_putc((MY_IP_BYTE3%100)%10+48); 
7082:  MOVFF  24,37C
7086:  MOVLW  64
7088:  MOVLB  3
708A:  MOVWF  x7D
708C:  MOVLB  0
708E:  RCALL  6EFE
7090:  MOVFF  00,37C
7094:  MOVLW  0A
7096:  MOVLB  3
7098:  MOVWF  x7D
709A:  MOVLB  0
709C:  RCALL  6EFE
709E:  MOVLW  30
70A0:  ADDWF  00,W
70A2:  MOVLB  3
70A4:  MOVWF  x7B
70A6:  MOVWF  x93
70A8:  MOVLB  0
70AA:  CALL   1730
.................... lcd_putc('.'); 
70AE:  MOVLW  2E
70B0:  MOVLB  3
70B2:  MOVWF  x93
70B4:  MOVLB  0
70B6:  CALL   1730
.................... lcd_putc(MY_IP_BYTE4/100+48); 
70BA:  MOVFF  25,37C
70BE:  MOVLW  64
70C0:  MOVLB  3
70C2:  MOVWF  x7D
70C4:  MOVLB  0
70C6:  RCALL  6EFE
70C8:  MOVLW  30
70CA:  ADDWF  01,W
70CC:  MOVLB  3
70CE:  MOVWF  x7B
70D0:  MOVWF  x93
70D2:  MOVLB  0
70D4:  CALL   1730
.................... lcd_putc((MY_IP_BYTE4%100)/10+48); 
70D8:  MOVFF  25,37C
70DC:  MOVLW  64
70DE:  MOVLB  3
70E0:  MOVWF  x7D
70E2:  MOVLB  0
70E4:  RCALL  6EFE
70E6:  MOVFF  00,37C
70EA:  MOVLW  0A
70EC:  MOVLB  3
70EE:  MOVWF  x7D
70F0:  MOVLB  0
70F2:  RCALL  6EFE
70F4:  MOVLW  30
70F6:  ADDWF  01,W
70F8:  MOVLB  3
70FA:  MOVWF  x7B
70FC:  MOVWF  x93
70FE:  MOVLB  0
7100:  CALL   1730
.................... lcd_putc((MY_IP_BYTE4%100)%10+48); 
7104:  MOVFF  25,37C
7108:  MOVLW  64
710A:  MOVLB  3
710C:  MOVWF  x7D
710E:  MOVLB  0
7110:  RCALL  6EFE
7112:  MOVFF  00,37C
7116:  MOVLW  0A
7118:  MOVLB  3
711A:  MOVWF  x7D
711C:  MOVLB  0
711E:  RCALL  6EFE
7120:  MOVLW  30
7122:  ADDWF  00,W
7124:  MOVLB  3
7126:  MOVWF  x7B
7128:  MOVWF  x93
712A:  MOVLB  0
712C:  CALL   1730
.................... return 1; 
7130:  MOVLW  01
7132:  MOVWF  01
7134:  GOTO   7C36 (RETURN)
.................... } 
....................  
.................... /////////////////////////////////////////////// 
.................... void main() 
*
7B04:  CLRF   FF8
7B06:  BCF    FD0.7
7B08:  BSF    07.7
7B0A:  MOVLW  FE
7B0C:  MOVWF  00
7B0E:  MOVLW  0D
7B10:  MOVWF  01
7B12:  MOVLW  02
7B14:  MOVWF  FE9
7B16:  MOVLW  00
7B18:  MOVWF  FEA
7B1A:  CLRF   FEE
7B1C:  CLRWDT
7B1E:  DECFSZ 00,F
7B20:  BRA    7B1A
7B22:  DECFSZ 01,F
7B24:  BRA    7B1A
7B26:  MOVLB  1
7B28:  BCF    x0B.0
7B2A:  BCF    x0B.1
7B2C:  MOVLW  41
7B2E:  MOVWF  x0F
7B30:  MOVLW  FE
7B32:  MOVWF  x0E
7B34:  MOVLW  9F
7B36:  MOVWF  x0D
7B38:  MOVLW  9E
7B3A:  MOVWF  x0C
7B3C:  CLRF   x17
7B3E:  CLRF   x16
7B40:  CLRF   x15
7B42:  CLRF   x14
7B44:  CLRF   x24
7B46:  CLRF   x23
7B48:  BCF    x0B.3
7B4A:  SETF   x30
7B4C:  SETF   x36
7B4E:  BCF    x0B.4
7B50:  MOVLW  FE
7B52:  MOVWF  x9C
7B54:  MOVWF  xF5
7B56:  MOVLB  3
7B58:  CLRF   x3A
7B5A:  CLRF   x39
7B5C:  MOVF   FC1,W
7B5E:  ANDLW  C0
7B60:  IORLW  0F
7B62:  MOVWF  FC1
7B64:  MOVLW  07
7B66:  MOVWF  FB4
7B68:  BRA    7B94
7B6A:  DATA 06,00
7B6C:  DATA 1C,08
7B6E:  DATA 00,DC
7B70:  DATA 05,F4
7B72:  DATA 01,1D
7B74:  DATA 03,3B
7B76:  DATA 20,00
7B78:  DATA 3F,00
7B7A:  DATA 47,45
7B7C:  DATA 54,00
7B7E:  DATA 50,4F
7B80:  DATA 53,54
7B82:  DATA 00,43
7B84:  DATA 6F,6E
7B86:  DATA 74,65
7B88:  DATA 6E,74
7B8A:  DATA 2D,4C
7B8C:  DATA 65,6E
7B8E:  DATA 67,74
7B90:  DATA 68,3A
7B92:  DATA 00,00
7B94:  MOVLW  00
7B96:  MOVWF  FF8
7B98:  MOVLW  7B
7B9A:  MOVWF  FF7
7B9C:  MOVLW  6A
7B9E:  MOVWF  FF6
7BA0:  TBLRD*+
7BA2:  MOVF   FF5,W
7BA4:  MOVWF  00
7BA6:  XORLW  00
7BA8:  BZ    7BD0
7BAA:  TBLRD*+
7BAC:  MOVF   FF5,W
7BAE:  MOVWF  01
7BB0:  BTFSC  FE8.7
7BB2:  BRA    7BBE
7BB4:  ANDLW  0F
7BB6:  MOVWF  FEA
7BB8:  TBLRD*+
7BBA:  MOVFF  FF5,FE9
7BBE:  BTFSC  01.6
7BC0:  TBLRD*+
7BC2:  BTFSS  01.6
7BC4:  TBLRD*+
7BC6:  MOVFF  FF5,FEE
7BCA:  DCFSNZ 00,F
7BCC:  BRA    7BA0
7BCE:  BRA    7BC2
7BD0:  CLRF   FF8
.................... { 
....................    setup_adc(ADC_READ_ONLY); //prepare analogue port for usage 
7BD2:  MOVF   FC0,W
7BD4:  ANDLW  C0
7BD6:  IORLW  06
7BD8:  MOVWF  FC0
7BDA:  BCF    FC0.7
7BDC:  BSF    FC2.0
....................    setup_adc_ports(AN0_TO_AN7); //set portA pins to work in ADC mode 
7BDE:  MOVF   FC1,W
7BE0:  ANDLW  C0
7BE2:  IORLW  07
7BE4:  MOVWF  FC1
....................  
....................    IPAddressInit(); 
7BE6:  MOVLB  0
7BE8:  GOTO   0272
....................    TickInit(); 
7BEC:  GOTO   0296
....................    enable_interrupts(GLOBAL); 
7BF0:  MOVLW  C0
7BF2:  IORWF  FF2,F
....................    StackInit(); 
7BF4:  GOTO   14AE
....................  
....................  
....................    lcd_init(); 
7BF8:  GOTO   1646
....................    lcd_cursor_on(1);//enable cursor 
7BFC:  MOVLW  01
7BFE:  MOVLB  3
7C00:  MOVWF  x7B
7C02:  MOVLB  0
7C04:  GOTO   16E8
....................    lcd_putc("Welcome\n"); 
7C08:  MOVLW  22
7C0A:  MOVWF  FF6
7C0C:  MOVLW  02
7C0E:  MOVWF  FF7
7C10:  CALL   179E
....................     
....................    unsigned char temp[2]={0};//buffer to store the recieved bytes 
7C14:  MOVLB  3
7C16:  CLRF   x77
7C18:  CLRF   x78
....................    char exit=0; 
....................    char got_ip=0; 
7C1A:  CLRF   x79
7C1C:  CLRF   x7A
....................     
....................    while(!exit) 
7C1E:  MOVF   x79,F
7C20:  BTFSS  FD8.2
7C22:  BRA    7D8A
....................    { 
....................       StackTask(); 
7C24:  MOVLB  0
7C26:  CALL   6D1C
....................       if (!got_ip) got_ip=print_my_ip(); 
7C2A:  MOVLB  3
7C2C:  MOVF   x7A,F
7C2E:  BNZ   7C3C
7C30:  MOVLB  0
7C32:  GOTO   6F2A
7C36:  MOVFF  01,37A
7C3A:  MOVLB  3
....................       if (TCPIsConnected(mySocket)) //check if client is connected 
7C3C:  MOVFF  376,37B
7C40:  MOVLB  0
7C42:  GOTO   7138
7C46:  MOVF   01,F
7C48:  BTFSC  FD8.2
7C4A:  BRA    7D86
....................       { 
....................          TCPGetArray(mySocket,temp,2); //receive two bytes and store them in temp 
7C4C:  MOVFF  376,392
7C50:  MOVLW  03
7C52:  MOVLB  3
7C54:  MOVWF  x94
7C56:  MOVLW  77
7C58:  MOVWF  x93
7C5A:  CLRF   x96
7C5C:  MOVLW  02
7C5E:  MOVWF  x95
7C60:  MOVLB  0
7C62:  CALL   71EA
....................          //delay_ms(500); 
....................          //switch to call the apropriate function 
....................          switch(temp){ 
7C66:  MOVLW  42
7C68:  MOVWF  FF6
7C6A:  MOVLW  02
7C6C:  MOVWF  FF7
7C6E:  MOVLW  03
7C70:  MOVWF  FEA
7C72:  MOVLW  77
7C74:  MOVWF  FE9
7C76:  GOTO   7362
7C7A:  MOVF   01,W
7C7C:  BZ    7C90
7C7E:  XORLW  01
7C80:  BZ    7CD6
7C82:  XORLW  03
7C84:  BZ    7D04
7C86:  XORLW  01
7C88:  BZ    7D30
7C8A:  XORLW  07
7C8C:  BZ    7D5C
7C8E:  BRA    7D86
....................          case "di" : temp="00";TCPClose(mySocket);lcd_putc("\fClient\ndisconnected");exit=1;break; 
7C90:  MOVLW  03
7C92:  MOVWF  FEA
7C94:  MOVLW  77
7C96:  MOVWF  FE9
7C98:  MOVFF  FF2,37B
7C9C:  BCF    FF2.7
7C9E:  MOVLW  00
7CA0:  CALL   0096
7CA4:  TBLRD*-
7CA6:  TBLRD*+
7CA8:  MOVF   FF5,W
7CAA:  MOVWF  FEE
7CAC:  IORLW  00
7CAE:  BNZ   7CA6
7CB0:  MOVLB  3
7CB2:  BTFSC  x7B.7
7CB4:  BSF    FF2.7
7CB6:  MOVFF  376,37B
7CBA:  MOVLB  0
7CBC:  GOTO   739E
7CC0:  MOVLW  2C
7CC2:  MOVWF  FF6
7CC4:  MOVLW  02
7CC6:  MOVWF  FF7
7CC8:  CALL   179E
7CCC:  MOVLW  01
7CCE:  MOVLB  3
7CD0:  MOVWF  x79
7CD2:  MOVLB  0
7CD4:  BRA    7D86
....................          case "od" : temp="00";output_digital();break; 
7CD6:  MOVLW  03
7CD8:  MOVWF  FEA
7CDA:  MOVLW  77
7CDC:  MOVWF  FE9
7CDE:  MOVFF  FF2,37B
7CE2:  BCF    FF2.7
7CE4:  MOVLW  00
7CE6:  CALL   0096
7CEA:  TBLRD*-
7CEC:  TBLRD*+
7CEE:  MOVF   FF5,W
7CF0:  MOVWF  FEE
7CF2:  IORLW  00
7CF4:  BNZ   7CEC
7CF6:  MOVLB  3
7CF8:  BTFSC  x7B.7
7CFA:  BSF    FF2.7
7CFC:  MOVLB  0
7CFE:  GOTO   740A
7D02:  BRA    7D86
....................          case "rd" : temp="00";read_digital();break; 
7D04:  MOVLW  03
7D06:  MOVWF  FEA
7D08:  MOVLW  77
7D0A:  MOVWF  FE9
7D0C:  MOVFF  FF2,37B
7D10:  BCF    FF2.7
7D12:  MOVLW  00
7D14:  CALL   0096
7D18:  TBLRD*-
7D1A:  TBLRD*+
7D1C:  MOVF   FF5,W
7D1E:  MOVWF  FEE
7D20:  IORLW  00
7D22:  BNZ   7D1A
7D24:  MOVLB  3
7D26:  BTFSC  x7B.7
7D28:  BSF    FF2.7
7D2A:  MOVLB  0
7D2C:  BRA    7900
7D2E:  BRA    7D86
....................          case "ra" : temp="00";read_analogue();break; 
7D30:  MOVLW  03
7D32:  MOVWF  FEA
7D34:  MOVLW  77
7D36:  MOVWF  FE9
7D38:  MOVFF  FF2,37B
7D3C:  BCF    FF2.7
7D3E:  MOVLW  00
7D40:  CALL   0096
7D44:  TBLRD*-
7D46:  TBLRD*+
7D48:  MOVF   FF5,W
7D4A:  MOVWF  FEE
7D4C:  IORLW  00
7D4E:  BNZ   7D46
7D50:  MOVLB  3
7D52:  BTFSC  x7B.7
7D54:  BSF    FF2.7
7D56:  MOVLB  0
7D58:  BRA    79C8
7D5A:  BRA    7D86
....................          case "wl" : temp="00";write_lcd();break; 
7D5C:  MOVLW  03
7D5E:  MOVWF  FEA
7D60:  MOVLW  77
7D62:  MOVWF  FE9
7D64:  MOVFF  FF2,37B
7D68:  BCF    FF2.7
7D6A:  MOVLW  00
7D6C:  CALL   0096
7D70:  TBLRD*-
7D72:  TBLRD*+
7D74:  MOVF   FF5,W
7D76:  MOVWF  FEE
7D78:  IORLW  00
7D7A:  BNZ   7D72
7D7C:  MOVLB  3
7D7E:  BTFSC  x7B.7
7D80:  BSF    FF2.7
7D82:  MOVLB  0
7D84:  BRA    7A5C
....................          } 
....................       }       
7D86:  MOVLB  3
7D88:  BRA    7C1E
....................    } 
.................... delay_ms(2000); 
7D8A:  MOVLW  08
7D8C:  MOVWF  x7B
7D8E:  MOVLW  FA
7D90:  MOVWF  x94
7D92:  MOVLB  0
7D94:  CALL   051A
7D98:  MOVLB  3
7D9A:  DECFSZ x7B,F
7D9C:  BRA    7D8E
.................... lcd_putc("\fProgram end"); 
7D9E:  MOVLW  52
7DA0:  MOVWF  FF6
7DA2:  MOVLW  02
7DA4:  MOVWF  FF7
7DA6:  MOVLB  0
7DA8:  CALL   179E
.................... } 
7DAC:  SLEEP 

Configuration Fuses:
   Word  1: C200   HS FCMEN IESO
   Word  2: 0E18   PUT NOBROWNOUT BORV21 NOWDT WDT128
   Word  3: 8600   PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP BBSIZ1K NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
00AFB4: 74 65 78 74 2F 68 74 6D 6C 00 00 00 00 74 65 78 
00AFC4: 74 2F 68 74 6D 6C 00 00 00 00 74 65 78 74 2F 70 
00AFD4: 6C 61 69 6E 00 00 00 74 65 78 74 2F 78 6D 6C 00 
00AFE4: 00 00 00 00 69 6D 61 67 65 2F 67 69 66 00 00 00 
00AFF4: 00 69 6D 61 67 65 2F 6A 70 65 67 00 00 00 69 6D 
00B004: 61 67 65 2F 70 6E 67 00 00 00 00 69 6D 61 67 65 
00B014: 2F 78 2D 69 63 6F 6E 00 

00B01C: 68 74 6D 00 00 68 74 6D 6C 00 74 78 74 00 00 78 
00B02C: 6D 6C 00 00 67 69 66 00 00 6A 70 67 00 00 70 6E 
00B03C: 67 00 00 69 63 6F 00 00 

00B044: 00 33 00 00 00 49 4E 44 45 58 2E 48 54 4D 20 20 
00B054: 20 00 01 0F 00 00 49 4E 44 45 58 2E 58 4D 4C 20 
00B064: 20 20 04 FF FF FF FF 45 4E 44 20 4F 46 20 46 41 
00B074: 54 20 20 3C 68 74 6D 6C 3E 0D 0A 3C 68 65 61 64 
00B084: 3E 0D 0A 3C 73 63 72 69 70 74 20 74 79 70 65 3D 
00B094: 22 74 65 78 74 2F 6A 61 76 61 73 63 72 69 70 74 
00B0A4: 22 3E 0D 0A 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00B0B4: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00B0C4: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00B0D4: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00B0E4: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 0D 0A 2F 
00B0F4: 2F 2F 2F 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B104: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B114: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B124: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B134: 20 20 20 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 20 
00B144: 41 4A 41 58 20 72 6F 75 74 69 6E 65 73 20 66 6F 
00B154: 72 20 72 78 2F 74 78 20 6F 66 20 64 61 74 61 20 
00B164: 77 69 74 68 6F 75 74 20 68 61 76 69 6E 67 20 74 
00B174: 6F 20 72 65 6C 6F 61 64 20 70 61 67 65 2E 20 2F 
00B184: 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 20 20 20 20 20 20 
00B194: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B1A4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B1B4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B1C4: 20 20 20 20 20 20 20 20 20 20 2F 2F 2F 2F 0D 0A 
00B1D4: 2F 2F 2F 2F 20 20 57 72 69 74 74 65 6E 20 62 79 
00B1E4: 20 43 43 53 2C 20 49 6E 63 2E 20 20 20 20 20 20 
00B1F4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 68 74 
00B204: 74 70 3A 2F 2F 77 77 77 2E 63 63 73 69 6E 66 6F 
00B214: 2E 63 6F 6D 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 
00B224: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B234: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B244: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B254: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B264: 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 20 20 20 20 20 
00B274: 20 20 28 43 29 20 43 6F 70 79 72 69 67 68 74 20 
00B284: 31 39 39 36 2C 32 30 31 33 20 43 75 73 74 6F 6D 
00B294: 20 43 6F 6D 70 75 74 65 72 20 53 65 72 76 69 63 
00B2A4: 65 73 20 20 20 20 20 20 20 20 20 2F 2F 2F 2F 0D 
00B2B4: 0A 2F 2F 2F 2F 20 54 68 69 73 20 73 6F 75 72 63 
00B2C4: 65 20 63 6F 64 65 20 6D 61 79 20 6F 6E 6C 79 20 
00B2D4: 62 65 20 75 73 65 64 20 62 79 20 6C 69 63 65 6E 
00B2E4: 73 65 64 20 75 73 65 72 73 20 6F 66 20 74 68 65 
00B2F4: 20 43 43 53 20 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 
00B304: 20 43 20 63 6F 6D 70 69 6C 65 72 2E 20 20 54 68 
00B314: 69 73 20 73 6F 75 72 63 65 20 63 6F 64 65 20 6D 
00B324: 61 79 20 6F 6E 6C 79 20 62 65 20 64 69 73 74 72 
00B334: 69 62 75 74 65 64 20 74 6F 20 6F 74 68 65 72 20 
00B344: 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 20 6C 69 63 65 
00B354: 6E 73 65 64 20 75 73 65 72 73 20 6F 66 20 74 68 
00B364: 65 20 43 43 53 20 43 20 63 6F 6D 70 69 6C 65 72 
00B374: 2E 20 20 4E 6F 20 6F 74 68 65 72 20 75 73 65 2C 
00B384: 20 20 20 20 20 20 20 20 20 20 20 20 2F 2F 2F 2F 
00B394: 0D 0A 2F 2F 2F 2F 20 72 65 70 72 6F 64 75 63 74 
00B3A4: 69 6F 6E 20 6F 72 20 64 69 73 74 72 69 62 75 74 
00B3B4: 69 6F 6E 20 69 73 20 70 65 72 6D 69 74 74 65 64 
00B3C4: 20 77 69 74 68 6F 75 74 20 77 72 69 74 74 65 6E 
00B3D4: 20 20 20 20 20 20 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 
00B3E4: 2F 20 70 65 72 6D 69 73 73 69 6F 6E 2E 20 20 20 
00B3F4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B404: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B414: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00B424: 20 20 2F 2F 2F 2F 0D 0A 2F 2F 2F 2F 2F 2F 2F 2F 
00B434: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00B444: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00B454: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00B464: 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 2F 
00B474: 2F 0D 0A 76 61 72 20 61 6A 61 78 47 65 74 3B 0D 
00B484: 0A 76 61 72 20 74 3B 0D 0A 76 61 72 20 77 61 69 
00B494: 74 69 6E 67 20 3D 20 30 3B 0D 0A 76 61 72 20 74 
00B4A4: 56 61 6C 69 64 20 3D 20 30 3B 0D 0A 76 61 72 20 
00B4B4: 6E 65 78 74 43 67 69 20 3D 20 22 22 3B 0D 0A 76 
00B4C4: 61 72 20 6C 61 73 74 43 67 69 20 3D 20 22 22 3B 
00B4D4: 0D 0A 76 61 72 20 69 6F 73 36 77 6F 72 6B 61 72 
00B4E4: 6F 75 6E 64 20 3D 20 30 3B 0D 0A 0D 0A 66 75 6E 
00B4F4: 63 74 69 6F 6E 20 73 65 74 53 74 61 72 74 54 69 
00B504: 6D 65 28 29 0D 0A 7B 0D 0A 20 20 20 74 56 61 6C 
00B514: 69 64 20 3D 20 31 3B 0D 0A 20 20 20 74 20 3D 20 
00B524: 73 65 74 54 69 6D 65 6F 75 74 28 27 61 6A 61 78 
00B534: 28 29 27 2C 20 35 30 30 29 3B 0D 0A 7D 0D 0A 0D 
00B544: 0A 66 75 6E 63 74 69 6F 6E 20 61 6A 61 78 28 29 
00B554: 0D 0A 7B 0D 0A 20 20 20 69 66 20 28 77 61 69 74 
00B564: 69 6E 67 29 0D 0A 20 20 20 7B 0D 0A 20 20 20 20 
00B574: 20 20 77 61 69 74 69 6E 67 2D 2D 3B 0D 0A 20 20 
00B584: 20 20 20 20 69 66 20 28 77 61 69 74 69 6E 67 20 
00B594: 3D 3D 20 30 29 0D 0A 20 20 20 20 20 20 7B 0D 0A 
00B5A4: 20 20 20 20 20 20 20 20 20 69 66 20 28 6C 61 73 
00B5B4: 74 43 67 69 20 21 3D 20 22 22 29 0D 0A 20 20 20 
00B5C4: 20 20 20 20 20 20 7B 0D 0A 20 20 20 20 20 20 20 
00B5D4: 20 20 20 20 20 69 66 20 28 6E 65 78 74 43 67 69 
00B5E4: 20 3D 3D 20 22 22 29 0D 0A 20 20 20 20 20 20 20 
00B5F4: 20 20 20 20 20 20 20 20 6E 65 78 74 43 67 69 20 
00B604: 3D 20 6C 61 73 74 43 67 69 3B 0D 0A 20 20 20 20 
00B614: 20 20 20 20 20 20 20 20 65 6C 73 65 0D 0A 20 20 
00B624: 20 20 20 20 20 20 20 20 20 20 20 20 20 6E 65 78 
00B634: 74 43 67 69 20 3D 20 6C 61 73 74 43 67 69 20 2B 
00B644: 20 22 26 22 20 2B 20 6E 65 78 74 43 67 69 3B 0D 
00B654: 0A 20 20 20 20 20 20 20 20 20 7D 0D 0A 20 20 20 
00B664: 20 20 20 7D 0D 0A 20 20 20 7D 0D 0A 0D 0A 20 20 
00B674: 20 69 66 20 28 21 77 61 69 74 69 6E 67 29 0D 0A 
00B684: 20 20 20 7B 0D 0A 20 20 20 20 20 20 61 6A 61 78 
00B694: 47 65 74 3D 47 65 74 58 6D 6C 48 74 74 70 4F 62 
00B6A4: 6A 65 63 74 28 29 3B 0D 0A 0D 0A 20 20 20 20 20 
00B6B4: 20 69 66 20 28 61 6A 61 78 47 65 74 3D 3D 6E 75 
00B6C4: 6C 6C 29 0D 0A 20 20 20 20 20 20 7B 0D 0A 20 20 
00B6D4: 20 20 20 20 20 20 20 61 6C 65 72 74 20 28 22 59 
00B6E4: 6F 75 72 20 62 72 6F 77 73 65 72 20 64 6F 65 73 
00B6F4: 20 6E 6F 74 20 73 75 70 70 6F 72 74 20 41 4A 41 
00B704: 58 21 22 29 3B 0D 0A 20 20 20 20 20 20 20 20 20 
00B714: 72 65 74 75 72 6E 3B 0D 0A 20 20 20 20 20 20 7D 
00B724: 0D 0A 0D 0A 20 20 20 20 20 20 77 61 69 74 69 6E 
00B734: 67 20 3D 20 35 3B 20 20 2F 2F 77 61 69 74 20 32 
00B744: 2E 35 20 73 65 63 6F 6E 64 73 20 66 6F 72 20 61 
00B754: 20 72 65 73 70 6F 6E 73 65 0D 0A 0D 0A 20 20 20 
00B764: 20 20 20 61 6A 61 78 47 65 74 2E 6F 70 65 6E 28 
00B774: 22 50 4F 53 54 22 2C 20 22 69 6E 64 65 78 2E 78 
00B784: 6D 6C 22 2C 20 74 72 75 65 29 3B 0D 0A 0D 0A 20 
00B794: 20 20 20 20 20 61 6A 61 78 47 65 74 2E 6F 6E 72 
00B7A4: 65 61 64 79 73 74 61 74 65 63 68 61 6E 67 65 20 
00B7B4: 3D 20 73 74 61 74 65 43 68 61 6E 67 65 64 3B 0D 
00B7C4: 0A 0D 0A 20 20 20 20 20 20 69 66 20 28 6E 65 78 
00B7D4: 74 43 67 69 20 21 3D 20 22 22 29 0D 0A 20 20 20 
00B7E4: 20 20 20 7B 0D 0A 20 20 20 20 20 20 20 20 20 61 
00B7F4: 6A 61 78 47 65 74 2E 73 65 6E 64 28 6E 65 78 74 
00B804: 43 67 69 29 3B 0D 0A 20 20 20 20 20 20 20 20 20 
00B814: 6C 61 73 74 43 67 69 20 3D 20 6E 65 78 74 43 67 
00B824: 69 3B 0D 0A 20 20 20 20 20 20 20 20 20 6E 65 78 
00B834: 74 43 67 69 20 3D 20 22 22 3B 0D 0A 20 20 20 20 
00B844: 20 20 7D 0D 0A 20 20 20 20 20 20 65 6C 73 65 0D 
00B854: 0A 20 20 20 20 20 20 7B 0D 0A 20 20 20 20 20 20 
00B864: 20 20 20 61 6A 61 78 47 65 74 2E 73 65 6E 64 28 
00B874: 22 49 47 4E 4F 52 45 44 54 41 47 3D 22 2B 69 6F 
00B884: 73 36 77 6F 72 6B 61 72 6F 75 6E 64 29 3B 0D 0A 
00B894: 0D 0A 20 20 20 20 20 20 20 20 20 69 66 20 28 2B 
00B8A4: 2B 69 6F 73 36 77 6F 72 6B 61 72 6F 75 6E 64 20 
00B8B4: 3E 20 32 35 35 29 0D 0A 20 20 20 20 20 20 20 20 
00B8C4: 20 20 20 20 69 6F 73 36 77 6F 72 6B 61 72 6F 75 
00B8D4: 6E 64 20 3D 20 30 3B 0D 0A 20 20 20 20 20 20 7D 
00B8E4: 0D 0A 20 20 20 7D 0D 0A 0D 0A 20 20 20 73 65 74 
00B8F4: 53 74 61 72 74 54 69 6D 65 28 29 3B 0D 0A 7D 0D 
00B904: 0A 0D 0A 66 75 6E 63 74 69 6F 6E 20 73 65 6E 64 
00B914: 43 67 69 28 63 6D 64 2C 20 76 61 6C 75 65 29 0D 
00B924: 0A 7B 0D 0A 20 20 20 69 66 20 28 6E 65 78 74 43 
00B934: 67 69 20 21 3D 20 22 22 29 0D 0A 20 20 20 20 20 
00B944: 20 6E 65 78 74 43 67 69 20 2B 3D 20 22 26 22 3B 
00B954: 0D 0A 0D 0A 20 20 20 6E 65 78 74 43 67 69 20 2B 
00B964: 3D 20 63 6D 64 20 2B 20 22 3D 22 20 2B 20 76 61 
00B974: 6C 75 65 3B 0D 0A 7D 0D 0A 0D 0A 66 75 6E 63 74 
00B984: 69 6F 6E 20 47 65 74 45 6C 65 6D 65 6E 74 4E 6F 
00B994: 64 65 56 61 6C 75 65 28 78 6D 6C 44 6F 63 2C 20 
00B9A4: 69 64 29 0D 0A 7B 0D 0A 20 20 20 72 65 74 75 72 
00B9B4: 6E 20 78 6D 6C 44 6F 63 2E 67 65 74 45 6C 65 6D 
00B9C4: 65 6E 74 73 42 79 54 61 67 4E 61 6D 65 28 69 64 
00B9D4: 29 5B 30 5D 2E 63 68 69 6C 64 4E 6F 64 65 73 5B 
00B9E4: 30 5D 2E 6E 6F 64 65 56 61 6C 75 65 3B 0D 0A 7D 
00B9F4: 0D 0A 0D 0A 66 75 6E 63 74 69 6F 6E 20 47 65 74 
00BA04: 45 6C 65 6D 65 6E 74 41 74 74 72 69 62 75 74 65 
00BA14: 56 61 6C 75 65 28 78 6D 6C 44 6F 63 2C 20 65 6C 
00BA24: 65 6D 65 6E 74 2C 20 61 74 74 72 69 62 75 74 65 
00BA34: 29 0D 0A 7B 0D 0A 20 20 20 76 61 72 20 6E 3B 0D 
00BA44: 0A 20 20 20 76 61 72 20 69 3B 0D 0A 0D 0A 20 20 
00BA54: 20 6E 20 3D 20 78 6D 6C 44 6F 63 2E 67 65 74 45 
00BA64: 6C 65 6D 65 6E 74 73 42 79 54 61 67 4E 61 6D 65 
00BA74: 28 65 6C 65 6D 65 6E 74 29 5B 30 5D 2E 61 74 74 
00BA84: 72 69 62 75 74 65 73 2E 6C 65 6E 67 74 68 3B 0D 
00BA94: 0A 0D 0A 20 20 20 66 6F 72 20 28 69 3D 30 3B 20 
00BAA4: 69 3C 6E 3B 20 69 2B 2B 29 0D 0A 20 20 20 7B 0D 
00BAB4: 0A 20 20 20 20 20 20 69 66 20 28 78 6D 6C 44 6F 
00BAC4: 63 2E 67 65 74 45 6C 65 6D 65 6E 74 73 42 79 54 
00BAD4: 61 67 4E 61 6D 65 28 65 6C 65 6D 65 6E 74 29 5B 
00BAE4: 30 5D 2E 61 74 74 72 69 62 75 74 65 73 5B 69 5D 
00BAF4: 2E 6E 61 6D 65 20 3D 3D 20 61 74 74 72 69 62 75 
00BB04: 74 65 29 0D 0A 20 20 20 20 20 20 7B 0D 0A 20 20 
00BB14: 20 20 20 20 20 20 20 72 65 74 75 72 6E 20 78 6D 
00BB24: 6C 44 6F 63 2E 67 65 74 45 6C 65 6D 65 6E 74 73 
00BB34: 42 79 54 61 67 4E 61 6D 65 28 65 6C 65 6D 65 6E 
00BB44: 74 29 5B 30 5D 2E 61 74 74 72 69 62 75 74 65 73 
00BB54: 5B 69 5D 2E 76 61 6C 75 65 3B 0D 0A 20 20 20 20 
00BB64: 20 20 7D 0D 0A 20 20 20 7D 0D 0A 0D 0A 20 20 20 
00BB74: 72 65 74 75 72 6E 20 22 22 3B 0D 0A 7D 0D 0A 0D 
00BB84: 0A 66 75 6E 63 74 69 6F 6E 20 55 70 64 61 74 65 
00BB94: 45 78 69 73 74 69 6E 67 54 61 62 6C 65 28 78 6D 
00BBA4: 6C 44 6F 63 29 0D 0A 7B 0D 0A 20 20 20 76 61 72 
00BBB4: 20 69 20 3D 20 30 3B 0D 0A 0D 0A 20 20 20 66 6F 
00BBC4: 72 28 3B 3B 29 0D 0A 20 20 20 7B 0D 0A 20 20 20 
00BBD4: 20 20 20 76 61 72 20 69 64 20 3D 20 22 64 79 6E 
00BBE4: 22 2B 69 3B 0D 0A 20 20 20 20 20 20 69 2B 2B 3B 
00BBF4: 0D 0A 20 20 20 20 20 20 69 66 20 28 64 6F 63 75 
00BC04: 6D 65 6E 74 2E 67 65 74 45 6C 65 6D 65 6E 74 42 
00BC14: 79 49 64 28 69 64 29 29 0D 0A 20 20 20 20 20 20 
00BC24: 7B 0D 0A 20 20 20 20 20 20 20 20 20 64 6F 63 75 
00BC34: 6D 65 6E 74 2E 67 65 74 45 6C 65 6D 65 6E 74 42 
00BC44: 79 49 64 28 69 64 29 2E 69 6E 6E 65 72 48 54 4D 
00BC54: 4C 20 3D 20 47 65 74 45 6C 65 6D 65 6E 74 4E 6F 
00BC64: 64 65 56 61 6C 75 65 28 78 6D 6C 44 6F 63 2C 20 
00BC74: 69 64 29 3B 0D 0A 20 20 20 20 20 20 7D 0D 0A 20 
00BC84: 20 20 20 20 20 65 6C 73 65 0D 0A 20 20 20 20 20 
00BC94: 20 20 20 20 62 72 65 61 6B 3B 0D 0A 20 20 20 7D 
00BCA4: 0D 0A 7D 0D 0A 0D 0A 66 75 6E 63 74 69 6F 6E 20 
00BCB4: 73 74 61 74 65 43 68 61 6E 67 65 64 28 29 0D 0A 
00BCC4: 7B 0D 0A 20 20 20 69 66 20 28 61 6A 61 78 47 65 
00BCD4: 74 2E 72 65 61 64 79 53 74 61 74 65 3D 3D 34 29 
00BCE4: 0D 0A 20 20 20 7B 0D 0A 20 20 20 20 20 20 55 70 
00BCF4: 64 61 74 65 45 78 69 73 74 69 6E 67 54 61 62 6C 
00BD04: 65 28 61 6A 61 78 47 65 74 2E 72 65 73 70 6F 6E 
00BD14: 73 65 58 4D 4C 2E 64 6F 63 75 6D 65 6E 74 45 6C 
00BD24: 65 6D 65 6E 74 29 3B 0D 0A 0D 0A 20 20 20 20 20 
00BD34: 20 77 61 69 74 69 6E 67 20 3D 20 30 3B 0D 0A 20 
00BD44: 20 7D 0D 0A 7D 0D 0A 0D 0A 66 75 6E 63 74 69 6F 
00BD54: 6E 20 47 65 74 58 6D 6C 48 74 74 70 4F 62 6A 65 
00BD64: 63 74 28 29 0D 0A 7B 0D 0A 20 20 20 69 66 20 28 
00BD74: 77 69 6E 64 6F 77 2E 58 4D 4C 48 74 74 70 52 65 
00BD84: 71 75 65 73 74 29 0D 0A 20 20 20 7B 0D 0A 20 20 
00BD94: 20 20 20 20 2F 2F 20 63 6F 64 65 20 66 6F 72 20 
00BDA4: 49 45 37 2B 2C 20 46 69 72 65 66 6F 78 2C 20 43 
00BDB4: 68 72 6F 6D 65 2C 20 4F 70 65 72 61 2C 20 53 61 
00BDC4: 66 61 72 69 0D 0A 20 20 20 20 20 20 72 65 74 75 
00BDD4: 72 6E 20 6E 65 77 20 58 4D 4C 48 74 74 70 52 65 
00BDE4: 71 75 65 73 74 28 29 3B 0D 0A 20 20 20 7D 0D 0A 
00BDF4: 20 20 20 69 66 20 28 77 69 6E 64 6F 77 2E 41 63 
00BE04: 74 69 76 65 58 4F 62 6A 65 63 74 29 0D 0A 20 20 
00BE14: 20 7B 0D 0A 20 20 20 20 20 20 2F 2F 20 63 6F 64 
00BE24: 65 20 66 6F 72 20 49 45 36 2C 20 49 45 35 0D 0A 
00BE34: 20 20 20 20 20 20 72 65 74 75 72 6E 20 6E 65 77 
00BE44: 20 41 63 74 69 76 65 58 4F 62 6A 65 63 74 28 22 
00BE54: 4D 69 63 72 6F 73 6F 66 74 2E 58 4D 4C 48 54 54 
00BE64: 50 22 29 3B 0D 0A 20 20 20 7D 0D 0A 20 20 20 72 
00BE74: 65 74 75 72 6E 20 6E 75 6C 6C 3B 0D 0A 7D 0D 0A 
00BE84: 3C 2F 73 63 72 69 70 74 3E 0D 0A 0D 0A 0D 0A 3C 
00BE94: 74 69 74 6C 65 3E 4D 79 20 57 65 62 70 61 67 65 
00BEA4: 3C 2F 74 69 74 6C 65 3E 0D 0A 3C 2F 68 65 61 64 
00BEB4: 3E 0D 0A 0D 0A 3C 62 6F 64 79 20 6F 6E 6C 6F 61 
00BEC4: 64 3D 22 73 65 74 53 74 61 72 74 54 69 6D 65 28 
00BED4: 27 27 29 3B 22 3E 20 0D 0A 0D 0A 3C 48 31 3E 4D 
00BEE4: 79 20 57 65 62 70 61 67 65 3C 2F 48 31 3E 0D 0A 
00BEF4: 0D 0A 3C 54 41 42 4C 45 20 42 4F 52 44 45 52 3D 
00BF04: 31 3E 0D 0A 3C 2F 54 41 42 4C 45 3E 0D 0A 0D 0A 
00BF14: 3C 42 52 2F 3E 0D 0A 0D 0A 3C 46 4F 52 4D 3E 0D 
00BF24: 0A 3C 2F 46 4F 52 4D 3E 0D 0A 0D 0A 3C 2F 62 6F 
00BF34: 64 79 3E 0D 0A 3C 2F 68 74 6D 6C 3E 0D 0A 04 FF 
00BF44: FF 3C 50 49 43 54 43 50 49 50 3E 0D 0A 3C 2F 50 
00BF54: 49 43 54 43 50 49 50 3E 0D 0A 04 FF FF 2F 2A 2A 
00BF64: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
00BF74: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
00BF84: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
00BF94: 0D 0A 20 2A 20 45 6E 64 20 6F 66 20 4D 50 46 53 
00BFA4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BFB4: 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 
00BFC4: 20 20 20 20 0D 0A 20 2A 2A 2A 2A 2A 2A 2A 2A 2A 
00BFD4: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
00BFE4: 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 2A 
00BFF4: 2A 2A 2A 2A 2A 2A 2A 2A 2F 0D 0A 00 
